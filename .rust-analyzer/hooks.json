[
  {
    "HookSignature": "OnPlayerHealthChange(BasePlayer basePlayer, float oldvalue, float newvalue)",
    "MethodSignature": "OnHealthChanged(float oldvalue, float newvalue)",
    "MethodSourseCode": "\r\n\tpublic override void OnHealthChanged(float oldvalue, float newvalue)\r\n\t{\r\n\t\tif (Interface.CallHook(\u0022OnPlayerHealthChange\u0022, this, oldvalue, newvalue) == null)\r\n\t\t{\r\n\t\t\tbase.OnHealthChanged(oldvalue, newvalue);\r\n\t\t\tmetabolism.isDirty = true;\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPlayerSpectate(BasePlayer basePlayer, string spectateFilter)",
    "MethodSignature": "StartSpectating()",
    "MethodSourseCode": "\r\n\tpublic void StartSpectating()\r\n\t{\r\n\t\tif (!IsSpectating() \u0026\u0026 Interface.CallHook(\u0022OnPlayerSpectate\u0022, this, spectateFilter) == null)\r\n\t\t{\r\n\t\t\tSetPlayerFlag(PlayerFlags.Spectating, b: true);\r\n\t\t\tUnityEngine.TransformEx.SetLayerRecursive(base.gameObject, 10);\r\n\t\t\tCancelInvoke(InventoryUpdate);\r\n\t\t\tChatMessage(\u0022Becoming Spectator\u0022);\r\n\t\t\tUpdateSpectateTarget(spectateFilter);\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnItemResearch(Item targetItem, BasePlayer player)",
    "MethodSignature": "DoResearch(RPCMessage msg)",
    "MethodSourseCode": "\r\n\t[RPC_Server]\r\n\tpublic void DoResearch(RPCMessage msg)\r\n\t{\r\n\t\tif (IsResearching())\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tBasePlayer player = msg.player;\r\n\t\tItem targetItem = GetTargetItem();\r\n\t\tif (targetItem != null \u0026\u0026 Interface.CallHook(\u0022OnItemResearch\u0022, targetItem, player) == null \u0026\u0026 targetItem.amount \u003C= 1 \u0026\u0026 IsItemResearchable(targetItem))\r\n\t\t{\r\n\t\t\tInterface.CallHook(\u0022OnItemResearchStart\u0022, this);\r\n\t\t\ttargetItem.CollectedForCrafting(player);\r\n\t\t\tresearchFinishedTime = UnityEngine.Time.realtimeSinceStartup \u002B researchDuration;\r\n\t\t\tInvoke(ResearchAttemptFinished, researchDuration);\r\n\t\t\tinventory.SetLocked(isLocked: true);\r\n\t\t\tSetFlag(Flags.On, b: true);\r\n\t\t\tSendNetworkUpdate();\r\n\t\t\tplayer.inventory.loot.SendImmediate();\r\n\t\t\tif (researchStartEffect.isValid)\r\n\t\t\t{\r\n\t\t\t\tEffect.server.Run(researchStartEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "ResearchTable",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "CanNpcAttack(BaseNpc baseNpc, BaseEntity AttackTarget)",
    "MethodSignature": "StartAttack()",
    "MethodSourseCode": "\r\n\tpublic virtual void StartAttack()\r\n\t{\r\n\t\tif ((bool)AttackTarget \u0026\u0026 AttackReady() \u0026\u0026 Interface.CallHook(\u0022CanNpcAttack\u0022, this, AttackTarget) == null)\r\n\t\t{\r\n\t\t\tnextAttackTime = UnityEngine.Time.realtimeSinceStartup \u002B AttackRate;\r\n\t\t\tBaseCombatEntity combatTarget = CombatTarget;\r\n\t\t\tif ((bool)combatTarget)\r\n\t\t\t{\r\n\t\t\t\tcombatTarget.Hurt(AttackDamage, AttackDamageType, this);\r\n\t\t\t\tStamina.Use(AttackCost);\r\n\t\t\t\tBusyTimer.Activate(0.5f);\r\n\t\t\t\tSignalBroadcast(Signal.Attack);\r\n\t\t\t\tClientRPC(null, \u0022Attack\u0022, AttackTarget.ServerPosition);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "BaseNpc",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnTrapArm(BearTrap bearTrap, BasePlayer rpcPlayer)",
    "MethodSignature": "RPC_Arm(RPCMessage rpc)",
    "MethodSourseCode": "\r\n\t[RPC_Server.MaxDistance(3f)]\r\n\t[RPC_Server]\r\n\tprivate void RPC_Arm(RPCMessage rpc)\r\n\t{\r\n\t\tif (!Armed() \u0026\u0026 Interface.CallHook(\u0022OnTrapArm\u0022, this, rpc.player) == null)\r\n\t\t{\r\n\t\t\tArm();\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "BearTrap",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnResourceDepositCreated(ResourceDepositManager.ResourceDeposit resourceDeposit)",
    "MethodSignature": "CreateFromPosition(Vector3 pos)",
    "MethodSourseCode": "\r\n\tpublic ResourceDeposit CreateFromPosition(Vector3 pos)\r\n\t{\r\n\t\tVector2i indexFrom = GetIndexFrom(pos);\r\n\t\tUnityEngine.Random.State state = UnityEngine.Random.state;\r\n\t\tuint seed = new Vector2(indexFrom.x, indexFrom.y).Seed(World.Seed \u002B World.Salt);\r\n\t\tUnityEngine.Random.InitState((int)seed);\r\n\t\tResourceDeposit resourceDeposit = new ResourceDeposit();\r\n\t\tresourceDeposit.origin = new Vector3(indexFrom.x * 20, 0f, indexFrom.y * 20);\r\n\t\tfloat num = UnityEngine.Random.Range(0f, 1f);\r\n\t\tif (num \u003C 0.5f)\r\n\t\t{\r\n\t\t\tresourceDeposit.Add(ItemManager.FindItemDefinition(\u0022stones\u0022), 1f, 100, 1f, ResourceDeposit.surveySpawnType.ITEM);\r\n\t\t}\r\n\t\telse if (0 == 0)\r\n\t\t{\r\n\t\t\tresourceDeposit.Add(ItemManager.FindItemDefinition(\u0022stones\u0022), 1f, UnityEngine.Random.Range(30000, 100000), UnityEngine.Random.Range(0.3f, 0.5f), ResourceDeposit.surveySpawnType.ITEM);\r\n\t\t\tfloat num2 = 0f;\r\n\t\t\tif (World.Procedural)\r\n\t\t\t{\r\n\t\t\t\tfloat num3 = ((!(TerrainMeta.BiomeMap.GetBiome(pos, 2) \u003E 0.5f)) ? 0f : 1f);\r\n\t\t\t\tnum2 = num3 * 0.25f;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tnum2 = 0.1f;\r\n\t\t\t}\r\n\t\t\tif (UnityEngine.Random.Range(0f, 1f) \u003E= 1f - num2)\r\n\t\t\t{\r\n\t\t\t\tresourceDeposit.Add(ItemManager.FindItemDefinition(\u0022metal.ore\u0022), 1f, UnityEngine.Random.Range(10000, 100000), UnityEngine.Random.Range(2f, 4f), ResourceDeposit.surveySpawnType.ITEM);\r\n\t\t\t}\r\n\t\t\tfloat num4 = 0f;\r\n\t\t\tif (World.Procedural)\r\n\t\t\t{\r\n\t\t\t\tfloat num5 = ((!(TerrainMeta.BiomeMap.GetBiome(pos, 1) \u003E 0.5f)) ? 0f : 1f);\r\n\t\t\t\tnum4 = num5 * (0.25f \u002B 0.25f * ((!TerrainMeta.TopologyMap.GetTopology(pos, 8)) ? 0f : 1f) \u002B 0.25f * ((!TerrainMeta.TopologyMap.GetTopology(pos, 1)) ? 0f : 1f));\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tnum4 = 0.1f;\r\n\t\t\t}\r\n\t\t\tif (UnityEngine.Random.Range(0f, 1f) \u003E= 1f - num4)\r\n\t\t\t{\r\n\t\t\t\tresourceDeposit.Add(ItemManager.FindItemDefinition(\u0022sulfur.ore\u0022), 1f, UnityEngine.Random.Range(10000, 100000), UnityEngine.Random.Range(4f, 4f), ResourceDeposit.surveySpawnType.ITEM);\r\n\t\t\t}\r\n\t\t\tfloat num6 = 0f;\r\n\t\t\tif (World.Procedural)\r\n\t\t\t{\r\n\t\t\t\tif (TerrainMeta.BiomeMap.GetBiome(pos, 8) \u003E 0.5f || TerrainMeta.BiomeMap.GetBiome(pos, 4) \u003E 0.5f)\r\n\t\t\t\t{\r\n\t\t\t\t\tnum6 \u002B= 0.25f;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tnum6 \u002B= 0.15f;\r\n\t\t\t}\r\n\t\t\tif (UnityEngine.Random.Range(0f, 1f) \u003E= 1f - num6)\r\n\t\t\t{\r\n\t\t\t\tresourceDeposit.Add(ItemManager.FindItemDefinition(\u0022hq.metal.ore\u0022), 1f, UnityEngine.Random.Range(5000, 10000), UnityEngine.Random.Range(30f, 50f), ResourceDeposit.surveySpawnType.ITEM);\r\n\t\t\t}\r\n\t\t}\r\n\t\t_deposits.Add(indexFrom, resourceDeposit);\r\n\t\tInterface.CallHook(\u0022OnResourceDepositCreated\u0022, resourceDeposit);\r\n\t\tUnityEngine.Random.state = state;\r\n\t\treturn resourceDeposit;\r\n\t}\r\n",
    "ClassName": "ResourceDepositManager",
    "HookLineInvoke": 63
  },
  {
    "HookSignature": "OnItemCraft(ItemCraftTask itemCraftTask, BasePlayer owner, Item fromTempBlueprint)",
    "MethodSignature": "CraftItem(ItemBlueprint bp, BasePlayer owner, ProtoBuf.Item.InstanceData instanceData, int amount, int skinID, Item fromTempBlueprint)",
    "MethodSourseCode": "\r\n\tpublic bool CraftItem(ItemBlueprint bp, BasePlayer owner, ProtoBuf.Item.InstanceData instanceData = null, int amount = 1, int skinID = 0, Item fromTempBlueprint = null)\r\n\t{\r\n\t\tif (!CanCraft(bp, amount))\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\ttaskUID\u002B\u002B;\r\n\t\tItemCraftTask itemCraftTask = Facepunch.Pool.Get\u003CItemCraftTask\u003E();\r\n\t\titemCraftTask.blueprint = bp;\r\n\t\tCollectIngredients(bp, itemCraftTask, amount, owner);\r\n\t\titemCraftTask.endTime = 0f;\r\n\t\titemCraftTask.taskUID = taskUID;\r\n\t\titemCraftTask.owner = owner;\r\n\t\titemCraftTask.instanceData = instanceData;\r\n\t\tif (itemCraftTask.instanceData != null)\r\n\t\t{\r\n\t\t\titemCraftTask.instanceData.ShouldPool = false;\r\n\t\t}\r\n\t\titemCraftTask.amount = amount;\r\n\t\titemCraftTask.skinID = skinID;\r\n\t\tif (fromTempBlueprint != null)\r\n\t\t{\r\n\t\t\tfromTempBlueprint.RemoveFromContainer();\r\n\t\t\titemCraftTask.takenItems.Add(fromTempBlueprint);\r\n\t\t\titemCraftTask.conditionScale = 0.5f;\r\n\t\t}\r\n\t\tobject obj = Interface.CallHook(\u0022OnItemCraft\u0022, itemCraftTask, owner, fromTempBlueprint);\r\n\t\tif (obj is bool)\r\n\t\t{\r\n\t\t\treturn (bool)obj;\r\n\t\t}\r\n\t\tqueue.Enqueue(itemCraftTask);\r\n\t\tif (itemCraftTask.owner != null)\r\n\t\t{\r\n\t\t\titemCraftTask.owner.Command(\u0022note.craft_add\u0022, itemCraftTask.taskUID, itemCraftTask.blueprint.targetItem.itemid, amount, itemCraftTask.skinID);\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n",
    "ClassName": "ItemCrafter",
    "HookLineInvoke": 27
  },
  {
    "HookSignature": "OnRecyclerToggle(Recycler recycler, BasePlayer msgPlayer)",
    "MethodSignature": "SVSwitch(RPCMessage msg)",
    "MethodSourseCode": "\r\n\t[RPC_Server]\r\n\t[RPC_Server.MaxDistance(3f)]\r\n\tprivate void SVSwitch(RPCMessage msg)\r\n\t{\r\n\t\tbool flag = msg.read.Bit();\r\n\t\tif (flag != IsOn() \u0026\u0026 (!flag || HasRecyclable()) \u0026\u0026 Interface.CallHook(\u0022OnRecyclerToggle\u0022, this, msg.player) == null)\r\n\t\t{\r\n\t\t\tif (flag)\r\n\t\t\t{\r\n\t\t\t\tStartRecycling();\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tStopRecycling();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "Recycler",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnAddVendingOffer(VendingMachine vendingMachine, BasePlayer player, ProtoBuf.VendingMachine.SellOrder sellOrder)",
    "MethodSignature": "RPC_AddSellOrder(RPCMessage msg)",
    "MethodSourseCode": "\r\n\t[RPC_Server]\r\n\t[RPC_Server.IsVisible(3f)]\r\n\tpublic void RPC_AddSellOrder(RPCMessage msg)\r\n\t{\r\n\t\tBasePlayer player = msg.player;\r\n\t\tif (!CanPlayerAdmin(player))\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (sellOrders.sellOrders.Count \u003E= 7)\r\n\t\t{\r\n\t\t\tplayer.ChatMessage(\u0022Too many sell orders - remove some\u0022);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tint num = msg.read.Int32();\r\n\t\tint value = msg.read.Int32();\r\n\t\tint num2 = msg.read.Int32();\r\n\t\tint value2 = msg.read.Int32();\r\n\t\tItemDefinition itemDefinition = ItemManager.FindItemDefinition(num);\r\n\t\tItemDefinition itemDefinition2 = ItemManager.FindItemDefinition(num2);\r\n\t\tif (!(itemDefinition == null) \u0026\u0026 !(itemDefinition2 == null))\r\n\t\t{\r\n\t\t\tvalue2 = Mathf.Clamp(value2, 1, 10000);\r\n\t\t\tvalue = Mathf.Clamp(value, 1, itemDefinition.stackable);\r\n\t\t\tProtoBuf.VendingMachine.SellOrder sellOrder = new ProtoBuf.VendingMachine.SellOrder();\r\n\t\t\tsellOrder.ShouldPool = false;\r\n\t\t\tsellOrder.itemToSellID = num;\r\n\t\t\tsellOrder.itemToSellAmount = value;\r\n\t\t\tsellOrder.currencyID = num2;\r\n\t\t\tsellOrder.currencyAmountPerItem = value2;\r\n\t\t\tsellOrders.sellOrders.Add(sellOrder);\r\n\t\t\tRefreshSellOrderStockLevel(itemDefinition);\r\n\t\t\tInterface.CallHook(\u0022OnAddVendingOffer\u0022, this, player, sellOrder);\r\n\t\t\tUpdateMapMarker();\r\n\t\t\tSendNetworkUpdate();\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 33
  },
  {
    "HookSignature": "OnStructureRotate(BuildingBlock buildingBlock, BasePlayer msgPlayer)",
    "MethodSignature": "DoRotation(RPCMessage msg)",
    "MethodSourseCode": "\r\n\t[RPC_Server.MaxDistance(3f)]\r\n\t[RPC_Server]\r\n\tprivate void DoRotation(RPCMessage msg)\r\n\t{\r\n\t\tif (msg.player.CanInteract() \u0026\u0026 CanRotate(msg.player) \u0026\u0026 blockDefinition.canRotate \u0026\u0026 Interface.CallHook(\u0022OnStructureRotate\u0022, this, msg.player) == null)\r\n\t\t{\r\n\t\t\tbase.transform.localRotation *= Quaternion.Euler(blockDefinition.rotationAmount);\r\n\t\t\tRefreshEntityLinks();\r\n\t\t\tUpdateSurroundingEntities();\r\n\t\t\tif ((bool)currentSkin)\r\n\t\t\t{\r\n\t\t\t\tcurrentSkin.Refresh(this);\r\n\t\t\t}\r\n\t\t\tSendNetworkUpdateImmediate();\r\n\t\t\tClientRPC(null, \u0022RefreshSkin\u0022);\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "BuildingBlock",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "IOnBasePlayerHurt(BasePlayer basePlayer, HitInfo info)",
    "MethodSignature": "Hurt(HitInfo info)",
    "MethodSourseCode": "\r\n\tpublic override void Hurt(HitInfo info)\r\n\t{\r\n\t\tif (IsDead() || IsImmortal() || Interface.CallHook(\u0022IOnBasePlayerHurt\u0022, this, info) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (ConVar.Server.pve \u0026\u0026 (bool)info.Initiator \u0026\u0026 info.Initiator is BasePlayer \u0026\u0026 info.Initiator != this)\r\n\t\t{\r\n\t\t\tBasePlayer basePlayer = info.Initiator as BasePlayer;\r\n\t\t\tbasePlayer.Hurt(info.damageTypes.Total(), DamageType.Generic);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tmetabolism.pending_health.Subtract(info.damageTypes.Total() * 10f);\r\n\t\tbase.Hurt(info);\r\n\t\tif (EACServer.playerTracker != null \u0026\u0026 info.Initiator != null \u0026\u0026 info.Initiator is BasePlayer)\r\n\t\t{\r\n\t\t\tPlayerTakeDamage takeDamage = default(PlayerTakeDamage);\r\n\t\t\tBasePlayer basePlayer2 = info.Initiator.ToPlayer();\r\n\t\t\ttakeDamage.VictimClient = EACServer.GetClient(userID);\r\n\t\t\ttakeDamage.AttackerClient = EACServer.GetClient(basePlayer2.userID);\r\n\t\t\ttakeDamage.HitBoneID = (int)info.HitBone;\r\n\t\t\tif (info.isHeadshot)\r\n\t\t\t{\r\n\t\t\t\ttakeDamage.Flags |= PlayerTakeDamageFlags.PlayerTakeDamageFlagHeadshot;\r\n\t\t\t}\r\n\t\t\ttakeDamage.WeaponID = 0;\r\n\t\t\tif (info.Weapon != null)\r\n\t\t\t{\r\n\t\t\t\tItem item = info.Weapon.GetItem();\r\n\t\t\t\tif (item != null)\r\n\t\t\t\t{\r\n\t\t\t\t\ttakeDamage.WeaponID = item.info.itemid;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tUnityEngine.Vector3 position = basePlayer2.eyes.position;\r\n\t\t\tUnityEngine.Vector3 eulerAngles = basePlayer2.eyes.rotation.eulerAngles;\r\n\t\t\tUnityEngine.Vector3 position2 = eyes.position;\r\n\t\t\tUnityEngine.Vector3 eulerAngles2 = eyes.rotation.eulerAngles;\r\n\t\t\ttakeDamage.AttackerPosition = new EasyAntiCheat.Server.Hydra.Cerberus.Vector3(position.x, position.y, position.z);\r\n\t\t\ttakeDamage.AttackerViewAngles = new EasyAntiCheat.Server.Hydra.Cerberus.Vector3(eulerAngles.x, eulerAngles.y, eulerAngles.z);\r\n\t\t\ttakeDamage.VictimPosition = new EasyAntiCheat.Server.Hydra.Cerberus.Vector3(position2.x, position2.y, position2.z);\r\n\t\t\ttakeDamage.VictimViewAngles = new EasyAntiCheat.Server.Hydra.Cerberus.Vector3(eulerAngles2.x, eulerAngles2.y, eulerAngles2.z);\r\n\t\t\tEACServer.playerTracker.LogPlayerTakeDamage(takeDamage);\r\n\t\t}\r\n\t\tmetabolism.SendChangesToClient();\r\n\t\tif (info.PointStart != UnityEngine.Vector3.zero)\r\n\t\t{\r\n\t\t\tClientRPCPlayer(null, this, \u0022DirectionalDamage\u0022, info.PointStart, (int)info.damageTypes.GetMajorityDamageType());\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnItemAction(Item item, string text)",
    "MethodSignature": "ItemCmd(BaseEntity.RPCMessage msg)",
    "MethodSourseCode": "\r\n\t[BaseEntity.RPC_Server]\r\n\t[BaseEntity.RPC_Server.FromOwner]\r\n\tprivate void ItemCmd(BaseEntity.RPCMessage msg)\r\n\t{\r\n\t\tuint id = msg.read.UInt32();\r\n\t\tstring text = msg.read.String();\r\n\t\tItem item = FindItemUID(id);\r\n\t\tif (item == null || Interface.CallHook(\u0022OnItemAction\u0022, item, text) != null || item.IsLocked() || !CanMoveItemsFrom(item.parent.entityOwner, item))\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (text == \u0022drop\u0022)\r\n\t\t{\r\n\t\t\tint num = item.amount;\r\n\t\t\tif (msg.read.unread \u003E= 4)\r\n\t\t\t{\r\n\t\t\t\tnum = msg.read.Int32();\r\n\t\t\t}\r\n\t\t\tbase.baseEntity.stats.Add(\u0022item_drop\u0022, 1);\r\n\t\t\tif (num \u003C item.amount)\r\n\t\t\t{\r\n\t\t\t\titem.SplitItem(num)?.Drop(base.baseEntity.eyes.position, base.baseEntity.eyes.BodyForward() * 4f \u002B Vector3Ex.Range(-0.5f, 0.5f));\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\titem.Drop(base.baseEntity.eyes.position, base.baseEntity.eyes.BodyForward() * 4f \u002B Vector3Ex.Range(-0.5f, 0.5f));\r\n\t\t\t}\r\n\t\t\tbase.baseEntity.SignalBroadcast(BaseEntity.Signal.Gesture, \u0022drop_item\u0022);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\titem.ServerCommand(text, base.baseEntity);\r\n\t\t\tItemManager.DoRemoves();\r\n\t\t\tServerUpdate(0f);\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "PlayerInventory",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnHealingItemUse(MedicalTool medicalTool, BasePlayer player)",
    "MethodSignature": "GiveEffectsTo(BasePlayer player)",
    "MethodSourseCode": "\r\n\tprivate void GiveEffectsTo(BasePlayer player)\r\n\t{\r\n\t\tif (!player)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tItemModConsumable component = GetOwnerItemDefinition().GetComponent\u003CItemModConsumable\u003E();\r\n\t\tif (!component)\r\n\t\t{\r\n\t\t\tDebug.LogWarning(\u0022No consumable for medicaltool :\u0022 \u002B base.name);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tif (Interface.CallHook(\u0022OnHealingItemUse\u0022, this, player) != null)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tif (player != GetOwnerPlayer() \u0026\u0026 player.IsWounded() \u0026\u0026 canRevive)\r\n\t\t\t{\r\n\t\t\t\tif (Interface.CallHook(\u0022IOnPlayerRevive\u0022, this, player) != null)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tplayer.StopWounded();\r\n\t\t\t}\r\n\t\t\tforeach (ItemModConsumable.ConsumableEffect effect in component.effects)\r\n\t\t\t{\r\n\t\t\t\tif (effect.type == MetabolismAttribute.Type.Health)\r\n\t\t\t\t{\r\n\t\t\t\t\tplayer.health \u002B= effect.amount;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tplayer.metabolism.ApplyChange(effect.type, effect.amount, effect.time);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "MedicalTool",
    "HookLineInvoke": 14
  },
  {
    "HookSignature": "CanChangeGrade(BasePlayer player, BuildingBlock buildingBlock, BuildingGrade.Enum iGrade)",
    "MethodSignature": "CanChangeToGrade(BuildingGrade.Enum iGrade, BasePlayer player)",
    "MethodSourseCode": "\r\n\tprivate bool CanChangeToGrade(BuildingGrade.Enum iGrade, BasePlayer player)\r\n\t{\r\n\t\tobject obj = Interface.CallHook(\u0022CanChangeGrade\u0022, player, this, iGrade);\r\n\t\tif (obj is bool)\r\n\t\t{\r\n\t\t\treturn (bool)obj;\r\n\t\t}\r\n\t\treturn HasUpgradePrivilege(iGrade, player) \u0026\u0026 !IsUpgradeBlocked();\r\n\t}\r\n",
    "ClassName": "BuildingBlock",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanRecycle(Recycler recycler, Item slot)",
    "MethodSignature": "HasRecyclable()",
    "MethodSourseCode": "\r\n\tpublic bool HasRecyclable()\r\n\t{\r\n\t\tfor (int i = 0; i \u003C 6; i\u002B\u002B)\r\n\t\t{\r\n\t\t\tItem slot = inventory.GetSlot(i);\r\n\t\t\tif (slot != null)\r\n\t\t\t{\r\n\t\t\t\tobject obj = Interface.CallHook(\u0022CanRecycle\u0022, this, slot);\r\n\t\t\t\tif (obj is bool)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn (bool)obj;\r\n\t\t\t\t}\r\n\t\t\t\tif (slot.info.Blueprint != null)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n",
    "ClassName": "Recycler",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnWeaponFired(BaseProjectile baseProjectile, BasePlayer msgPlayer, ItemModProjectile component, ProtoBuf.ProjectileShoot projectileShoot)",
    "MethodSignature": "CLProject(RPCMessage msg)",
    "MethodSourseCode": "\r\n\t[RPC_Server]\r\n\t[RPC_Server.FromOwner]\r\n\tprivate void CLProject(RPCMessage msg)\r\n\t{\r\n\t\tBasePlayer player = msg.player;\r\n\t\tif (!VerifyClientAttack(player))\r\n\t\t{\r\n\t\t\tSendNetworkUpdate();\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (reloadFinished \u0026\u0026 HasReloadCooldown())\r\n\t\t{\r\n\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Reloading (\u0022 \u002B base.ShortPrefabName \u002B \u0022)\u0022);\r\n\t\t\tplayer.stats.combat.Log(this, \u0022reload_cooldown\u0022);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\treloadStarted = false;\r\n\t\treloadFinished = false;\r\n\t\tif (primaryMagazine.contents \u003C= 0 \u0026\u0026 !UsingInfiniteAmmoCheat)\r\n\t\t{\r\n\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Magazine empty (\u0022 \u002B base.ShortPrefabName \u002B \u0022)\u0022);\r\n\t\t\tplayer.stats.combat.Log(this, \u0022ammo_missing\u0022);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tItemDefinition ammoType = primaryMagazine.ammoType;\r\n\t\tProjectileShoot projectileShoot = ProjectileShoot.Deserialize(msg.read);\r\n\t\tif (ammoType.itemid != projectileShoot.ammoType)\r\n\t\t{\r\n\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Ammo mismatch (\u0022 \u002B base.ShortPrefabName \u002B \u0022)\u0022);\r\n\t\t\tplayer.stats.combat.Log(this, \u0022ammo_mismatch\u0022);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (!UsingInfiniteAmmoCheat)\r\n\t\t{\r\n\t\t\tprimaryMagazine.contents--;\r\n\t\t}\r\n\t\tItemModProjectile component = ammoType.GetComponent\u003CItemModProjectile\u003E();\r\n\t\tif (component == null)\r\n\t\t{\r\n\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Item mod not found (\u0022 \u002B base.ShortPrefabName \u002B \u0022)\u0022);\r\n\t\t\tplayer.stats.combat.Log(this, \u0022mod_missing\u0022);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (projectileShoot.projectiles.Count \u003E component.numProjectiles)\r\n\t\t{\r\n\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Count mismatch (\u0022 \u002B base.ShortPrefabName \u002B \u0022)\u0022);\r\n\t\t\tplayer.stats.combat.Log(this, \u0022count_mismatch\u0022);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tInterface.CallHook(\u0022OnWeaponFired\u0022, this, msg.player, component, projectileShoot);\r\n\t\tSignalBroadcast(Signal.Attack, string.Empty, msg.connection);\r\n\t\tplayer.CleanupExpiredProjectiles();\r\n\t\tforeach (ProjectileShoot.Projectile projectile in projectileShoot.projectiles)\r\n\t\t{\r\n\t\t\tif (player.HasFiredProjectile(projectile.projectileID))\r\n\t\t\t{\r\n\t\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Duplicate ID (\u0022 \u002B projectile.projectileID \u002B \u0022)\u0022);\r\n\t\t\t\tplayer.stats.combat.Log(this, \u0022duplicate_id\u0022);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tplayer.NoteFiredProjectile(projectile.projectileID, projectile.startPos, projectile.startVel, this, ammoType);\r\n\t\t\t\tCreateProjectileEffectClientside(component.projectileObject.resourcePath, projectile.startPos, projectile.startVel, projectile.seed, msg.connection, IsSilenced());\r\n\t\t\t}\r\n\t\t}\r\n\t\tplayer.stats.Add(component.category \u002B \u0022_fired\u0022, projectileShoot.projectiles.Count());\r\n\t\tStartAttackCooldown(ScaleRepeatDelay(repeatDelay));\r\n\t\tUpdateItemCondition();\r\n\t\tSensation sensation = default(Sensation);\r\n\t\tsensation.Type = SensationType.Gunshot;\r\n\t\tsensation.Position = player.GetNetworkPosition();\r\n\t\tsensation.Radius = 100f;\r\n\t\tSense.Stimulate(sensation);\r\n\t\tif (EACServer.playerTracker == null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tusing (TimeWarning.New(\u0022LogPlayerShooting\u0022))\r\n\t\t{\r\n\t\t\tUnityEngine.Vector3 networkPosition = player.GetNetworkPosition();\r\n\t\t\tUnityEngine.Vector3 networkRotation = player.GetNetworkRotation();\r\n\t\t\tint weaponID = GetItem()?.info.itemid ?? 0;\r\n\t\t\tPlayerUseWeapon useWeapon = default(PlayerUseWeapon);\r\n\t\t\tuseWeapon.Client = EACServer.GetClient(player.userID);\r\n\t\t\tuseWeapon.PlayerPosition = new EasyAntiCheat.Server.Hydra.Cerberus.Vector3(networkPosition.x, networkPosition.y, networkPosition.z);\r\n\t\t\tuseWeapon.PlayerViewAngles = new EasyAntiCheat.Server.Hydra.Cerberus.Vector3(networkRotation.x, networkRotation.y, networkRotation.z);\r\n\t\t\tuseWeapon.WeaponID = weaponID;\r\n\t\t\tEACServer.playerTracker.LogPlayerUseWeapon(useWeapon);\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "BaseProjectile",
    "HookLineInvoke": 50
  },
  {
    "HookSignature": "OnSpinWheel(BasePlayer rpcPlayer, SpinnerWheel spinnerWheel)",
    "MethodSignature": "RPC_Spin(RPCMessage rpc)",
    "MethodSourseCode": "\r\n\t[RPC_Server]\r\n\t[RPC_Server.MaxDistance(3f)]\r\n\tprivate void RPC_Spin(RPCMessage rpc)\r\n\t{\r\n\t\tif (rpc.player.CanInteract() \u0026\u0026 (AnyoneSpin() || rpc.player.CanBuild()))\r\n\t\t{\r\n\t\t\tInterface.CallHook(\u0022OnSpinWheel\u0022, rpc.player, this);\r\n\t\t\tif (!(velocity \u003E 15f))\r\n\t\t\t{\r\n\t\t\t\tvelocity \u002B= UnityEngine.Random.Range(4f, 7f);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "SpinnerWheel",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "CanDemolish(BasePlayer player, BuildingBlock buildingBlock)",
    "MethodSignature": "CanDemolish(BasePlayer player)",
    "MethodSourseCode": "\r\n\tprivate bool CanDemolish(BasePlayer player)\r\n\t{\r\n\t\tobject obj = Interface.CallHook(\u0022CanDemolish\u0022, player, this);\r\n\t\tif (obj is bool)\r\n\t\t{\r\n\t\t\treturn (bool)obj;\r\n\t\t}\r\n\t\treturn IsDemolishable() \u0026\u0026 HasDemolishPrivilege(player);\r\n\t}\r\n",
    "ClassName": "BuildingBlock",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnCropGather(PlantEntity plantEntity, Item item, BasePlayer msgPlayer)",
    "MethodSignature": "RPC_PickFruit(RPCMessage msg)",
    "MethodSourseCode": "\r\n\t[RPC_Server.MaxDistance(3f)]\r\n\t[RPC_Server]\r\n\tpublic void RPC_PickFruit(RPCMessage msg)\r\n\t{\r\n\t\tif (!CanPick())\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tharvests\u002B\u002B;\r\n\t\tfloat num = YieldBonusScale() * (float)plantProperty.waterYieldBonus;\r\n\t\tint num2 = Mathf.RoundToInt((currentStage.resources \u002B num) * (float)plantProperty.pickupAmount);\r\n\t\tResetSeason();\r\n\t\tif (plantProperty.pickupItem.condition.enabled)\r\n\t\t{\r\n\t\t\tfor (int i = 0; i \u003C num2; i\u002B\u002B)\r\n\t\t\t{\r\n\t\t\t\tItem item = ItemManager.Create(plantProperty.pickupItem, 1, 0uL);\r\n\t\t\t\titem.conditionNormalized = plantProperty.fruitCurve.Evaluate(ageFraction);\r\n\t\t\t\tInterface.CallHook(\u0022OnCropGather\u0022, this, item, msg.player);\r\n\t\t\t\tmsg.player.GiveItem(item, GiveItemReason.PickedUp);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tItem item2 = ItemManager.Create(plantProperty.pickupItem, num2, 0uL);\r\n\t\t\tInterface.CallHook(\u0022OnCropGather\u0022, this, item2, msg.player);\r\n\t\t\tmsg.player.GiveItem(item2, GiveItemReason.PickedUp);\r\n\t\t}\r\n\t\tif (plantProperty.pickEffect.isValid)\r\n\t\t{\r\n\t\t\tEffect.server.Run(plantProperty.pickEffect.resourcePath, GetEstimatedWorldPosition(), Vector3.up);\r\n\t\t}\r\n\t\tif (harvests \u003E= plantProperty.maxHarvests)\r\n\t\t{\r\n\t\t\tif (plantProperty.disappearAfterHarvest)\r\n\t\t\t{\r\n\t\t\t\tDie();\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tBecomeState(PlantProperties.State.Dying);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tBecomeState(PlantProperties.State.Mature);\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "PlantEntity",
    "HookLineInvoke": 19
  },
  {
    "HookSignature": "OnOvenToggle(BaseOven baseOven, BasePlayer msgPlayer)",
    "MethodSignature": "SVSwitch(RPCMessage msg)",
    "MethodSourseCode": "\r\n\t[RPC_Server]\r\n\t[RPC_Server.MaxDistance(3f)]\r\n\tprivate void SVSwitch(RPCMessage msg)\r\n\t{\r\n\t\tbool flag = msg.read.Bit();\r\n\t\tif (flag != IsOn() \u0026\u0026 Interface.CallHook(\u0022OnOvenToggle\u0022, this, msg.player) == null \u0026\u0026 (!needsBuildingPrivilegeToUse || msg.player.CanBuild()))\r\n\t\t{\r\n\t\t\tif (flag)\r\n\t\t\t{\r\n\t\t\t\tStartCooking();\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tStopCooking();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "BaseOven",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "CanBuild(Planner planner, Construction construction, UnityEngine.Vector3 msgPosition)",
    "MethodSignature": "DoBuild(CreateBuilding msg)",
    "MethodSourseCode": "\r\n\tpublic void DoBuild(CreateBuilding msg)\r\n\t{\r\n\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\r\n\t\tif (!ownerPlayer)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (ConVar.AntiHack.objectplacement \u0026\u0026 ownerPlayer.TriggeredAntiHack())\r\n\t\t{\r\n\t\t\townerPlayer.ChatMessage(\u0022AntiHack!\u0022);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tConstruction construction = PrefabAttribute.server.Find\u003CConstruction\u003E(msg.blockID);\r\n\t\tif (construction == null)\r\n\t\t{\r\n\t\t\townerPlayer.ChatMessage(\u0022Couldn\u0027t find Construction \u0022 \u002B msg.blockID);\r\n\t\t}\r\n\t\telse if (!CanAffordToPlace(construction))\r\n\t\t{\r\n\t\t\townerPlayer.ChatMessage(\u0022Can\u0027t afford to place!\u0022);\r\n\t\t}\r\n\t\telse if (!ownerPlayer.CanBuild() \u0026\u0026 !construction.canBypassBuildingPermission)\r\n\t\t{\r\n\t\t\townerPlayer.ChatMessage(\u0022Building is blocked!\u0022);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tif (Interface.CallHook(\u0022CanBuild\u0022, this, construction, msg.position) != null)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tConstruction.Target target = default(Construction.Target);\r\n\t\t\tBaseNetworkable baseNetworkable = null;\r\n\t\t\tif (msg.entity != 0)\r\n\t\t\t{\r\n\t\t\t\tbaseNetworkable = BaseNetworkable.serverEntities.Find(msg.entity);\r\n\t\t\t\tif (!baseNetworkable)\r\n\t\t\t\t{\r\n\t\t\t\t\townerPlayer.ChatMessage(\u0022Couldn\u0027t find entity \u0022 \u002B msg.entity);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\ttarget.construction = baseNetworkable.GetComponent\u003CBuildingBlock\u003E();\r\n\t\t\t\ttarget.transformParent = baseNetworkable.GetComponent\u003CBaseEntity\u003E();\r\n\t\t\t\tif (msg.socket != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tstring text = StringPool.Get(msg.socket);\r\n\t\t\t\t\tif (text != string.Empty \u0026\u0026 target.transformParent != null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\ttarget.socket = FindSocket(text, target.transformParent.prefabID);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\townerPlayer.ChatMessage(\u0022Invalid Socket!\u0022);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tDebug.Log(\u0022socket was 0\u0022);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\ttarget.ray = msg.ray;\r\n\t\t\ttarget.onTerrain = msg.onterrain;\r\n\t\t\ttarget.position = msg.position;\r\n\t\t\ttarget.normal = msg.normal;\r\n\t\t\ttarget.rotation = msg.rotation;\r\n\t\t\ttarget.player = ownerPlayer;\r\n\t\t\ttarget.valid = true;\r\n\t\t\tDeployable deployable = GetDeployable();\r\n\t\t\tif ((bool)deployable \u0026\u0026 deployable.placeEffect.isValid)\r\n\t\t\t{\r\n\t\t\t\tif ((bool)baseNetworkable \u0026\u0026 msg.socket != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tEffect.server.Run(deployable.placeEffect.resourcePath, baseNetworkable.transform.TransformPoint(target.socket.worldPosition), baseNetworkable.transform.up);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tEffect.server.Run(deployable.placeEffect.resourcePath, msg.position, msg.normal);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tDoBuild(target, construction);\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "Planner",
    "HookLineInvoke": 28
  },
  {
    "HookSignature": "OnDispenserGather(ResourceDispenser resourceDispenser, BaseEntity entity, Item item)",
    "MethodSignature": "GiveResourceFromItem(BaseEntity entity, ItemAmount itemAmt, float gatherDamage, float destroyFraction, AttackEntity attackWeapon)",
    "MethodSourseCode": "\r\n\tprivate void GiveResourceFromItem(BaseEntity entity, ItemAmount itemAmt, float gatherDamage, float destroyFraction, AttackEntity attackWeapon)\r\n\t{\r\n\t\tif (itemAmt.amount == 0f)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tfloat num = Mathf.Min(gatherDamage, base.baseEntity.Health()) / base.baseEntity.MaxHealth();\r\n\t\tfloat num2 = itemAmt.startAmount / startingItemCounts;\r\n\t\tfloat value = itemAmt.startAmount * num / num2;\r\n\t\tfloat num3 = Mathf.Clamp(value, 0f, itemAmt.amount);\r\n\t\tfloat num4 = num3 * destroyFraction * 2f;\r\n\t\tif (itemAmt.amount \u003C= num3 \u002B num4)\r\n\t\t{\r\n\t\t\tfloat num5 = (num3 \u002B num4) / itemAmt.amount;\r\n\t\t\tnum3 /= num5;\r\n\t\t\tnum4 /= num5;\r\n\t\t}\r\n\t\tfloat amount = itemAmt.amount;\r\n\t\titemAmt.amount -= Mathf.Floor(num3);\r\n\t\titemAmt.amount -= Mathf.Floor(num4);\r\n\t\tif (num3 \u003C 1f)\r\n\t\t{\r\n\t\t\tnum3 = ((!(UnityEngine.Random.Range(0f, 1f) \u003C= num3)) ? 0f : 1f);\r\n\t\t\titemAmt.amount = 0f;\r\n\t\t}\r\n\t\tif (itemAmt.amount \u003C 0f)\r\n\t\t{\r\n\t\t\titemAmt.amount = 0f;\r\n\t\t}\r\n\t\tif (num3 \u003E= 1f)\r\n\t\t{\r\n\t\t\tItem item = ItemManager.CreateByItemID(itemAmt.itemid, Mathf.FloorToInt(num3), 0uL);\r\n\t\t\tif (item != null)\r\n\t\t\t{\r\n\t\t\t\tInterface.CallHook(\u0022OnDispenserGather\u0022, this, entity, item);\r\n\t\t\t\tOverrideOwnership(item, attackWeapon);\r\n\t\t\t\tentity.GiveItem(item, BaseEntity.GiveItemReason.ResourceHarvested);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "ResourceDispenser",
    "HookLineInvoke": 35
  },
  {
    "HookSignature": "OnExplosiveThrown(BasePlayer msgPlayer, BaseEntity baseEntity)",
    "MethodSignature": "DoThrow(RPCMessage msg)",
    "MethodSourseCode": "\r\n\t[RPC_Server]\r\n\t[RPC_Server.IsActiveItem]\r\n\tprivate void DoThrow(RPCMessage msg)\r\n\t{\r\n\t\tif (!HasItemAmount() || HasAttackCooldown())\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tVector3 vector = msg.read.Vector3();\r\n\t\tVector3 normalized = msg.read.Vector3().normalized;\r\n\t\tfloat num = Mathf.Clamp01(msg.read.Float());\r\n\t\tif (!ValidateEyePos(msg.player, vector))\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(prefabToThrow.resourcePath, vector, Quaternion.LookRotation((!(overrideAngle == Vector3.zero)) ? overrideAngle : (-normalized)));\r\n\t\tif (!(baseEntity == null))\r\n\t\t{\r\n\t\t\tbaseEntity.creatorEntity = msg.player;\r\n\t\t\tbaseEntity.SetVelocity(normalized * maxThrowVelocity * num);\r\n\t\t\tif (tumbleVelocity \u003E 0f)\r\n\t\t\t{\r\n\t\t\t\tbaseEntity.SetAngularVelocity(new Vector3(UnityEngine.Random.Range(-1f, 1f), UnityEngine.Random.Range(-1f, 1f), UnityEngine.Random.Range(-1f, 1f)) * tumbleVelocity);\r\n\t\t\t}\r\n\t\t\tbaseEntity.Spawn();\r\n\t\t\tInterface.CallHook(\u0022OnExplosiveThrown\u0022, msg.player, baseEntity);\r\n\t\t\tStartAttackCooldown(repeatDelay);\r\n\t\t\tUseItemAmount(1);\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "ThrownWeapon",
    "HookLineInvoke": 26
  },
  {
    "HookSignature": "OnEntityKill(BaseNetworkable baseNetworkable)",
    "MethodSignature": "Kill(DestroyMode mode)",
    "MethodSourseCode": "\r\n\tpublic void Kill(DestroyMode mode = DestroyMode.None)\r\n\t{\r\n\t\tif (IsDestroyed)\r\n\t\t{\r\n\t\t\tDebug.LogWarning(\u0022Calling kill - but already IsDestroyed!? \u0022 \u002B this);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tInterface.CallHook(\u0022OnEntityKill\u0022, this);\r\n\t\tOnParentDestroyingEx.BroadcastOnParentDestroying(base.gameObject);\r\n\t\tTerm(mode);\r\n\t\tDoEntityDestroy();\r\n\t\tEntityDestroy();\r\n\t}\r\n",
    "ClassName": "BaseNetworkable",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "CanChangeCode(CodeLock codeLock, BasePlayer rpcPlayer, string text, bool flag)",
    "MethodSignature": "RPC_ChangeCode(RPCMessage rpc)",
    "MethodSourseCode": "\r\n\t[RPC_Server]\r\n\t[RPC_Server.MaxDistance(3f)]\r\n\tprivate void RPC_ChangeCode(RPCMessage rpc)\r\n\t{\r\n\t\tif (!rpc.player.CanInteract())\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tstring text = rpc.read.String();\r\n\t\tbool flag = rpc.read.Bit();\r\n\t\tif (IsLocked() || text.Length != 4 || (!hasCode \u0026\u0026 flag))\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (!hasCode \u0026\u0026 !flag)\r\n\t\t{\r\n\t\t\tSetFlag(Flags.Locked, b: true);\r\n\t\t}\r\n\t\tif (Interface.CallHook(\u0022CanChangeCode\u0022, this, rpc.player, text, flag) == null)\r\n\t\t{\r\n\t\t\tif (!flag)\r\n\t\t\t{\r\n\t\t\t\tcode = text;\r\n\t\t\t\thasCode = code.Length \u003E 0;\r\n\t\t\t\twhitelistPlayers.Clear();\r\n\t\t\t\twhitelistPlayers.Add(rpc.player.userID);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tguestCode = text;\r\n\t\t\t\thasGuestCode = guestCode.Length \u003E 0;\r\n\t\t\t\tguestPlayers.Clear();\r\n\t\t\t\tguestPlayers.Add(rpc.player.userID);\r\n\t\t\t}\r\n\t\t\tDoEffect(effectCodeChanged.resourcePath);\r\n\t\t\tSendNetworkUpdate();\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "CodeLock",
    "HookLineInvoke": 19
  },
  {
    "HookSignature": "CanMoveItem(Item item, PlayerInventory playerInventory, uint num, int num2, int num3)",
    "MethodSignature": "MoveItem(BaseEntity.RPCMessage msg)",
    "MethodSourseCode": "\r\n\t[BaseEntity.RPC_Server]\r\n\t[BaseEntity.RPC_Server.FromOwner]\r\n\tprivate void MoveItem(BaseEntity.RPCMessage msg)\r\n\t{\r\n\t\tuint id = msg.read.UInt32();\r\n\t\tuint num = msg.read.UInt32();\r\n\t\tint num2 = msg.read.Int8();\r\n\t\tint num3 = msg.read.UInt16();\r\n\t\tItem item = FindItemUID(id);\r\n\t\tif (item == null || Interface.CallHook(\u0022CanMoveItem\u0022, item, this, num, num2, num3) != null || !CanMoveItemsFrom(item.parent.entityOwner, item))\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (num3 \u003C= 0)\r\n\t\t{\r\n\t\t\tnum3 = item.amount;\r\n\t\t}\r\n\t\tnum3 = Mathf.Clamp(num3, 1, item.info.stackable);\r\n\t\tif (num == 0)\r\n\t\t{\r\n\t\t\tGiveItem(item);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tItemContainer itemContainer = FindContainer(num);\r\n\t\tif (itemContainer == null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tItemContainer parent = item.parent;\r\n\t\tif ((parent != null \u0026\u0026 parent.IsLocked()) || itemContainer.IsLocked() || itemContainer.PlayerItemInputBlocked())\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tusing (TimeWarning.New(\u0022Split\u0022))\r\n\t\t{\r\n\t\t\tif (item.amount \u003E num3)\r\n\t\t\t{\r\n\t\t\t\tItem item2 = item.SplitItem(num3);\r\n\t\t\t\tif (!item2.MoveToContainer(itemContainer, num2))\r\n\t\t\t\t{\r\n\t\t\t\t\titem.amount \u002B= item2.amount;\r\n\t\t\t\t\titem2.Remove();\r\n\t\t\t\t}\r\n\t\t\t\tItemManager.DoRemoves();\r\n\t\t\t\tServerUpdate(0f);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (item.MoveToContainer(itemContainer, num2))\r\n\t\t{\r\n\t\t\tItemManager.DoRemoves();\r\n\t\t\tServerUpdate(0f);\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "PlayerInventory",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnTrapDisarm(Landmine landmine, BasePlayer rpcPlayer)",
    "MethodSignature": "RPC_Disarm(RPCMessage rpc)",
    "MethodSourseCode": "\r\n\t[RPC_Server]\r\n\tprivate void RPC_Disarm(RPCMessage rpc)\r\n\t{\r\n\t\tif (rpc.player.net.ID != triggerPlayerID \u0026\u0026 Armed() \u0026\u0026 Interface.CallHook(\u0022OnTrapDisarm\u0022, this, rpc.player) == null)\r\n\t\t{\r\n\t\t\tSetFlag(Flags.On, b: false);\r\n\t\t\tint num = UnityEngine.Random.Range(0, 100);\r\n\t\t\tif (num \u003C 15)\r\n\t\t\t{\r\n\t\t\t\tInvoke(TryExplode, 0.05f);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\trpc.player.GiveItem(ItemManager.CreateByName(\u0022trap.landmine\u0022, 1, 0uL), GiveItemReason.PickedUp);\r\n\t\t\tKill();\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "Landmine",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "CanEquipItem(PlayerInventory playerInventory, Item item)",
    "MethodSignature": "CanEquipItem(Item item)",
    "MethodSourseCode": "\r\n\tprivate bool CanEquipItem(Item item)\r\n\t{\r\n\t\tobject obj = Interface.CallHook(\u0022CanEquipItem\u0022, this, item);\r\n\t\tif (obj is bool)\r\n\t\t{\r\n\t\t\treturn (bool)obj;\r\n\t\t}\r\n\t\tItemModContainerRestriction component = item.info.GetComponent\u003CItemModContainerRestriction\u003E();\r\n\t\tif (component == null)\r\n\t\t{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tItem[] array = containerBelt.itemList.ToArray();\r\n\t\tforeach (Item item2 in array)\r\n\t\t{\r\n\t\t\tif (item2 != item)\r\n\t\t\t{\r\n\t\t\t\tItemModContainerRestriction component2 = item2.info.GetComponent\u003CItemModContainerRestriction\u003E();\r\n\t\t\t\tif (!(component2 == null) \u0026\u0026 !component.CanExistWith(component2) \u0026\u0026 !item2.MoveToContainer(containerMain))\r\n\t\t\t\t{\r\n\t\t\t\t\titem2.Drop(base.baseEntity.eyes.position, base.baseEntity.eyes.BodyForward() * 2f);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n",
    "ClassName": "PlayerInventory",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnItemAddedToContainer(ItemContainer itemContainer, Item item)",
    "MethodSignature": "Insert(Item item)",
    "MethodSourseCode": "\r\n\tpublic bool Insert(Item item)\r\n\t{\r\n\t\tif (itemList.Contains(item))\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (IsFull())\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\titemList.Add(item);\r\n\t\titem.parent = this;\r\n\t\tif (!FindPosition(item))\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tMarkDirty();\r\n\t\tif (onItemAddedRemoved != null)\r\n\t\t{\r\n\t\t\tonItemAddedRemoved(item, arg2: true);\r\n\t\t}\r\n\t\tInterface.CallHook(\u0022OnItemAddedToContainer\u0022, this, item);\r\n\t\treturn true;\r\n\t}\r\n",
    "ClassName": "ItemContainer",
    "HookLineInvoke": 22
  },
  {
    "HookSignature": "CanAdministerVending(VendingMachine vendingMachine, BasePlayer player)",
    "MethodSignature": "CanPlayerAdmin(BasePlayer player)",
    "MethodSourseCode": "\r\n\tpublic bool CanPlayerAdmin(BasePlayer player)\r\n\t{\r\n\t\tobject obj = Interface.CallHook(\u0022CanAdministerVending\u0022, this, player);\r\n\t\tif (obj is bool)\r\n\t\t{\r\n\t\t\treturn (bool)obj;\r\n\t\t}\r\n\t\treturn PlayerBehind(player);\r\n\t}\r\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnDoorOpened(Door door, BasePlayer rpcPlayer)",
    "MethodSignature": "RPC_OpenDoor(RPCMessage rpc)",
    "MethodSourseCode": "\r\n\t[RPC_Server]\r\n\t[RPC_Server.MaxDistance(3f)]\r\n\tprivate void RPC_OpenDoor(RPCMessage rpc)\r\n\t{\r\n\t\tif (!rpc.player.CanInteract() || IsOpen() || IsBusy() || IsLocked())\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tBaseLock baseLock = GetSlot(Slot.Lock) as BaseLock;\r\n\t\tif (baseLock != null)\r\n\t\t{\r\n\t\t\tif (!baseLock.OnTryToOpen(rpc.player))\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tif (baseLock.IsLocked() \u0026\u0026 UnityEngine.Time.realtimeSinceStartup - decayResetTimeLast \u003E 60f)\r\n\t\t\t{\r\n\t\t\t\tBuildingBlock buildingBlock = FindLinkedEntity\u003CBuildingBlock\u003E();\r\n\t\t\t\tif ((bool)buildingBlock)\r\n\t\t\t\t{\r\n\t\t\t\t\tDecay.BuildingDecayTouch(buildingBlock);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tDecay.RadialDecayTouch(base.transform.position, 40f, 2097408);\r\n\t\t\t\t}\r\n\t\t\t\tdecayResetTimeLast = UnityEngine.Time.realtimeSinceStartup;\r\n\t\t\t}\r\n\t\t}\r\n\t\tSetFlag(Flags.Open, b: true);\r\n\t\tSendNetworkUpdateImmediate();\r\n\t\tInterface.CallHook(\u0022OnDoorOpened\u0022, this, rpc.player);\r\n\t}\r\n",
    "ClassName": "Door",
    "HookLineInvoke": 32
  },
  {
    "HookSignature": "IOnLootItem(PlayerLoot playerLoot, Item item)",
    "MethodSignature": "StartLootingItem(Item item)",
    "MethodSourseCode": "\r\n\tpublic void StartLootingItem(Item item)\r\n\t{\r\n\t\tClear();\r\n\t\tif (item != null \u0026\u0026 item.contents != null)\r\n\t\t{\r\n\t\t\tPositionChecks = true;\r\n\t\t\tcontainers.Add(item.contents);\r\n\t\t\titem.contents.onDirty \u002B= MarkDirty;\r\n\t\t\titemSource = item;\r\n\t\t\tentitySource = item.GetWorldEntity();\r\n\t\t\tMarkDirty();\r\n\t\t\tInterface.CallHook(\u0022IOnLootItem\u0022, this, item);\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "PlayerLoot",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "OnPlayerSpectateEnd(BasePlayer basePlayer, string spectateFilter)",
    "MethodSignature": "StopSpectating()",
    "MethodSourseCode": "\r\n\tpublic void StopSpectating()\r\n\t{\r\n\t\tif (IsSpectating() \u0026\u0026 Interface.CallHook(\u0022OnPlayerSpectateEnd\u0022, this, spectateFilter) == null)\r\n\t\t{\r\n\t\t\tSetParent(null);\r\n\t\t\tSetPlayerFlag(PlayerFlags.Spectating, b: false);\r\n\t\t\tUnityEngine.TransformEx.SetLayerRecursive(base.gameObject, 17);\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "IOnLootEntity(PlayerLoot playerLoot, BaseEntity targetEntity)",
    "MethodSignature": "StartLootingEntity(BaseEntity targetEntity, bool doPositionChecks)",
    "MethodSourseCode": "\r\n\tpublic void StartLootingEntity(BaseEntity targetEntity, bool doPositionChecks = true)\r\n\t{\r\n\t\tClear();\r\n\t\tif ((bool)targetEntity \u0026\u0026 targetEntity.OnStartBeingLooted(base.baseEntity))\r\n\t\t{\r\n\t\t\tAssert.IsTrue(targetEntity.isServer, \u0022Assure is server\u0022);\r\n\t\t\tPositionChecks = doPositionChecks;\r\n\t\t\tentitySource = targetEntity;\r\n\t\t\titemSource = null;\r\n\t\t\tMarkDirty();\r\n\t\t\tInterface.CallHook(\u0022IOnLootEntity\u0022, this, targetEntity);\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "PlayerLoot",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnAirdrop(CargoPlane cargoPlane, UnityEngine.Vector3 newDropPosition)",
    "MethodSignature": "UpdateDropPosition(Vector3 newDropPosition)",
    "MethodSourseCode": "\r\n\tpublic void UpdateDropPosition(Vector3 newDropPosition)\r\n\t{\r\n\t\tfloat x = TerrainMeta.Size.x;\r\n\t\tfloat y = TerrainMeta.HighestPoint.y \u002B 250f;\r\n\t\tstartPos = Vector3Ex.Range(-1f, 1f);\r\n\t\tstartPos.y = 0f;\r\n\t\tstartPos.Normalize();\r\n\t\tstartPos *= x * 2f;\r\n\t\tstartPos.y = y;\r\n\t\tendPos = startPos * -1f;\r\n\t\tendPos.y = startPos.y;\r\n\t\tstartPos \u002B= newDropPosition;\r\n\t\tendPos \u002B= newDropPosition;\r\n\t\tsecondsToTake = Vector3.Distance(startPos, endPos) / 50f;\r\n\t\tsecondsToTake *= UnityEngine.Random.Range(0.95f, 1.05f);\r\n\t\tbase.transform.position = startPos;\r\n\t\tbase.transform.rotation = Quaternion.LookRotation(endPos - startPos);\r\n\t\tdropPosition = newDropPosition;\r\n\t\tInterface.CallHook(\u0022OnAirdrop\u0022, this, newDropPosition);\r\n\t}\r\n",
    "ClassName": "CargoPlane",
    "HookLineInvoke": 19
  },
  {
    "HookSignature": "OnSurveyGather(SurveyCharge surveyCharge, Item item)",
    "MethodSignature": "Explode()",
    "MethodSourseCode": "\r\n\tpublic override void Explode()\r\n\t{\r\n\t\tbase.Explode();\r\n\t\tif (WaterLevel.Test(base.transform.position))\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tResourceDepositManager.ResourceDeposit orCreate = ResourceDepositManager.GetOrCreate(base.transform.position);\r\n\t\tif (orCreate == null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tVector2i indexFrom = ResourceDepositManager.GetIndexFrom(base.transform.position);\r\n\t\tif (Time.realtimeSinceStartup - orCreate.lastSurveyTime \u003C 10f)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\torCreate.lastSurveyTime = Time.realtimeSinceStartup;\r\n\t\tif (!TransformUtil.GetGroundInfo(base.transform.position, out var hitOut, 0.3f, 8388608))\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tVector3 point = hitOut.point;\r\n\t\tVector3 normal = hitOut.normal;\r\n\t\tList\u003CSurveyCrater\u003E obj = Pool.GetList\u003CSurveyCrater\u003E();\r\n\t\tVis.Entities(base.transform.position, 10f, obj, 1);\r\n\t\tbool flag = obj.Count \u003E 0;\r\n\t\tPool.FreeList(ref obj);\r\n\t\tif (flag)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tbool flag2 = false;\r\n\t\tbool flag3 = false;\r\n\t\tforeach (ResourceDepositManager.ResourceDeposit.ResourceDepositEntry resource in orCreate._resources)\r\n\t\t{\r\n\t\t\tif (resource.spawnType == ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM \u0026\u0026 !resource.isLiquid \u0026\u0026 resource.amount \u003E= 1000)\r\n\t\t\t{\r\n\t\t\t\tint num = Mathf.Clamp(Mathf.CeilToInt(2.5f / resource.workNeeded * 10f), 0, 5);\r\n\t\t\t\tint iAmount = 1;\r\n\t\t\t\tflag2 = true;\r\n\t\t\t\tif (resource.isLiquid)\r\n\t\t\t\t{\r\n\t\t\t\t\tflag3 = true;\r\n\t\t\t\t}\r\n\t\t\t\tfor (int i = 0; i \u003C num; i\u002B\u002B)\r\n\t\t\t\t{\r\n\t\t\t\t\tItem item = ItemManager.Create(resource.type, iAmount, 0uL);\r\n\t\t\t\t\tInterface.CallHook(\u0022OnSurveyGather\u0022, this, item);\r\n\t\t\t\t\tfloat aimCone = 20f;\r\n\t\t\t\t\tVector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(aimCone, Vector3.up);\r\n\t\t\t\t\tBaseEntity baseEntity = item.Drop(base.transform.position \u002B Vector3.up * 1f, modifiedAimConeDirection * UnityEngine.Random.Range(5f, 10f), UnityEngine.Random.rotation);\r\n\t\t\t\t\tbaseEntity.SetAngularVelocity(UnityEngine.Random.rotation.eulerAngles * 5f);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (flag2)\r\n\t\t{\r\n\t\t\tstring strPrefab = ((!flag3) ? craterPrefab.resourcePath : craterPrefab_Oil.resourcePath);\r\n\t\t\tBaseEntity baseEntity2 = GameManager.server.CreateEntity(strPrefab, point, Quaternion.identity);\r\n\t\t\tif ((bool)baseEntity2)\r\n\t\t\t{\r\n\t\t\t\tbaseEntity2.Spawn();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "SurveyCharge",
    "HookLineInvoke": 49
  },
  {
    "HookSignature": "OnRotateVendingMachine(VendingMachine vendingMachine, BasePlayer player)",
    "MethodSignature": "RPC_RotateVM(RPCMessage msg)",
    "MethodSourseCode": "\r\n\t[RPC_Server]\r\n\t[RPC_Server.IsVisible(3f)]\r\n\tpublic void RPC_RotateVM(RPCMessage msg)\r\n\t{\r\n\t\tBasePlayer player = msg.player;\r\n\t\tif (Interface.CallHook(\u0022OnRotateVendingMachine\u0022, this, player) == null \u0026\u0026 player.CanBuild() \u0026\u0026 IsInventoryEmpty())\r\n\t\t{\r\n\t\t\tbase.transform.rotation = Quaternion.LookRotation(-base.transform.forward, base.transform.up);\r\n\t\t\tSendNetworkUpdate();\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "IOnPlayerRevive(MedicalTool medicalTool, BasePlayer player)",
    "MethodSignature": "GiveEffectsTo(BasePlayer player)",
    "MethodSourseCode": "\r\n\tprivate void GiveEffectsTo(BasePlayer player)\r\n\t{\r\n\t\tif (!player)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tItemModConsumable component = GetOwnerItemDefinition().GetComponent\u003CItemModConsumable\u003E();\r\n\t\tif (!component)\r\n\t\t{\r\n\t\t\tDebug.LogWarning(\u0022No consumable for medicaltool :\u0022 \u002B base.name);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tif (Interface.CallHook(\u0022OnHealingItemUse\u0022, this, player) != null)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tif (player != GetOwnerPlayer() \u0026\u0026 player.IsWounded() \u0026\u0026 canRevive)\r\n\t\t\t{\r\n\t\t\t\tif (Interface.CallHook(\u0022IOnPlayerRevive\u0022, this, player) != null)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tplayer.StopWounded();\r\n\t\t\t}\r\n\t\t\tforeach (ItemModConsumable.ConsumableEffect effect in component.effects)\r\n\t\t\t{\r\n\t\t\t\tif (effect.type == MetabolismAttribute.Type.Health)\r\n\t\t\t\t{\r\n\t\t\t\t\tplayer.health \u002B= effect.amount;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tplayer.metabolism.ApplyChange(effect.type, effect.amount, effect.time);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "MedicalTool",
    "HookLineInvoke": 20
  },
  {
    "HookSignature": "OnEntityLeave(TriggerBase triggerBase, BaseEntity ent)",
    "MethodSignature": "OnEntityLeave(BaseEntity ent)",
    "MethodSourseCode": "\r\n\tinternal virtual void OnEntityLeave(BaseEntity ent)\r\n\t{\r\n\t\tif (entityContents != null)\r\n\t\t{\r\n\t\t\tInterface.CallHook(\u0022OnEntityLeave\u0022, this, ent);\r\n\t\t\tentityContents.Remove(ent);\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "TriggerBase",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnLootEntityEnd(BasePlayer player, LootableCorpse lootableCorpse)",
    "MethodSignature": "PlayerStoppedLooting(BasePlayer player)",
    "MethodSourseCode": "\r\n\tpublic void PlayerStoppedLooting(BasePlayer player)\r\n\t{\r\n\t\tInterface.CallHook(\u0022OnLootEntityEnd\u0022, player, this);\r\n\t\tResetRemovalTime();\r\n\t\tSetFlag(Flags.Open, b: false);\r\n\t\tSendNetworkUpdate();\r\n\t}\r\n",
    "ClassName": "LootableCorpse",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnRunPlayerMetabolism(PlayerMetabolism playerMetabolism, BaseCombatEntity ownerEntity, float delta)",
    "MethodSignature": "RunMetabolism(BaseCombatEntity ownerEntity, float delta)",
    "MethodSourseCode": "\r\n\tprotected override void RunMetabolism(BaseCombatEntity ownerEntity, float delta)\r\n\t{\r\n\t\tif (Interface.CallHook(\u0022OnRunPlayerMetabolism\u0022, this, ownerEntity, delta) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tfloat currentTemperature = owner.currentTemperature;\r\n\t\tfloat fTarget = owner.currentComfort;\r\n\t\tfloat num = currentTemperature;\r\n\t\tnum -= DeltaWet() * 34f;\r\n\t\tfloat num2 = Mathf.Clamp(owner.baseProtection.amounts[18] * 1.5f, -1f, 1f);\r\n\t\tfloat num3 = num2;\r\n\t\tfloat num4 = Mathf.InverseLerp(20f, -50f, currentTemperature);\r\n\t\tfloat num5 = Mathf.InverseLerp(20f, 30f, currentTemperature);\r\n\t\tnum \u002B= num4 * 70f * num3;\r\n\t\tnum \u002B= num5 * 10f * Mathf.Abs(num3);\r\n\t\tnum \u002B= heartrate.value * 5f;\r\n\t\ttemperature.MoveTowards(num, delta * 5f);\r\n\t\tif (temperature.value \u003E= 40f)\r\n\t\t{\r\n\t\t\tfTarget = 0f;\r\n\t\t}\r\n\t\tcomfort.MoveTowards(fTarget, delta / 5f);\r\n\t\tfloat num6 = 0.6f \u002B 0.4f * comfort.value;\r\n\t\tif (calories.value \u003E 100f \u0026\u0026 owner.healthFraction \u003C num6 \u0026\u0026 radiation_poison.Fraction() \u003C 0.25f \u0026\u0026 owner.SecondsSinceAttacked \u003E 10f \u0026\u0026 !SignificantBleeding() \u0026\u0026 temperature.value \u003E= 10f \u0026\u0026 hydration.value \u003E 40f)\r\n\t\t{\r\n\t\t\tfloat num7 = Mathf.InverseLerp(calories.min, calories.max, calories.value);\r\n\t\t\tfloat num8 = 5f;\r\n\t\t\tfloat num9 = num8 * owner.MaxHealth() * 0.8f / 600f;\r\n\t\t\tnum9 \u002B= num9 * num7 * 0.5f;\r\n\t\t\tfloat num10 = num9 / num8;\r\n\t\t\tnum10 \u002B= num10 * comfort.value * 6f;\r\n\t\t\townerEntity.Heal(num10 * delta);\r\n\t\t\tcalories.Subtract(num9 * delta);\r\n\t\t\thydration.Subtract(num9 * delta * 0.2f);\r\n\t\t}\r\n\t\tfloat num11 = owner.estimatedSpeed2D / owner.GetMaxSpeed() * 0.75f;\r\n\t\tfloat fTarget2 = Mathf.Clamp(0.05f \u002B num11, 0f, 1f);\r\n\t\theartrate.MoveTowards(fTarget2, delta * 0.1f);\r\n\t\tfloat num12 = heartrate.Fraction() * 0.375f;\r\n\t\tcalories.MoveTowards(0f, delta * num12);\r\n\t\tfloat num13 = 1f / 120f;\r\n\t\tnum13 \u002B= Mathf.InverseLerp(40f, 60f, temperature.value) * (1f / 12f);\r\n\t\tnum13 \u002B= heartrate.value * (1f / 15f);\r\n\t\thydration.MoveTowards(0f, delta * num13);\r\n\t\tbool b = hydration.Fraction() \u003C= 0f || radiation_poison.value \u003E= 100f;\r\n\t\towner.SetPlayerFlag(BasePlayer.PlayerFlags.NoSprint, b);\r\n\t\tif (temperature.value \u003E 40f)\r\n\t\t{\r\n\t\t\thydration.Add(Mathf.InverseLerp(40f, 200f, temperature.value) * delta * -1f);\r\n\t\t}\r\n\t\tif (temperature.value \u003C 10f)\r\n\t\t{\r\n\t\t\tfloat num14 = Mathf.InverseLerp(20f, -100f, temperature.value);\r\n\t\t\theartrate.MoveTowards(Mathf.Lerp(0.2f, 1f, num14), delta * 2f * num14);\r\n\t\t}\r\n\t\tfloat num15 = owner.WaterFactor();\r\n\t\tif (num15 \u003E 0.85f)\r\n\t\t{\r\n\t\t\toxygen.MoveTowards(0f, delta * 0.1f);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\toxygen.MoveTowards(1f, delta * 1f);\r\n\t\t}\r\n\t\tfloat f = 0f;\r\n\t\tfloat f2 = 0f;\r\n\t\tif (owner.IsOutside(owner.eyes.position))\r\n\t\t{\r\n\t\t\tf = Climate.GetRain(owner.eyes.position) * 0.6f;\r\n\t\t\tf2 = Climate.GetSnow(owner.eyes.position) * 0.2f;\r\n\t\t}\r\n\t\twetness.value = Mathf.Max(wetness.value, num15);\r\n\t\twetness.MoveTowards(Mathx.Max(wetness.value, f, f2), delta * 0.05f);\r\n\t\tif (num15 \u003C wetness.value)\r\n\t\t{\r\n\t\t\twetness.MoveTowards(0f, delta * 0.2f * Mathf.InverseLerp(0f, 100f, currentTemperature));\r\n\t\t}\r\n\t\tpoison.MoveTowards(0f, delta * (5f / 9f));\r\n\t\tif (wetness.Fraction() \u003E 0.4f \u0026\u0026 owner.estimatedSpeed \u003E 0.25f \u0026\u0026 radiation_level.Fraction() == 0f)\r\n\t\t{\r\n\t\t\tradiation_poison.Subtract(radiation_poison.value * 0.2f * wetness.Fraction() * delta * 0.2f);\r\n\t\t}\r\n\t\tif (ConVar.Server.radiation)\r\n\t\t{\r\n\t\t\tradiation_level.value = owner.radiationLevel;\r\n\t\t\tif (radiation_level.value \u003E 0f)\r\n\t\t\t{\r\n\t\t\t\tradiation_poison.Add(radiation_level.value * delta);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (pending_health.value \u003E 0f)\r\n\t\t{\r\n\t\t\tfloat num16 = Mathf.Min(2f * delta, pending_health.value);\r\n\t\t\townerEntity.Heal(num16);\r\n\t\t\tif (ownerEntity.healthFraction == 1f)\r\n\t\t\t{\r\n\t\t\t\tpending_health.value = 0f;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tpending_health.Subtract(num16);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "PlayerMetabolism",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanBeTargeted(BaseCombatEntity obj, AutoTurret autoTurret)",
    "MethodSignature": "ObjectVisible(BaseCombatEntity obj)",
    "MethodSourseCode": "\r\n\tpublic bool ObjectVisible(BaseCombatEntity obj)\r\n\t{\r\n\t\tobject obj2 = Interface.CallHook(\u0022CanBeTargeted\u0022, obj, this);\r\n\t\tif (obj2 is bool)\r\n\t\t{\r\n\t\t\treturn (bool)obj2;\r\n\t\t}\r\n\t\tList\u003CRaycastHit\u003E obj3 = Facepunch.Pool.GetList\u003CRaycastHit\u003E();\r\n\t\tVector3 position = eyePos.transform.position;\r\n\t\tVector3 vector = AimOffset(obj);\r\n\t\tfloat num = Vector3.Distance(vector, position);\r\n\t\tVector3 normalized = (vector - position).normalized;\r\n\t\tVector3 vector2 = Vector3.Cross(normalized, Vector3.up);\r\n\t\tfor (int i = 0; i \u003C 3; i\u002B\u002B)\r\n\t\t{\r\n\t\t\tVector3 vector3 = vector \u002B vector2 * visibilityOffsets[i];\r\n\t\t\tVector3 normalized2 = (vector3 - position).normalized;\r\n\t\t\tobj3.Clear();\r\n\t\t\tGamePhysics.TraceAll(new Ray(position, normalized2), 0f, obj3, num * 1.1f, 1084434689);\r\n\t\t\tfor (int j = 0; j \u003C obj3.Count; j\u002B\u002B)\r\n\t\t\t{\r\n\t\t\t\tRaycastHit hit = obj3[j];\r\n\t\t\t\tBaseEntity entity = RaycastHitEx.GetEntity(hit);\r\n\t\t\t\tif (entity != null \u0026\u0026 (entity == obj || entity.EqualNetID(obj)))\r\n\t\t\t\t{\r\n\t\t\t\t\tFacepunch.Pool.FreeList(ref obj3);\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t\tif (!(entity != null) || entity.ShouldBlockProjectiles())\r\n\t\t\t\t{\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tFacepunch.Pool.FreeList(ref obj3);\r\n\t\treturn false;\r\n\t}\r\n",
    "ClassName": "AutoTurret",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnEntityEnter(TriggerBase triggerBase, BaseEntity ent)",
    "MethodSignature": "OnEntityEnter(BaseEntity ent)",
    "MethodSourseCode": "\r\n\tinternal virtual void OnEntityEnter(BaseEntity ent)\r\n\t{\r\n\t\tif (!(ent == null))\r\n\t\t{\r\n\t\t\tif (entityContents == null)\r\n\t\t\t{\r\n\t\t\t\tentityContents = new HashSet\u003CBaseEntity\u003E();\r\n\t\t\t}\r\n\t\t\tInterface.CallHook(\u0022OnEntityEnter\u0022, this, ent);\r\n\t\t\tentityContents.Add(ent);\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "TriggerBase",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnVendingTransaction(VendingMachine vendingMachine, BasePlayer buyer, int sellOrderId, int numberOfTransactions)",
    "MethodSignature": "DoTransaction(BasePlayer buyer, int sellOrderId, int numberOfTransactions)",
    "MethodSourseCode": "\r\n\tpublic bool DoTransaction(BasePlayer buyer, int sellOrderId, int numberOfTransactions = 1)\r\n\t{\r\n\t\tif (sellOrderId \u003C 0 || sellOrderId \u003E sellOrders.sellOrders.Count)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (Vector3.Distance(buyer.GetEstimatedWorldPosition(), base.transform.position) \u003E 4f)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tobject obj = Interface.CallHook(\u0022OnVendingTransaction\u0022, this, buyer, sellOrderId, numberOfTransactions);\r\n\t\tif (obj is bool)\r\n\t\t{\r\n\t\t\treturn (bool)obj;\r\n\t\t}\r\n\t\tProtoBuf.VendingMachine.SellOrder sellOrder = sellOrders.sellOrders[sellOrderId];\r\n\t\tList\u003CItem\u003E list = inventory.FindItemsByItemID(sellOrder.itemToSellID);\r\n\t\tif (list == null || list.Count == 0)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tnumberOfTransactions = Mathf.Clamp(numberOfTransactions, 1, list[0].hasCondition ? 1 : 1000000);\r\n\t\tint num = sellOrder.itemToSellAmount * numberOfTransactions;\r\n\t\tint num2 = list.Sum((Item x) =\u003E x.amount);\r\n\t\tif (num \u003E num2)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tList\u003CItem\u003E list2 = buyer.inventory.FindItemIDs(sellOrder.currencyID);\r\n\t\tif (list2.Count == 0)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tint num3 = list2.Sum((Item x) =\u003E x.amount);\r\n\t\tint num4 = sellOrder.currencyAmountPerItem * numberOfTransactions;\r\n\t\tif (num3 \u003C num4)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\ttransactionActive = true;\r\n\t\tint num5 = 0;\r\n\t\tforeach (Item item3 in list2)\r\n\t\t{\r\n\t\t\tint num6 = Mathf.Min(num4 - num5, item3.amount);\r\n\t\t\tItem item = ((item3.amount \u003E num6) ? item3.SplitItem(num6) : item3);\r\n\t\t\tif (!item.MoveToContainer(inventory))\r\n\t\t\t{\r\n\t\t\t\titem.Drop(inventory.dropPosition, Vector3.zero);\r\n\t\t\t}\r\n\t\t\tnum5 \u002B= num6;\r\n\t\t\tif (num5 \u003E= num4)\r\n\t\t\t{\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tint num7 = 0;\r\n\t\tforeach (Item item4 in list)\r\n\t\t{\r\n\t\t\tItem item2 = ((item4.amount \u003E num) ? item4.SplitItem(num) : item4);\r\n\t\t\tnum7 \u002B= item2.amount;\r\n\t\t\tbuyer.GiveItem(item2, GiveItemReason.PickedUp);\r\n\t\t\tif (num7 \u003E= num)\r\n\t\t\t{\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tUpdateEmptyFlag();\r\n\t\ttransactionActive = false;\r\n\t\treturn true;\r\n\t}\r\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnCollectiblePickup(Item item, BasePlayer msgPlayer, CollectibleEntity collectibleEntity)",
    "MethodSignature": "Pickup(RPCMessage msg)",
    "MethodSourseCode": "\r\n\t[RPC_Server]\r\n\t[RPC_Server.MaxDistance(3f)]\r\n\tpublic void Pickup(RPCMessage msg)\r\n\t{\r\n\t\tif (msg.player.CanInteract() \u0026\u0026 itemList != null)\r\n\t\t{\r\n\t\t\tItemAmount[] array = itemList;\r\n\t\t\tforeach (ItemAmount itemAmount in array)\r\n\t\t\t{\r\n\t\t\t\tItem item = ItemManager.Create(itemAmount.itemDef, (int)itemAmount.amount, 0uL);\r\n\t\t\t\tInterface.CallHook(\u0022OnCollectiblePickup\u0022, item, msg.player, this);\r\n\t\t\t\tmsg.player.GiveItem(item, GiveItemReason.PickedUp);\r\n\t\t\t}\r\n\t\t\titemList = null;\r\n\t\t\tif (pickupEffect.isValid)\r\n\t\t\t{\r\n\t\t\t\tEffect.server.Run(pickupEffect.resourcePath, base.transform.position, base.transform.up);\r\n\t\t\t}\r\n\t\t\tKill();\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "CollectibleEntity",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnPlayerRespawned(BasePlayer basePlayer)",
    "MethodSignature": "RespawnAt(UnityEngine.Vector3 position, Quaternion rotation)",
    "MethodSourseCode": "\r\n\tpublic void RespawnAt(UnityEngine.Vector3 position, Quaternion rotation)\r\n\t{\r\n\t\tSetPlayerFlag(PlayerFlags.Wounded, b: false);\r\n\t\tSetPlayerFlag(PlayerFlags.HasBuildingPrivilege, b: false);\r\n\t\tSetPlayerFlag(PlayerFlags.InBuildingPrivilege, b: false);\r\n\t\tSetPlayerFlag(PlayerFlags.ReceivingSnapshot, b: true);\r\n\t\tSetPlayerFlag(PlayerFlags.DisplaySash, b: false);\r\n\t\tServerPerformance.spawns\u002B\u002B;\r\n\t\tbase.transform.position = position;\r\n\t\tbase.transform.rotation = rotation;\r\n\t\ttickInterpolator.Reset(position);\r\n\t\tlastTickTime = 0f;\r\n\t\tStopWounded();\r\n\t\tStopSpectating();\r\n\t\tUpdateNetworkGroup();\r\n\t\tUpdatePlayerCollider(state: true);\r\n\t\tUpdatePlayerRigidbody(state: false);\r\n\t\tStartSleeping();\r\n\t\tLifeStoryStart();\r\n\t\tmetabolism.Reset();\r\n\t\tInitializeHealth(StartHealth(), StartMaxHealth());\r\n\t\tinventory.GiveDefaultItems();\r\n\t\tSendNetworkUpdateImmediate();\r\n\t\tClearEntityQueue();\r\n\t\tClientRPCPlayer(null, this, \u0022StartLoading\u0022);\r\n\t\tNetworkable networkable = net;\r\n\t\tInterface.CallHook(\u0022OnPlayerRespawned\u0022, this);\r\n\t\tif (networkable != null)\r\n\t\t{\r\n\t\t\tEACServer.OnStartLoading(net.connection);\r\n\t\t}\r\n\t\tSendFullSnapshot();\r\n\t}\r\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 27
  },
  {
    "HookSignature": "CanLock(KeyLock keyLock, BasePlayer rpcPlayer)",
    "MethodSignature": "RPC_Lock(RPCMessage rpc)",
    "MethodSourseCode": "\r\n\t[RPC_Server.MaxDistance(3f)]\r\n\t[RPC_Server]\r\n\tprivate void RPC_Lock(RPCMessage rpc)\r\n\t{\r\n\t\tif (rpc.player.CanInteract() \u0026\u0026 !IsLocked() \u0026\u0026 Interface.CallHook(\u0022CanLock\u0022, this, rpc.player) == null \u0026\u0026 HasLockPermission(rpc.player))\r\n\t\t{\r\n\t\t\tSetFlag(Flags.Locked, b: true);\r\n\t\t\tSendNetworkUpdate();\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "KeyLock",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "CanBeWounded(BasePlayer basePlayer, HitInfo info)",
    "MethodSignature": "EligibleForWounding(HitInfo info)",
    "MethodSourseCode": "\r\n\tpublic virtual bool EligibleForWounding(HitInfo info)\r\n\t{\r\n\t\tobject obj = Interface.CallHook(\u0022CanBeWounded\u0022, this, info);\r\n\t\tif (obj is bool)\r\n\t\t{\r\n\t\t\treturn (bool)obj;\r\n\t\t}\r\n\t\tif (!ConVar.Server.woundingenabled)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (IsSleeping())\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (info == null)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (UnityEngine.Time.realtimeSinceStartup - lastWoundedTime \u003C 60f)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (info.WeaponPrefab is BaseMelee)\r\n\t\t{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tif (info.WeaponPrefab is BaseProjectile)\r\n\t\t{\r\n\t\t\treturn !info.isHeadshot;\r\n\t\t}\r\n\t\treturn info.damageTypes.GetMajorityDamageType() switch\r\n\t\t{\r\n\t\t\tDamageType.Suicide =\u003E false, \r\n\t\t\tDamageType.Fall =\u003E true, \r\n\t\t\tDamageType.Bite =\u003E true, \r\n\t\t\tDamageType.Bleeding =\u003E true, \r\n\t\t\tDamageType.Hunger =\u003E true, \r\n\t\t\tDamageType.Thirst =\u003E true, \r\n\t\t\tDamageType.Poison =\u003E true, \r\n\t\t\t_ =\u003E false, \r\n\t\t};\r\n\t}\r\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnCupboardAuthorize(BuildingPrivlidge buildingPrivlidge, BasePlayer rpcPlayer)",
    "MethodSignature": "AddSelfAuthorize(RPCMessage rpc)",
    "MethodSourseCode": "\r\n\t[RPC_Server.IsVisible(3f)]\r\n\t[RPC_Server]\r\n\tprivate void AddSelfAuthorize(RPCMessage rpc)\r\n\t{\r\n\t\tRPCMessage rpc2 = rpc;\r\n\t\tif (rpc2.player.CanInteract() \u0026\u0026 CanAdministrate(rpc2.player) \u0026\u0026 Interface.CallHook(\u0022OnCupboardAuthorize\u0022, this, rpc.player) == null)\r\n\t\t{\r\n\t\t\tauthorizedPlayers.RemoveAll((PlayerNameID x) =\u003E x.userid == rpc2.player.userID);\r\n\t\t\tPlayerNameID playerNameID = new PlayerNameID();\r\n\t\t\tplayerNameID.userid = rpc2.player.userID;\r\n\t\t\tplayerNameID.username = rpc2.player.displayName;\r\n\t\t\tauthorizedPlayers.Add(playerNameID);\r\n\t\t\tUpdateAllPlayers();\r\n\t\t\tSendNetworkUpdate();\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "BuildingPrivlidge",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnPlayerBanned(Network.Connection connection, string connectionAuthStatus)",
    "MethodSignature": "HandleClientUpdate(ClientStatusUpdate\u003CEasyAntiCheat.Server.Hydra.Client\u003E clientStatus)",
    "MethodSourseCode": "\r\n\tprivate static void HandleClientUpdate(ClientStatusUpdate\u003CEasyAntiCheat.Server.Hydra.Client\u003E clientStatus)\r\n\t{\r\n\t\tif (!ConVar.Server.secure)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tusing (TimeWarning.New(\u0022AntiCheatKickPlayer\u0022, 10L))\r\n\t\t{\r\n\t\t\tEasyAntiCheat.Server.Hydra.Client clientObject = clientStatus.ClientObject;\r\n\t\t\tConnection connection = GetConnection(clientObject);\r\n\t\t\tif (connection == null)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tif (clientStatus.RequiresKick)\r\n\t\t\t{\r\n\t\t\t\tstring text = clientStatus.Message;\r\n\t\t\t\tif (string.IsNullOrEmpty(text))\r\n\t\t\t\t{\r\n\t\t\t\t\ttext = clientStatus.Status.ToString();\r\n\t\t\t\t}\r\n\t\t\t\tDebug.Log(\u0022[EAC] Kicking \u0022 \u002B connection.userid \u002B \u0022 (\u0022 \u002B text \u002B \u0022)\u0022);\r\n\t\t\t\tconnection.authStatus = \u0022eac\u0022;\r\n\t\t\t\tNetwork.Net.sv.Kick(connection, \u0022EAC: \u0022 \u002B text);\r\n\t\t\t\tif (clientStatus.Status == ClientStatus.ClientBanned)\r\n\t\t\t\t{\r\n\t\t\t\t\tconnection.authStatus = \u0022eacbanned\u0022;\r\n\t\t\t\t\tInterface.CallHook(\u0022OnPlayerBanned\u0022, connection, connection.authStatus);\r\n\t\t\t\t\tServerUsers.Set(connection.userid, ServerUsers.UserGroup.Banned, connection.username, \u0022EAC\u0022);\r\n\t\t\t\t\tConsoleNetwork.BroadcastToAllClients(\u0022chat.add\u0022, 0, \u0022\u003Ccolor=#fff\u003ESERVER\u003C/color\u003E Kicking \u0022 \u002B connection.username \u002B \u0022 (banned by anticheat)\u0022);\r\n\t\t\t\t\tEntity.DeleteBy(connection.userid);\r\n\t\t\t\t}\r\n\t\t\t\teasyAntiCheat.UnregisterClient(clientObject);\r\n\t\t\t\tclient2connection.Remove(clientObject);\r\n\t\t\t\tuserid2client.Remove(connection.userid);\r\n\t\t\t\tuserid2status.Remove(connection.userid);\r\n\t\t\t}\r\n\t\t\telse if (clientStatus.Status == ClientStatus.ClientAuthenticatedLocal)\r\n\t\t\t{\r\n\t\t\t\tOnAuthenticatedLocal(connection);\r\n\t\t\t\teasyAntiCheat.SetClientNetworkState(clientObject, networkActive: false);\r\n\t\t\t}\r\n\t\t\telse if (clientStatus.Status == ClientStatus.ClientAuthenticatedRemote)\r\n\t\t\t{\r\n\t\t\t\tOnAuthenticatedRemote(connection);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "EACServer",
    "HookLineInvoke": 28
  },
  {
    "HookSignature": "CanHelicopterUseNapalm(PatrolHelicopterAI patrolHelicopterAI)",
    "MethodSignature": "CanUseNapalm()",
    "MethodSourseCode": "\r\n\tpublic bool CanUseNapalm()\r\n\t{\r\n\t\tobject obj = Interface.CallHook(\u0022CanHelicopterUseNapalm\u0022, this);\r\n\t\tif (obj is bool)\r\n\t\t{\r\n\t\t\treturn (bool)obj;\r\n\t\t}\r\n\t\treturn UnityEngine.Time.realtimeSinceStartup - lastNapalmTime \u003E= 30f;\r\n\t}\r\n",
    "ClassName": "PatrolHelicopterAI",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanBeTargeted(BasePlayer item, GunTrap gunTrap)",
    "MethodSignature": "CheckTrigger(float offset, float radius)",
    "MethodSourseCode": "\r\n\tpublic bool CheckTrigger(float offset, float radius)\r\n\t{\r\n\t\tList\u003CRaycastHit\u003E obj = Pool.GetList\u003CRaycastHit\u003E();\r\n\t\tList\u003CBasePlayer\u003E obj2 = Pool.GetList\u003CBasePlayer\u003E();\r\n\t\tVis.Entities(GetEyePosition() \u002B base.transform.forward * offset, radius, obj2, 131072);\r\n\t\tbool flag = false;\r\n\t\tforeach (BasePlayer item in obj2)\r\n\t\t{\r\n\t\t\tif (item.IsSleeping() || !item.IsAlive() || (item.HasPlayerFlag(BasePlayer.PlayerFlags.InBuildingPrivilege) \u0026\u0026 item.CanBuild()))\r\n\t\t\t{\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tobject obj3 = Interface.CallHook(\u0022CanBeTargeted\u0022, item, this);\r\n\t\t\tif (obj3 is bool)\r\n\t\t\t{\r\n\t\t\t\treturn (bool)obj3;\r\n\t\t\t}\r\n\t\t\tobj.Clear();\r\n\t\t\tGamePhysics.TraceAll(new Ray(item.eyes.position, (GetEyePosition() - item.eyes.position).normalized), 0f, obj, 9f, 1075904769);\r\n\t\t\tfor (int i = 0; i \u003C obj.Count; i\u002B\u002B)\r\n\t\t\t{\r\n\t\t\t\tRaycastHit hit = obj[i];\r\n\t\t\t\tBaseEntity entity = RaycastHitEx.GetEntity(hit);\r\n\t\t\t\tif (entity != null \u0026\u0026 (entity == this || entity.EqualNetID(this)))\r\n\t\t\t\t{\r\n\t\t\t\t\tflag = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tif (!(entity != null) || entity.ShouldBlockProjectiles())\r\n\t\t\t\t{\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (flag)\r\n\t\t\t{\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tPool.FreeList(ref obj);\r\n\t\tPool.FreeList(ref obj2);\r\n\t\treturn flag;\r\n\t}\r\n",
    "ClassName": "GunTrap",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "OnReloadWeapon(BasePlayer player, BaseProjectile baseProjectile)",
    "MethodSignature": "StartReload(RPCMessage msg)",
    "MethodSourseCode": "\r\n\t[RPC_Server]\r\n\t[RPC_Server.IsActiveItem]\r\n\tprivate void StartReload(RPCMessage msg)\r\n\t{\r\n\t\tBasePlayer player = msg.player;\r\n\t\tif (!VerifyClientRPC(player))\r\n\t\t{\r\n\t\t\tSendNetworkUpdate();\r\n\t\t\treloadStarted = false;\r\n\t\t\treloadFinished = false;\r\n\t\t}\r\n\t\telse if (Interface.CallHook(\u0022OnReloadWeapon\u0022, player, this) == null)\r\n\t\t{\r\n\t\t\treloadFinished = false;\r\n\t\t\treloadStarted = true;\r\n\t\t\tStartReloadCooldown(reloadTime);\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "BaseProjectile",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "OnToggleVendingBroadcast(VendingMachine vendingMachine, BasePlayer player)",
    "MethodSignature": "RPC_Broadcast(RPCMessage msg)",
    "MethodSourseCode": "\r\n\t[RPC_Server]\r\n\t[RPC_Server.IsVisible(3f)]\r\n\tpublic void RPC_Broadcast(RPCMessage msg)\r\n\t{\r\n\t\tBasePlayer player = msg.player;\r\n\t\tbool b = msg.read.Bit();\r\n\t\tif (CanPlayerAdmin(player))\r\n\t\t{\r\n\t\t\tSetFlag(Flags.Reserved4, b);\r\n\t\t\tInterface.CallHook(\u0022OnToggleVendingBroadcast\u0022, this, player);\r\n\t\t\tUpdateMapMarker();\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "CanVendingAcceptItem(VendingMachine vendingMachine, Item item)",
    "MethodSignature": "CanAcceptItem(Item item)",
    "MethodSourseCode": "\r\n\tpublic bool CanAcceptItem(Item item)\r\n\t{\r\n\t\tobject obj = Interface.CallHook(\u0022CanVendingAcceptItem\u0022, this, item);\r\n\t\tif (obj is bool)\r\n\t\t{\r\n\t\t\treturn (bool)obj;\r\n\t\t}\r\n\t\tBasePlayer ownerPlayer = item.GetOwnerPlayer();\r\n\t\tif (transactionActive)\r\n\t\t{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tif (item.parent == null)\r\n\t\t{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tif (inventory.itemList.Contains(item))\r\n\t\t{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tif (ownerPlayer == null)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\treturn CanPlayerAdmin(ownerPlayer);\r\n\t}\r\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnItemCraftCancelled(ItemCraftTask itemCraftTask)",
    "MethodSignature": "CancelTask(int iID, bool ReturnItems)",
    "MethodSourseCode": "\r\n\tpublic bool CancelTask(int iID, bool ReturnItems)\r\n\t{\r\n\t\tif (queue.Count == 0)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tItemCraftTask itemCraftTask = queue.FirstOrDefault((ItemCraftTask x) =\u003E x.taskUID == iID \u0026\u0026 !x.cancelled);\r\n\t\tif (itemCraftTask == null)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\titemCraftTask.cancelled = true;\r\n\t\tif (itemCraftTask.owner == null)\r\n\t\t{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tInterface.CallHook(\u0022OnItemCraftCancelled\u0022, itemCraftTask);\r\n\t\titemCraftTask.owner.Command(\u0022note.craft_done\u0022, itemCraftTask.taskUID, 0);\r\n\t\tif (itemCraftTask.takenItems != null \u0026\u0026 itemCraftTask.takenItems.Count \u003E 0 \u0026\u0026 ReturnItems)\r\n\t\t{\r\n\t\t\tforeach (Item takenItem in itemCraftTask.takenItems)\r\n\t\t\t{\r\n\t\t\t\tif (takenItem != null \u0026\u0026 takenItem.amount \u003E 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (takenItem.IsBlueprint() \u0026\u0026 takenItem.blueprintTargetDef == itemCraftTask.blueprint.targetItem)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\ttakenItem.UseItem(itemCraftTask.numCrafted);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (takenItem.amount \u003E 0 \u0026\u0026 !takenItem.MoveToContainer(itemCraftTask.owner.inventory.containerMain))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\ttakenItem.Drop(itemCraftTask.owner.inventory.containerMain.dropPosition, itemCraftTask.owner.inventory.containerMain.dropVelocity);\r\n\t\t\t\t\t\titemCraftTask.owner.Command(\u0022note.inv\u0022, takenItem.info.itemid, -takenItem.amount);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n",
    "ClassName": "ItemCrafter",
    "HookLineInvoke": 17
  },
  {
    "HookSignature": "OnTurretToggle(AutoTurret autoTurret)",
    "MethodSignature": "SetIsOnline(bool online)",
    "MethodSourseCode": "\r\n\tpublic void SetIsOnline(bool online)\r\n\t{\r\n\t\tif (online != HasFlag(Flags.On) \u0026\u0026 Interface.CallHook(\u0022OnTurretToggle\u0022, this) == null)\r\n\t\t{\r\n\t\t\tSetFlag(Flags.On, online);\r\n\t\t\tbooting = false;\r\n\t\t\tSendNetworkUpdate();\r\n\t\t\tif (IsOffline())\r\n\t\t\t{\r\n\t\t\t\tSetTarget(null);\r\n\t\t\t\tisLootable = true;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tisLootable = false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "AutoTurret",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnTerrainInitialized()",
    "MethodSignature": "PostSetupComponents()",
    "MethodSourseCode": "\r\n\tpublic void PostSetupComponents()\r\n\t{\r\n\t\tTerrainExtension[] components = GetComponents\u003CTerrainExtension\u003E();\r\n\t\tforeach (TerrainExtension terrainExtension in components)\r\n\t\t{\r\n\t\t\tterrainExtension.PostSetup();\r\n\t\t}\r\n\t\tInterface.CallHook(\u0022OnTerrainInitialized\u0022, null);\r\n\t}\r\n",
    "ClassName": "TerrainMeta",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "CanBeTargeted(BaseCombatEntity potentialtarget, HelicopterTurret helicopterTurret)",
    "MethodSignature": "InFiringArc(BaseCombatEntity potentialtarget)",
    "MethodSourseCode": "\r\n\tpublic bool InFiringArc(BaseCombatEntity potentialtarget)\r\n\t{\r\n\t\tobject obj = Interface.CallHook(\u0022CanBeTargeted\u0022, potentialtarget, this);\r\n\t\tif (obj is bool)\r\n\t\t{\r\n\t\t\treturn (bool)obj;\r\n\t\t}\r\n\t\treturn AngleToTarget(potentialtarget) \u003C 80f;\r\n\t}\r\n",
    "ClassName": "HelicopterTurret",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "IOnStructureDemolish(BuildingBlock buildingBlock, BasePlayer msgPlayer)",
    "MethodSignature": "DoDemolish(RPCMessage msg)",
    "MethodSourseCode": "\r\n\t[RPC_Server]\r\n\t[RPC_Server.MaxDistance(3f)]\r\n\tprivate void DoDemolish(RPCMessage msg)\r\n\t{\r\n\t\tif (msg.player.CanInteract() \u0026\u0026 CanDemolish(msg.player) \u0026\u0026 Interface.CallHook(\u0022IOnStructureDemolish\u0022, this, msg.player) == null)\r\n\t\t{\r\n\t\t\tKill(DestroyMode.Gib);\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "BuildingBlock",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "IOnPlayerAttack(BaseMelee baseMelee, HitInfo info)",
    "MethodSignature": "DoAttackShared(HitInfo info)",
    "MethodSourseCode": "\r\n\tpublic virtual void DoAttackShared(HitInfo info)\r\n\t{\r\n\t\tif (Interface.CallHook(\u0022IOnPlayerAttack\u0022, this, info) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tGetAttackStats(info);\r\n\t\tif (info.HitEntity != null)\r\n\t\t{\r\n\t\t\tusing (TimeWarning.New(\u0022OnAttacked\u0022, 50L))\r\n\t\t\t{\r\n\t\t\t\tinfo.HitEntity.OnAttacked(info);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (base.isServer)\r\n\t\t{\r\n\t\t\tusing (TimeWarning.New(\u0022ImpactEffect\u0022, 20L))\r\n\t\t\t{\r\n\t\t\t\tEffect.server.ImpactEffect(info);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tusing (TimeWarning.New(\u0022ImpactEffect\u0022, 20L))\r\n\t\t\t{\r\n\t\t\t\tEffect.client.ImpactEffect(info);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (base.isServer \u0026\u0026 !base.IsDestroyed)\r\n\t\t{\r\n\t\t\tusing (TimeWarning.New(\u0022UpdateItemCondition\u0022, 50L))\r\n\t\t\t{\r\n\t\t\t\tUpdateItemCondition(info);\r\n\t\t\t}\r\n\t\t\tStartAttackCooldown(repeatDelay * 0.5f);\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "BaseMelee",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnCodeEntered(CodeLock codeLock, BasePlayer rpcPlayer, string text)",
    "MethodSignature": "UnlockWithCode(RPCMessage rpc)",
    "MethodSourseCode": "\r\n\t[RPC_Server]\r\n\t[RPC_Server.MaxDistance(3f)]\r\n\tprivate void UnlockWithCode(RPCMessage rpc)\r\n\t{\r\n\t\tif (!rpc.player.CanInteract() || !IsLocked())\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tstring text = rpc.read.String();\r\n\t\tif (Interface.CallHook(\u0022OnCodeEntered\u0022, this, rpc.player, text) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tbool flag = text == guestCode;\r\n\t\tbool flag2 = text == code;\r\n\t\tif (!(text == code) \u0026\u0026 (!hasGuestCode || !(text == guestCode)))\r\n\t\t{\r\n\t\t\tif (UnityEngine.Time.realtimeSinceStartup \u003E lastWrongTime \u002B 10f)\r\n\t\t\t{\r\n\t\t\t\twrongCodes = 0;\r\n\t\t\t}\r\n\t\t\tDoEffect(effectDenied.resourcePath);\r\n\t\t\tDoEffect(effectShock.resourcePath);\r\n\t\t\trpc.player.Hurt((float)(wrongCodes \u002B 1) * 5f, DamageType.ElectricShock, this, useProtection: false);\r\n\t\t\twrongCodes\u002B\u002B;\r\n\t\t\tlastWrongTime = UnityEngine.Time.realtimeSinceStartup;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tSendNetworkUpdate();\r\n\t\tif (flag2)\r\n\t\t{\r\n\t\t\tif (!whitelistPlayers.Contains(rpc.player.userID))\r\n\t\t\t{\r\n\t\t\t\tDoEffect(effectCodeChanged.resourcePath);\r\n\t\t\t\twhitelistPlayers.Add(rpc.player.userID);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (flag \u0026\u0026 !guestPlayers.Contains(rpc.player.userID))\r\n\t\t{\r\n\t\t\tDoEffect(effectCodeChanged.resourcePath);\r\n\t\t\tguestPlayers.Add(rpc.player.userID);\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "CodeLock",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnHammerHit(BasePlayer ownerPlayer, HitInfo info)",
    "MethodSignature": "DoAttackShared(HitInfo info)",
    "MethodSourseCode": "\r\n\tpublic override void DoAttackShared(HitInfo info)\r\n\t{\r\n\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\r\n\t\tBaseCombatEntity baseCombatEntity = info.HitEntity as BaseCombatEntity;\r\n\t\tif (baseCombatEntity != null)\r\n\t\t{\r\n\t\t\tif (Interface.CallHook(\u0022OnHammerHit\u0022, ownerPlayer, info) != null)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tif (ownerPlayer != null \u0026\u0026 base.isServer)\r\n\t\t\t{\r\n\t\t\t\tusing (TimeWarning.New(\u0022DoRepair\u0022, 50L))\r\n\t\t\t\t{\r\n\t\t\t\t\tbaseCombatEntity.DoRepair(ownerPlayer);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (base.isServer)\r\n\t\t{\r\n\t\t\tEffect.server.ImpactEffect(info);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tEffect.client.ImpactEffect(info);\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "Hammer",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnMapImageUpdated()",
    "MethodSignature": "ImageUpdate(RPCMessage msg)",
    "MethodSourseCode": "\r\n\t[RPC_Server]\r\n\t[RPC_Server.FromOwner]\r\n\tpublic void ImageUpdate(RPCMessage msg)\r\n\t{\r\n\t\tbyte b = msg.read.UInt8();\r\n\t\tbyte b2 = msg.read.UInt8();\r\n\t\tuint num = msg.read.UInt32();\r\n\t\tif ((b == 0 \u0026\u0026 fogImages[b2] == num) || (b == 1 \u0026\u0026 paintImages[b2] == num))\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tuint num2 = (uint)(b * 1000 \u002B b2);\r\n\t\tbyte[] array = msg.read.BytesWithSize();\r\n\t\tif (array != null)\r\n\t\t{\r\n\t\t\tFileStorage.server.RemoveEntityNum(net.ID, num2);\r\n\t\t\tuint num3 = FileStorage.server.Store(array, FileStorage.Type.png, net.ID, num2);\r\n\t\t\tif (b == 0)\r\n\t\t\t{\r\n\t\t\t\tfogImages[b2] = num3;\r\n\t\t\t}\r\n\t\t\tif (b == 1)\r\n\t\t\t{\r\n\t\t\t\tpaintImages[b2] = num3;\r\n\t\t\t}\r\n\t\t\tInvalidateNetworkCache();\r\n\t\t\tInterface.CallHook(\u0022OnMapImageUpdated\u0022, null);\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "MapEntity",
    "HookLineInvoke": 27
  },
  {
    "HookSignature": "OnMeleeThrown(BasePlayer player, Item item)",
    "MethodSignature": "CLProject(RPCMessage msg)",
    "MethodSourseCode": "\r\n\t[RPC_Server]\r\n\t[RPC_Server.FromOwner]\r\n\tprivate void CLProject(RPCMessage msg)\r\n\t{\r\n\t\tBasePlayer player = msg.player;\r\n\t\tif (!VerifyClientAttack(player))\r\n\t\t{\r\n\t\t\tSendNetworkUpdate();\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (!canThrowAsProjectile)\r\n\t\t{\r\n\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Not throwable (\u0022 \u002B base.ShortPrefabName \u002B \u0022)\u0022);\r\n\t\t\tplayer.stats.combat.Log(this, \u0022not_throwable\u0022);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tItem item = GetItem();\r\n\t\tif (item == null)\r\n\t\t{\r\n\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Item not found (\u0022 \u002B base.ShortPrefabName \u002B \u0022)\u0022);\r\n\t\t\tplayer.stats.combat.Log(this, \u0022item_missing\u0022);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tItemModProjectile component = item.info.GetComponent\u003CItemModProjectile\u003E();\r\n\t\tif (component == null)\r\n\t\t{\r\n\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Item mod not found (\u0022 \u002B base.ShortPrefabName \u002B \u0022)\u0022);\r\n\t\t\tplayer.stats.combat.Log(this, \u0022mod_missing\u0022);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tProjectileShoot projectileShoot = ProjectileShoot.Deserialize(msg.read);\r\n\t\tif (projectileShoot.projectiles.Count != 1)\r\n\t\t{\r\n\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Projectile count mismatch (\u0022 \u002B base.ShortPrefabName \u002B \u0022)\u0022);\r\n\t\t\tplayer.stats.combat.Log(this, \u0022count_mismatch\u0022);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tplayer.CleanupExpiredProjectiles();\r\n\t\tforeach (ProjectileShoot.Projectile projectile in projectileShoot.projectiles)\r\n\t\t{\r\n\t\t\tif (player.HasFiredProjectile(projectile.projectileID))\r\n\t\t\t{\r\n\t\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Duplicate ID (\u0022 \u002B projectile.projectileID \u002B \u0022)\u0022);\r\n\t\t\t\tplayer.stats.combat.Log(this, \u0022duplicate_id\u0022);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tplayer.NoteFiredProjectile(projectile.projectileID, projectile.startPos, projectile.startVel, this, item.info, item);\r\n\t\t\tEffect effect = new Effect();\r\n\t\t\teffect.Init(Effect.Type.Projectile, projectile.startPos, projectile.startVel, msg.connection);\r\n\t\t\teffect.scale = 1f;\r\n\t\t\teffect.pooledString = component.projectileObject.resourcePath;\r\n\t\t\teffect.number = projectile.seed;\r\n\t\t\tEffectNetwork.Send(effect);\r\n\t\t}\r\n\t\titem.SetParent(null);\r\n\t\tInterface.CallHook(\u0022OnMeleeThrown\u0022, player, item);\r\n\t}\r\n",
    "ClassName": "BaseMelee",
    "HookLineInvoke": 56
  },
  {
    "HookSignature": "CanUnlock(CodeLock codeLock, BasePlayer rpcPlayer)",
    "MethodSignature": "TryUnlock(RPCMessage rpc)",
    "MethodSourseCode": "\r\n\t[RPC_Server]\r\n\t[RPC_Server.MaxDistance(3f)]\r\n\tprivate void TryUnlock(RPCMessage rpc)\r\n\t{\r\n\t\tif (rpc.player.CanInteract() \u0026\u0026 IsLocked() \u0026\u0026 Interface.CallHook(\u0022CanUnlock\u0022, this, rpc.player) == null)\r\n\t\t{\r\n\t\t\tif (whitelistPlayers.Contains(rpc.player.userID))\r\n\t\t\t{\r\n\t\t\t\tDoEffect(effectUnlocked.resourcePath);\r\n\t\t\t\tSetFlag(Flags.Locked, b: false);\r\n\t\t\t\tSendNetworkUpdate();\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tClientRPCPlayer(null, rpc.player, \u0022EnterUnlockCode\u0022);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "CodeLock",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnCupboardDeauthorize(BuildingPrivlidge buildingPrivlidge, BasePlayer rpcPlayer)",
    "MethodSignature": "RemoveSelfAuthorize(RPCMessage rpc)",
    "MethodSourseCode": "\r\n\t[RPC_Server.IsVisible(3f)]\r\n\t[RPC_Server]\r\n\tprivate void RemoveSelfAuthorize(RPCMessage rpc)\r\n\t{\r\n\t\tRPCMessage rpc2 = rpc;\r\n\t\tif (rpc2.player.CanInteract() \u0026\u0026 CanAdministrate(rpc2.player) \u0026\u0026 Interface.CallHook(\u0022OnCupboardDeauthorize\u0022, this, rpc.player) == null)\r\n\t\t{\r\n\t\t\tauthorizedPlayers.RemoveAll((PlayerNameID x) =\u003E x.userid == rpc2.player.userID);\r\n\t\t\tUpdateAllPlayers();\r\n\t\t\tSendNetworkUpdate();\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "BuildingPrivlidge",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "IOnBasePlayerAttacked(BasePlayer basePlayer, HitInfo info)",
    "MethodSignature": "OnAttacked(HitInfo info)",
    "MethodSourseCode": "\r\n\tpublic override void OnAttacked(HitInfo info)\r\n\t{\r\n\t\tif (Interface.CallHook(\u0022IOnBasePlayerAttacked\u0022, this, info) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tfloat health_old = base.health;\r\n\t\tif (base.isServer)\r\n\t\t{\r\n\t\t\tHitArea boneArea = info.boneArea;\r\n\t\t\tif (boneArea != (HitArea)(-1))\r\n\t\t\t{\r\n\t\t\t\tList\u003CItem\u003E obj = Facepunch.Pool.GetList\u003CItem\u003E();\r\n\t\t\t\tobj.AddRange(inventory.containerWear.itemList);\r\n\t\t\t\tfor (int i = 0; i \u003C obj.Count; i\u002B\u002B)\r\n\t\t\t\t{\r\n\t\t\t\t\tItem item = obj[i];\r\n\t\t\t\t\tif (item != null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tItemModWearable component = item.info.GetComponent\u003CItemModWearable\u003E();\r\n\t\t\t\t\t\tif (!(component == null) \u0026\u0026 component.ProtectsArea(boneArea))\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\titem.OnAttacked(info);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tFacepunch.Pool.FreeList(ref obj);\r\n\t\t\t\tinventory.ServerUpdate(0f);\r\n\t\t\t}\r\n\t\t}\r\n\t\tbase.OnAttacked(info);\r\n\t\tif (base.isServer \u0026\u0026 base.isServer \u0026\u0026 info.hasDamage)\r\n\t\t{\r\n\t\t\tif (!info.damageTypes.Has(DamageType.Bleeding) \u0026\u0026 info.damageTypes.IsBleedCausing() \u0026\u0026 !IsWounded() \u0026\u0026 !IsImmortal())\r\n\t\t\t{\r\n\t\t\t\tmetabolism.bleeding.Add(info.damageTypes.Total() * 0.2f);\r\n\t\t\t}\r\n\t\t\tCheckDeathCondition(info);\r\n\t\t\tif (net != null \u0026\u0026 net.connection != null)\r\n\t\t\t{\r\n\t\t\t\tEffect effect = new Effect();\r\n\t\t\t\teffect.Init(Effect.Type.Generic, base.transform.position, base.transform.forward);\r\n\t\t\t\teffect.pooledString = \u0022assets/bundled/prefabs/fx/takedamage_hit.prefab\u0022;\r\n\t\t\t\tEffectNetwork.Send(effect, net.connection);\r\n\t\t\t}\r\n\t\t\tstring text = StringPool.Get(info.HitBone);\r\n\t\t\tUnityEngine.Vector3 normalized = (info.PointEnd - info.PointStart).normalized;\r\n\t\t\tbool flag = UnityEngine.Vector3.Dot(normalized, eyes.BodyForward()) \u003E 0.4f;\r\n\t\t\tif (info.isHeadshot)\r\n\t\t\t{\r\n\t\t\t\tif (flag)\r\n\t\t\t\t{\r\n\t\t\t\t\tSignalBroadcast(Signal.Flinch_RearHead, string.Empty);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tSignalBroadcast(Signal.Flinch_Head, string.Empty);\r\n\t\t\t\t}\r\n\t\t\t\tBasePlayer initiatorPlayer = info.InitiatorPlayer;\r\n\t\t\t\tEffect.server.Run(\u0022assets/bundled/prefabs/fx/headshot.prefab\u0022, this, 0u, new UnityEngine.Vector3(0f, 2f, 0f), UnityEngine.Vector3.zero, (!(initiatorPlayer != null)) ? null : initiatorPlayer.net.connection);\r\n\t\t\t\tif ((bool)initiatorPlayer)\r\n\t\t\t\t{\r\n\t\t\t\t\tinitiatorPlayer.stats.Add(\u0022headshot\u0022, 1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (flag)\r\n\t\t\t{\r\n\t\t\t\tSignalBroadcast(Signal.Flinch_RearTorso, string.Empty);\r\n\t\t\t}\r\n\t\t\telse if (text == \u0022spine\u0022 || text == \u0022spine2\u0022)\r\n\t\t\t{\r\n\t\t\t\tSignalBroadcast(Signal.Flinch_Stomach, string.Empty);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tSignalBroadcast(Signal.Flinch_Chest, string.Empty);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (stats != null)\r\n\t\t{\r\n\t\t\tif (IsWounded())\r\n\t\t\t{\r\n\t\t\t\tstats.combat.Log(info, health_old, base.health, \u0022wounded\u0022);\r\n\t\t\t}\r\n\t\t\telse if (IsDead())\r\n\t\t\t{\r\n\t\t\t\tstats.combat.Log(info, health_old, base.health, \u0022killed\u0022);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tstats.combat.Log(info, health_old, base.health);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanBypassQueue(Network.Connection connection)",
    "MethodSignature": "CanJumpQueue(Connection connection)",
    "MethodSourseCode": "\r\n\tprivate bool CanJumpQueue(Connection connection)\r\n\t{\r\n\t\tobject obj = Interface.CallHook(\u0022CanBypassQueue\u0022, connection);\r\n\t\tif (obj is bool)\r\n\t\t{\r\n\t\t\treturn (bool)obj;\r\n\t\t}\r\n\t\tif (DeveloperList.Contains(connection.userid))\r\n\t\t{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tServerUsers.User user = ServerUsers.Get(connection.userid);\r\n\t\tif (user != null \u0026\u0026 user.group == ServerUsers.UserGroup.Moderator)\r\n\t\t{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tif (user != null \u0026\u0026 user.group == ServerUsers.UserGroup.Owner)\r\n\t\t{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n",
    "ClassName": "ConnectionQueue",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanSetBedPublic(SleepingBag sleepingBag, BasePlayer msgPlayer)",
    "MethodSignature": "RPC_MakePublic(RPCMessage msg)",
    "MethodSourseCode": "\r\n\t[RPC_Server.MaxDistance(3f)]\r\n\t[RPC_Server]\r\n\tpublic void RPC_MakePublic(RPCMessage msg)\r\n\t{\r\n\t\tif (!canBePublic || !msg.player.CanInteract() || (deployerUserID != msg.player.userID \u0026\u0026 !msg.player.CanBuild()))\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tbool flag = msg.read.Bit();\r\n\t\tif (flag != IsPublic() \u0026\u0026 Interface.CallHook(\u0022CanSetBedPublic\u0022, this, msg.player) == null)\r\n\t\t{\r\n\t\t\tSetPublic(flag);\r\n\t\t\tif (!IsPublic())\r\n\t\t\t{\r\n\t\t\t\tdeployerUserID = msg.player.userID;\r\n\t\t\t}\r\n\t\t\tSendNetworkUpdate();\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "SleepingBag",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnTurretTarget(AutoTurret autoTurret, BaseCombatEntity targ)",
    "MethodSignature": "SetTarget(BaseCombatEntity targ)",
    "MethodSourseCode": "\r\n\tpublic void SetTarget(BaseCombatEntity targ)\r\n\t{\r\n\t\tif (Interface.CallHook(\u0022OnTurretTarget\u0022, this, targ) == null)\r\n\t\t{\r\n\t\t\tif (targ != target)\r\n\t\t\t{\r\n\t\t\t\tEffect.server.Run((!(targ == null)) ? targetAcquiredEffect.resourcePath : targetLostEffect.resourcePath, base.transform.position, Vector3.up);\r\n\t\t\t}\r\n\t\t\ttarget = targ;\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "AutoTurret",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnTurretStartup(AutoTurret autoTurret)",
    "MethodSignature": "InitiateStartup()",
    "MethodSourseCode": "\r\n\tpublic void InitiateStartup()\r\n\t{\r\n\t\tif (!IsOnline() \u0026\u0026 !booting \u0026\u0026 Interface.CallHook(\u0022OnTurretStartup\u0022, this) == null)\r\n\t\t{\r\n\t\t\tEffect.server.Run(onlineSound.resourcePath, this, 0u, Vector3.zero, Vector3.zero);\r\n\t\t\tInvoke(SetOnline, 2f);\r\n\t\t\tbooting = true;\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "AutoTurret",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanUseMailbox(BasePlayer player, Mailbox mailbox)",
    "MethodSignature": "PlayerIsOwner(BasePlayer player)",
    "MethodSourseCode": "\r\n\tpublic virtual bool PlayerIsOwner(BasePlayer player)\r\n\t{\r\n\t\tobject obj = Interface.CallHook(\u0022CanUseMailbox\u0022, player, this);\r\n\t\tif (obj is bool)\r\n\t\t{\r\n\t\t\treturn (bool)obj;\r\n\t\t}\r\n\t\treturn player.CanBuild();\r\n\t}\r\n",
    "ClassName": "Mailbox",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnItemUse(Item item, int amountToConsume)",
    "MethodSignature": "UseItem(int amountToConsume)",
    "MethodSourseCode": "\r\n\tpublic void UseItem(int amountToConsume = 1)\r\n\t{\r\n\t\tif (amountToConsume \u003E 0)\r\n\t\t{\r\n\t\t\tInterface.CallHook(\u0022OnItemUse\u0022, this, amountToConsume);\r\n\t\t\tamount -= amountToConsume;\r\n\t\t\tif (amount \u003C= 0)\r\n\t\t\t{\r\n\t\t\t\tamount = 0;\r\n\t\t\t\tRemove();\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tMarkDirty();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "Item",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "CanUpdateSign(BasePlayer player, Signage signage)",
    "MethodSignature": "CanUpdateSign(BasePlayer player)",
    "MethodSourseCode": "\r\n\tpublic bool CanUpdateSign(BasePlayer player)\r\n\t{\r\n\t\tobject obj = Interface.CallHook(\u0022CanUpdateSign\u0022, player, this);\r\n\t\tif (obj is bool)\r\n\t\t{\r\n\t\t\treturn (bool)obj;\r\n\t\t}\r\n\t\tif (player.IsAdmin || player.IsDeveloper)\r\n\t\t{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tif (!player.CanBuild())\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (IsLocked())\r\n\t\t{\r\n\t\t\treturn player.userID == base.OwnerID;\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n",
    "ClassName": "Signage",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnReloadMagazine(BasePlayer ownerPlayer, BaseProjectile baseProjectile)",
    "MethodSignature": "ReloadMagazine()",
    "MethodSourseCode": "\r\n\tprotected void ReloadMagazine()\r\n\t{\r\n\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\r\n\t\tif ((bool)ownerPlayer \u0026\u0026 Interface.CallHook(\u0022OnReloadMagazine\u0022, ownerPlayer, this) == null)\r\n\t\t{\r\n\t\t\tprimaryMagazine.Reload(ownerPlayer);\r\n\t\t\tSendNetworkUpdateImmediate();\r\n\t\t\tItemManager.DoRemoves();\r\n\t\t\townerPlayer.inventory.ServerUpdate(0f);\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "BaseProjectile",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnLiftUse(Lift lift, BasePlayer rpcPlayer)",
    "MethodSignature": "RPC_UseLift(RPCMessage rpc)",
    "MethodSourseCode": "\r\n\t[RPC_Server.MaxDistance(3f)]\r\n\t[RPC_Server]\r\n\tprivate void RPC_UseLift(RPCMessage rpc)\r\n\t{\r\n\t\tif (rpc.player.CanInteract() \u0026\u0026 Interface.CallHook(\u0022OnLiftUse\u0022, this, rpc.player) == null)\r\n\t\t{\r\n\t\t\tMoveUp();\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "Lift",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnPlayerRecover(BasePlayer basePlayer)",
    "MethodSignature": "StopWounded()",
    "MethodSourseCode": "\r\n\tpublic void StopWounded()\r\n\t{\r\n\t\tif (Interface.CallHook(\u0022OnPlayerRecover\u0022, this) == null)\r\n\t\t{\r\n\t\t\tSetPlayerFlag(PlayerFlags.Wounded, b: false);\r\n\t\t\tCancelInvoke(WoundingTick);\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnItemUpgrade(Item item, Item item2, BasePlayer player)",
    "MethodSignature": "ServerCommand(Item item, string command, BasePlayer player)",
    "MethodSourseCode": "\r\n\tpublic override void ServerCommand(Item item, string command, BasePlayer player)\r\n\t{\r\n\t\tif (!(command == \u0022upgrade_item\u0022) || item.amount \u003C numForUpgrade)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tfloat num = UnityEngine.Random.Range(0f, 1f);\r\n\t\tif (num \u003C= upgradeSuccessChance)\r\n\t\t{\r\n\t\t\titem.UseItem(numForUpgrade);\r\n\t\t\tItem item2 = ItemManager.Create(upgradedItem, numUpgradedItem, 0uL);\r\n\t\t\tInterface.CallHook(\u0022OnItemUpgrade\u0022, item, item2, player);\r\n\t\t\tif (!item2.MoveToContainer(player.inventory.containerMain))\r\n\t\t\t{\r\n\t\t\t\titem2.Drop(player.eyes.position, player.eyes.BodyForward() * 2f);\r\n\t\t\t}\r\n\t\t\tif (successEffect.isValid)\r\n\t\t\t{\r\n\t\t\t\tEffect.server.Run(successEffect.resourcePath, player.eyes.position);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\titem.UseItem(numToLoseOnFail);\r\n\t\t\tif (failEffect.isValid)\r\n\t\t\t{\r\n\t\t\t\tEffect.server.Run(failEffect.resourcePath, player.eyes.position);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "ItemModUpgrade",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "OnConsumeFuel(BaseOven baseOven, Item fuel, ItemModBurnable burnable)",
    "MethodSignature": "ConsumeFuel(Item fuel, ItemModBurnable burnable)",
    "MethodSourseCode": "\r\n\tprivate void ConsumeFuel(Item fuel, ItemModBurnable burnable)\r\n\t{\r\n\t\tInterface.CallHook(\u0022OnConsumeFuel\u0022, this, fuel, burnable);\r\n\t\tif (allowByproductCreation \u0026\u0026 burnable.byproductItem != null \u0026\u0026 UnityEngine.Random.Range(0f, 1f) \u003E burnable.byproductChance)\r\n\t\t{\r\n\t\t\tItem item = ItemManager.Create(burnable.byproductItem, burnable.byproductAmount, 0uL);\r\n\t\t\tif (!item.MoveToContainer(inventory))\r\n\t\t\t{\r\n\t\t\t\tOvenFull();\r\n\t\t\t\titem.Drop(inventory.dropPosition, inventory.dropVelocity);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (fuel.amount \u003C= 1)\r\n\t\t{\r\n\t\t\tfuel.Remove();\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tfuel.amount--;\r\n\t\tfuel.fuel = burnable.fuelAmount;\r\n\t\tfuel.MarkDirty();\r\n\t}\r\n",
    "ClassName": "BaseOven",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnServerInitialized()",
    "MethodSignature": "OpenConnection()",
    "MethodSourseCode": "\r\n\tpublic void OpenConnection()\r\n\t{\r\n\t\tNetwork.Net.sv.ip = ConVar.Server.ip;\r\n\t\tNetwork.Net.sv.port = ConVar.Server.port;\r\n\t\tif (!Network.Net.sv.Start())\r\n\t\t{\r\n\t\t\tUnityEngine.Debug.LogWarning(\u0022Couldn\u0027t Start Server.\u0022);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tStartSteamServer();\r\n\t\tNetwork.Net.sv.onMessage = OnNetworkMessage;\r\n\t\tNetwork.Net.sv.onUnconnectedMessage = OnUnconnectedMessage;\r\n\t\tNetwork.Net.sv.onDisconnected = OnDisconnected;\r\n\t\tEACServer.DoStartup();\r\n\t\tInvokeRepeating(\u0022EACUpdate\u0022, 1f, 1f);\r\n\t\tInvokeRepeating(\u0022DoTick\u0022, 1f, 1f / (float)ConVar.Server.tickrate);\r\n\t\tInvokeRepeating(\u0022DoHeartbeat\u0022, 1f, 1f);\r\n\t\trunFrameUpdate = true;\r\n\t\tInterface.CallHook(\u0022OnServerInitialized\u0022, null);\r\n\t}\r\n",
    "ClassName": "ServerMgr",
    "HookLineInvoke": 19
  },
  {
    "HookSignature": "OnPlayerChat(ConsoleSystem.Arg arg)",
    "MethodSignature": "say(Arg arg)",
    "MethodSourseCode": "\r\n\t[ServerUserVar]\r\n\tpublic static void say(Arg arg)\r\n\t{\r\n\t\tif (!enabled)\r\n\t\t{\r\n\t\t\targ.ReplyWith(\u0022Chat is disabled.\u0022);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tBasePlayer basePlayer = ArgEx.Player(arg);\r\n\t\tif (!basePlayer || basePlayer.HasPlayerFlag(BasePlayer.PlayerFlags.ChatMute))\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (!basePlayer.IsAdmin \u0026\u0026 !basePlayer.IsDeveloper)\r\n\t\t{\r\n\t\t\tif (basePlayer.NextChatTime == 0f)\r\n\t\t\t{\r\n\t\t\t\tbasePlayer.NextChatTime = UnityEngine.Time.realtimeSinceStartup - 30f;\r\n\t\t\t}\r\n\t\t\tif (basePlayer.NextChatTime \u003E UnityEngine.Time.realtimeSinceStartup)\r\n\t\t\t{\r\n\t\t\t\tbasePlayer.NextChatTime \u002B= 2f;\r\n\t\t\t\tfloat num = basePlayer.NextChatTime - UnityEngine.Time.realtimeSinceStartup;\r\n\t\t\t\tConsoleNetwork.SendClientCommand(basePlayer.net.connection, \u0022chat.add\u0022, 0, \u0022You\u0027re chatting too fast - try again in \u0022 \u002B (num \u002B 0.5f).ToString(\u00220\u0022) \u002B \u0022 seconds\u0022);\r\n\t\t\t\tif (num \u003E 120f)\r\n\t\t\t\t{\r\n\t\t\t\t\tbasePlayer.Kick(\u0022Chatting too fast\u0022);\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t\tstring text = arg.GetString(0, \u0022text\u0022).Trim();\r\n\t\tif (text.Length \u003E 128)\r\n\t\t{\r\n\t\t\ttext = text.Substring(0, 128);\r\n\t\t}\r\n\t\tif (text.Length \u003C= 0 || text.StartsWith(\u0022/\u0022) || text.StartsWith(\u0022\\\\\u0022) || (text.Contains(\u0022\u003C\u0022) \u0026\u0026 (StringEx.Contains(text, \u0022\u003Csize\u0022, CompareOptions.IgnoreCase) || StringEx.Contains(text, \u0022\u003Ccolor\u0022, CompareOptions.IgnoreCase) || StringEx.Contains(text, \u0022\u003Cmaterial\u0022, CompareOptions.IgnoreCase) || StringEx.Contains(text, \u0022\u003Cquad\u0022, CompareOptions.IgnoreCase) || StringEx.Contains(text, \u0022\u003Cb\u003E\u0022, CompareOptions.IgnoreCase) || StringEx.Contains(text, \u0022\u003Ci\u003E\u0022, CompareOptions.IgnoreCase))) || Interface.CallHook(\u0022OnPlayerChat\u0022, arg) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (serverlog)\r\n\t\t{\r\n\t\t\tServerConsole.PrintColoured(ConsoleColor.DarkYellow, basePlayer.displayName \u002B \u0022: \u0022, ConsoleColor.DarkGreen, text);\r\n\t\t\tServer.Log(\u0022Log.Chat.txt\u0022, $\u0022{basePlayer.ToString()}: {text}\\n\u0022);\r\n\t\t\tDebug.Log($\u0022[CHAT] {basePlayer.ToString()} : {text}\u0022);\r\n\t\t}\r\n\t\tstring text2 = \u0022#5af\u0022;\r\n\t\tif (basePlayer.IsAdmin)\r\n\t\t{\r\n\t\t\ttext2 = \u0022#af5\u0022;\r\n\t\t}\r\n\t\tif (basePlayer.IsDeveloper)\r\n\t\t{\r\n\t\t\ttext2 = \u0022#fa5\u0022;\r\n\t\t}\r\n\t\tstring displayName = basePlayer.displayName;\r\n\t\tdisplayName = displayName.Replace(\u0027\u003C\u0027, \u0027[\u0027).Replace(\u0027\u003E\u0027, \u0027]\u0027);\r\n\t\tbasePlayer.NextChatTime = UnityEngine.Time.realtimeSinceStartup \u002B 1.5f;\r\n\t\tChatEntry chatEntry = default(ChatEntry);\r\n\t\tchatEntry.Message = text;\r\n\t\tchatEntry.UserId = basePlayer.userID;\r\n\t\tchatEntry.Username = basePlayer.displayName;\r\n\t\tchatEntry.Color = text2;\r\n\t\tchatEntry.Time = Epoch.Current;\r\n\t\tChatEntry chatEntry2 = chatEntry;\r\n\t\tHistory.Add(chatEntry2);\r\n\t\tRCon.Broadcast(RCon.LogType.Chat, chatEntry2);\r\n\t\tif (Server.globalchat)\r\n\t\t{\r\n\t\t\tConsoleNetwork.BroadcastToAllClients(\u0022chat.add2\u0022, basePlayer.userID, text, displayName, text2, 1f);\r\n\t\t\targ.ReplyWith(string.Empty);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tfloat num2 = 2500f;\r\n\t\tforeach (BasePlayer activePlayer in BasePlayer.activePlayerList)\r\n\t\t{\r\n\t\t\tfloat sqrMagnitude = (activePlayer.transform.position - basePlayer.transform.position).sqrMagnitude;\r\n\t\t\tif (!(sqrMagnitude \u003E num2))\r\n\t\t\t{\r\n\t\t\t\tConsoleNetwork.SendClientCommand(activePlayer.net.connection, \u0022chat.add2\u0022, basePlayer.userID, text, displayName, text2, Mathf.Clamp01(num2 - sqrMagnitude \u002B 0.2f));\r\n\t\t\t}\r\n\t\t}\r\n\t\targ.ReplyWith(string.Empty);\r\n\t}\r\n",
    "ClassName": "Chat",
    "HookLineInvoke": 37
  },
  {
    "HookSignature": "IOnBaseCombatEntityHurt(BaseCombatEntity baseCombatEntity, HitInfo info)",
    "MethodSignature": "Hurt(HitInfo info)",
    "MethodSourseCode": "\r\n\tpublic virtual void Hurt(HitInfo info)\r\n\t{\r\n\t\tAssert.IsTrue(base.isServer, \u0022This should be called serverside only\u0022);\r\n\t\tif (IsDead())\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tusing (TimeWarning.New(\u0022Hurt( HitInfo )\u0022, 50L))\r\n\t\t{\r\n\t\t\tfloat num = health;\r\n\t\t\tScaleDamage(info);\r\n\t\t\tif (info.PointStart != Vector3.zero)\r\n\t\t\t{\r\n\t\t\t\tfor (int i = 0; i \u003C propDirection.Length; i\u002B\u002B)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (!(propDirection[i].extraProtection == null) \u0026\u0026 !propDirection[i].IsWeakspot(base.transform, info))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tpropDirection[i].extraProtection.Scale(info.damageTypes);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tinfo.damageTypes.Scale(DamageType.Arrow, ConVar.Server.arrowdamage);\r\n\t\t\tinfo.damageTypes.Scale(DamageType.Bullet, ConVar.Server.bulletdamage);\r\n\t\t\tinfo.damageTypes.Scale(DamageType.Slash, ConVar.Server.meleedamage);\r\n\t\t\tinfo.damageTypes.Scale(DamageType.Blunt, ConVar.Server.meleedamage);\r\n\t\t\tinfo.damageTypes.Scale(DamageType.Stab, ConVar.Server.meleedamage);\r\n\t\t\tinfo.damageTypes.Scale(DamageType.Bleeding, ConVar.Server.bleedingdamage);\r\n\t\t\tif (Interface.CallHook(\u0022IOnBaseCombatEntityHurt\u0022, this, info) != null)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tDebugHurt(info);\r\n\t\t\thealth = num - info.damageTypes.Total();\r\n\t\t\tSendNetworkUpdate();\r\n\t\t\tif (SingletonComponent\u003CAiManager\u003E.Instance != null \u0026\u0026 SingletonComponent\u003CAiManager\u003E.Instance.enabled \u0026\u0026 SingletonComponent\u003CAiManager\u003E.Instance.UseIntensity)\r\n\t\t\t{\r\n\t\t\t\tSingletonComponent\u003CAiManager\u003E.Instance.OnHit(info);\r\n\t\t\t}\r\n\t\t\tif (ConVar.Global.developer \u003E 1)\r\n\t\t\t{\r\n\t\t\t\tDebug.Log(string.Concat(\u0022[Combat]\u0022.PadRight(10), base.gameObject.name, \u0022 hurt \u0022, info.damageTypes.GetMajorityDamageType(), \u0022/\u0022, info.damageTypes.Total(), \u0022 - \u0022, health.ToString(\u00220\u0022), \u0022 health left\u0022));\r\n\t\t\t}\r\n\t\t\tlastDamage = info.damageTypes.GetMajorityDamageType();\r\n\t\t\tlastAttacker = info.Initiator;\r\n\t\t\tBaseCombatEntity baseCombatEntity = lastAttacker as BaseCombatEntity;\r\n\t\t\tif (baseCombatEntity != null)\r\n\t\t\t{\r\n\t\t\t\tbaseCombatEntity.MarkHostileTime();\r\n\t\t\t}\r\n\t\t\tif (lastDamage != DamageType.Decay)\r\n\t\t\t{\r\n\t\t\t\t_lastAttackedTime = UnityEngine.Time.time;\r\n\t\t\t}\r\n\t\t\tif (health \u003C= 0f)\r\n\t\t\t{\r\n\t\t\t\tDie(info);\r\n\t\t\t}\r\n\t\t\tBasePlayer initiatorPlayer = info.InitiatorPlayer;\r\n\t\t\tif ((bool)initiatorPlayer)\r\n\t\t\t{\r\n\t\t\t\tif (IsDead())\r\n\t\t\t\t{\r\n\t\t\t\t\tinitiatorPlayer.stats.combat.Log(info, num, health, \u0022killed\u0022);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tinitiatorPlayer.stats.combat.Log(info, num, health);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "BaseCombatEntity",
    "HookLineInvoke": 28
  },
  {
    "HookSignature": "OnNpcPlayerTarget(NPCPlayerApex nPCPlayerApex, BaseEntity target)",
    "MethodSignature": "GetWantsToAttack(BaseEntity target)",
    "MethodSourseCode": "\r\n\tpublic float GetWantsToAttack(BaseEntity target)\r\n\t{\r\n\t\tif (target == null)\r\n\t\t{\r\n\t\t\treturn 0f;\r\n\t\t}\r\n\t\tobject obj = Interface.CallHook(\u0022OnNpcPlayerTarget\u0022, this, target);\r\n\t\tif (obj is float)\r\n\t\t{\r\n\t\t\treturn (float)obj;\r\n\t\t}\r\n\t\tif (!target.HasAnyTrait(TraitFlag.Animal | TraitFlag.Human))\r\n\t\t{\r\n\t\t\treturn 0f;\r\n\t\t}\r\n\t\tif ((bool)target.GetComponent\u003CNPCPlayer\u003E())\r\n\t\t{\r\n\t\t\treturn 0f;\r\n\t\t}\r\n\t\tif (target.Health() \u003C= 0f)\r\n\t\t{\r\n\t\t\treturn 0f;\r\n\t\t}\r\n\t\treturn 1f;\r\n\t}\r\n",
    "ClassName": "NPCPlayerApex",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "CanBradleyApcTarget(BradleyAPC bradleyAPC, BaseEntity ent)",
    "MethodSignature": "VisibilityTest(BaseEntity ent)",
    "MethodSourseCode": "\r\n\tpublic bool VisibilityTest(BaseEntity ent)\r\n\t{\r\n\t\tif (ent == null)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (!(Vector3.Distance(ent.GetEstimatedWorldPosition(), base.transform.position) \u003C viewDistance))\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tobject obj = Interface.CallHook(\u0022CanBradleyApcTarget\u0022, this, ent);\r\n\t\tif (obj is bool)\r\n\t\t{\r\n\t\t\treturn (bool)obj;\r\n\t\t}\r\n\t\tbool flag = false;\r\n\t\tif (ent is BasePlayer)\r\n\t\t{\r\n\t\t\tBasePlayer basePlayer = ent as BasePlayer;\r\n\t\t\tVector3 position = mainTurret.transform.position;\r\n\t\t\treturn basePlayer.IsVisible(position, CenterPoint()) || basePlayer.IsVisible(position, basePlayer.eyes.position) || basePlayer.IsVisible(position, basePlayer.transform.position);\r\n\t\t}\r\n\t\tDebug.LogWarning(\u0022Standard vis test!\u0022);\r\n\t\treturn IsVisible(ent.CenterPoint());\r\n\t}\r\n",
    "ClassName": "BradleyAPC",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "IOnServerUsersRemove(ulong uID)",
    "MethodSignature": "Remove(ulong uID)",
    "MethodSourseCode": "\r\n\tpublic static void Remove(ulong uID)\r\n\t{\r\n\t\tInterface.CallHook(\u0022IOnServerUsersRemove\u0022, uID);\r\n\t\tulong uID2 = uID;\r\n\t\tusers.RemoveAll((User x) =\u003E x.steamid == uID2);\r\n\t}\r\n",
    "ClassName": "ServerUsers",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanHelicopterTarget(PatrolHelicopterAI patrolHelicopterAI, BasePlayer ply)",
    "MethodSignature": "PlayerVisible(BasePlayer ply)",
    "MethodSourseCode": "\r\n\tpublic bool PlayerVisible(BasePlayer ply)\r\n\t{\r\n\t\tobject obj = Interface.CallHook(\u0022CanHelicopterTarget\u0022, this, ply);\r\n\t\tif (obj is bool)\r\n\t\t{\r\n\t\t\treturn (bool)obj;\r\n\t\t}\r\n\t\tVector3 position = ply.eyes.position;\r\n\t\tif (TOD_Sky.Instance.IsNight \u0026\u0026 Vector3.Distance(position, interestZoneOrigin) \u003E 40f)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tVector3 vector = base.transform.position - Vector3.up * 6f;\r\n\t\tfloat num = Vector3.Distance(position, vector);\r\n\t\tVector3 normalized = (position - vector).normalized;\r\n\t\tif (GamePhysics.Trace(new Ray(vector \u002B normalized * 5f, normalized), 0f, out var hitInfo, num * 1.1f, 1084434689) \u0026\u0026 GameObjectEx.ToBaseEntity(hitInfo.collider.gameObject) == ply)\r\n\t\t{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n",
    "ClassName": "PatrolHelicopterAI",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPlayerDie(BasePlayer basePlayer, HitInfo info)",
    "MethodSignature": "Die(HitInfo info)",
    "MethodSourseCode": "\r\n\tpublic override void Die(HitInfo info = null)\r\n\t{\r\n\t\tusing (TimeWarning.New(\u0022Player.Die\u0022))\r\n\t\t{\r\n\t\t\tif (!IsDead() \u0026\u0026 Interface.CallHook(\u0022OnPlayerDie\u0022, this, info) == null)\r\n\t\t\t{\r\n\t\t\t\tif (Belt != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tUnityEngine.Vector3 vector = new UnityEngine.Vector3(UnityEngine.Random.Range(-2f, 2f), 0.2f, UnityEngine.Random.Range(-2f, 2f));\r\n\t\t\t\t\tBelt.DropActive(vector.normalized * 3f);\r\n\t\t\t\t}\r\n\t\t\t\tif (!WoundInsteadOfDying(info))\r\n\t\t\t\t{\r\n\t\t\t\t\tbase.Die(info);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "CanUseVending(VendingMachine vendingMachine, BasePlayer player)",
    "MethodSignature": "CanOpenLootPanel(BasePlayer player, string panelName)",
    "MethodSourseCode": "\r\n\tpublic override bool CanOpenLootPanel(BasePlayer player, string panelName = \u0022\u0022)\r\n\t{\r\n\t\tobject obj = Interface.CallHook(\u0022CanUseVending\u0022, this, player);\r\n\t\tif (obj is bool)\r\n\t\t{\r\n\t\t\treturn (bool)obj;\r\n\t\t}\r\n\t\tif (panelName == customerPanel)\r\n\t\t{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn base.CanOpenLootPanel(player, panelName) \u0026\u0026 CanPlayerAdmin(player);\r\n\t}\r\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanUnlock(KeyLock keyLock, BasePlayer rpcPlayer)",
    "MethodSignature": "RPC_Unlock(RPCMessage rpc)",
    "MethodSourseCode": "\r\n\t[RPC_Server.MaxDistance(3f)]\r\n\t[RPC_Server]\r\n\tprivate void RPC_Unlock(RPCMessage rpc)\r\n\t{\r\n\t\tif (rpc.player.CanInteract() \u0026\u0026 IsLocked() \u0026\u0026 Interface.CallHook(\u0022CanUnlock\u0022, this, rpc.player) == null \u0026\u0026 HasLockPermission(rpc.player))\r\n\t\t{\r\n\t\t\tSetFlag(Flags.Locked, b: false);\r\n\t\t\tSendNetworkUpdate();\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "KeyLock",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnBradleyApcInitialize(BradleyAPC bradleyAPC)",
    "MethodSignature": "Initialize()",
    "MethodSourseCode": "\r\n\tpublic void Initialize()\r\n\t{\r\n\t\tif (Interface.CallHook(\u0022OnBradleyApcInitialize\u0022, this) == null)\r\n\t\t{\r\n\t\t\tmyRigidBody.centerOfMass = centerOfMass.localPosition;\r\n\t\t\tdestination = base.transform.position;\r\n\t\t\tfinalDestination = base.transform.position;\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "BradleyAPC",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnNpcTarget(BaseNpc baseNpc, BaseEntity target)",
    "MethodSignature": "GetWantsToAttack(BaseEntity target)",
    "MethodSourseCode": "\r\n\tpublic float GetWantsToAttack(BaseEntity target)\r\n\t{\r\n\t\tobject obj = Interface.CallHook(\u0022OnNpcTarget\u0022, this, target);\r\n\t\tif (obj is float)\r\n\t\t{\r\n\t\t\treturn (float)obj;\r\n\t\t}\r\n\t\treturn WantsToAttack(target);\r\n\t}\r\n",
    "ClassName": "BaseNpc",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanNetworkTo(BaseNetworkable baseNetworkable, BasePlayer player)",
    "MethodSignature": "ShouldNetworkTo(BasePlayer player)",
    "MethodSourseCode": "\r\n\tpublic virtual bool ShouldNetworkTo(BasePlayer player)\r\n\t{\r\n\t\tobject obj = Interface.CallHook(\u0022CanNetworkTo\u0022, this, player);\r\n\t\tif (obj is bool)\r\n\t\t{\r\n\t\t\treturn (bool)obj;\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n",
    "ClassName": "BaseNetworkable",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPlayerKicked(BasePlayer basePlayer, string reason)",
    "MethodSignature": "Kick(string reason)",
    "MethodSourseCode": "\r\n\tpublic void Kick(string reason)\r\n\t{\r\n\t\tif (IsConnected)\r\n\t\t{\r\n\t\t\tNetwork.Net.sv.Kick(net.connection, reason);\r\n\t\t\tInterface.CallHook(\u0022OnPlayerKicked\u0022, this, reason);\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnEntityDeath(BaseCombatEntity baseCombatEntity, HitInfo info)",
    "MethodSignature": "Die(HitInfo info)",
    "MethodSourseCode": "\r\n\tpublic virtual void Die(HitInfo info = null)\r\n\t{\r\n\t\tif (IsDead())\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tInterface.CallHook(\u0022OnEntityDeath\u0022, this, info);\r\n\t\tif (ConVar.Global.developer \u003E 1)\r\n\t\t{\r\n\t\t\tDebug.Log(\u0022[Combat]\u0022.PadRight(10) \u002B base.gameObject.name \u002B \u0022 died\u0022);\r\n\t\t}\r\n\t\thealth = 0f;\r\n\t\tlifestate = LifeState.Dead;\r\n\t\tusing (TimeWarning.New(\u0022OnKilled\u0022))\r\n\t\t{\r\n\t\t\tOnKilled(info);\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "BaseCombatEntity",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "CanSeeStash(StashContainer stashContainer, BasePlayer rpcPlayer)",
    "MethodSignature": "RPC_WantsUnhide(RPCMessage rpc)",
    "MethodSourseCode": "\r\n\t[RPC_Server]\r\n\tpublic void RPC_WantsUnhide(RPCMessage rpc)\r\n\t{\r\n\t\tif (IsHidden() \u0026\u0026 Interface.CallHook(\u0022CanSeeStash\u0022, this, rpc.player) == null)\r\n\t\t{\r\n\t\t\tBasePlayer player = rpc.player;\r\n\t\t\tif (PlayerInRange(player))\r\n\t\t\t{\r\n\t\t\t\tSetHidden(isHidden: false);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "StashContainer",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnPlayerSleep(BasePlayer basePlayer)",
    "MethodSignature": "StartSleeping()",
    "MethodSourseCode": "\r\n\tpublic virtual void StartSleeping()\r\n\t{\r\n\t\tif (!IsSleeping() \u0026\u0026 Interface.CallHook(\u0022OnPlayerSleep\u0022, this) == null)\r\n\t\t{\r\n\t\t\tEnsureDismounted();\r\n\t\t\tSetPlayerFlag(PlayerFlags.Sleeping, b: true);\r\n\t\t\tif (!sleepingPlayerList.Contains(this))\r\n\t\t\t{\r\n\t\t\t\tsleepingPlayerList.Add(this);\r\n\t\t\t}\r\n\t\t\tCancelInvoke(InventoryUpdate);\r\n\t\t\tinventory.loot.Clear();\r\n\t\t\tinventory.crafting.CancelAll(returnItems: true);\r\n\t\t\tUpdatePlayerCollider(state: true);\r\n\t\t\tUpdatePlayerRigidbody(state: false);\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnSignUpdated(Signage signage, BasePlayer msgPlayer)",
    "MethodSignature": "UpdateSign(RPCMessage msg)",
    "MethodSourseCode": "\r\n\t[RPC_Server]\r\n\tpublic void UpdateSign(RPCMessage msg)\r\n\t{\r\n\t\tif (!CanUpdateSign(msg.player))\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tbyte[] array = msg.read.BytesWithSize();\r\n\t\tif (array != null)\r\n\t\t{\r\n\t\t\tif (textureID != 0)\r\n\t\t\t{\r\n\t\t\t\tFileStorage.server.Remove(textureID, FileStorage.Type.png, net.ID);\r\n\t\t\t\ttextureID = 0u;\r\n\t\t\t}\r\n\t\t\ttextureID = FileStorage.server.Store(array, FileStorage.Type.png, net.ID);\r\n\t\t\tInterface.CallHook(\u0022OnSignUpdated\u0022, this, msg.player);\r\n\t\t\tSendNetworkUpdate();\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "Signage",
    "HookLineInvoke": 17
  },
  {
    "HookSignature": "OnItemDeployed(Deployer deployer, BaseEntity baseEntity)",
    "MethodSignature": "DoDeploy_Slot(Deployable deployable, Ray ray, uint entityID)",
    "MethodSourseCode": "\r\n\tpublic void DoDeploy_Slot(Deployable deployable, Ray ray, uint entityID)\r\n\t{\r\n\t\tif (!HasItemAmount())\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\r\n\t\tif (!ownerPlayer || !ownerPlayer.CanBuild())\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tBaseEntity baseEntity = BaseNetworkable.serverEntities.Find(entityID) as BaseEntity;\r\n\t\tif (baseEntity == null || !baseEntity.HasSlot(deployable.slot) || baseEntity.GetSlot(deployable.slot) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tItemModDeployable modDeployable = GetModDeployable();\r\n\t\tBaseEntity baseEntity2 = GameManager.server.CreateEntity(modDeployable.entityPrefab.resourcePath);\r\n\t\tif (baseEntity2 != null)\r\n\t\t{\r\n\t\t\tTransformEx.Identity(baseEntity2.gameObject);\r\n\t\t\tbaseEntity2.SetParent(baseEntity, baseEntity.GetSlotAnchorName(deployable.slot));\r\n\t\t\tbaseEntity2.OnDeployed(baseEntity);\r\n\t\t\tbaseEntity2.Spawn();\r\n\t\t\tbaseEntity.SetSlot(deployable.slot, baseEntity2);\r\n\t\t\tif (deployable.placeEffect.isValid)\r\n\t\t\t{\r\n\t\t\t\tEffect.server.Run(deployable.placeEffect.resourcePath, baseEntity.transform.position, Vector3.up);\r\n\t\t\t}\r\n\t\t}\r\n\t\tmodDeployable.OnDeployed(baseEntity2, ownerPlayer);\r\n\t\tInterface.CallHook(\u0022OnItemDeployed\u0022, this, baseEntity);\r\n\t\tUseItemAmount(1);\r\n\t}\r\n",
    "ClassName": "Deployer",
    "HookLineInvoke": 32
  },
  {
    "HookSignature": "OnTrapSnapped(BaseTrapTrigger baseTrapTrigger, UnityEngine.GameObject obj)",
    "MethodSignature": "OnObjectAdded(GameObject obj)",
    "MethodSourseCode": "\r\n\tinternal override void OnObjectAdded(GameObject obj)\r\n\t{\r\n\t\tInterface.CallHook(\u0022OnTrapSnapped\u0022, this, obj);\r\n\t\tbase.OnObjectAdded(obj);\r\n\t\t_trap.ObjectEntered(obj);\r\n\t}\r\n",
    "ClassName": "BaseTrapTrigger",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPlayerSleepEnded(BasePlayer basePlayer)",
    "MethodSignature": "EndSleeping()",
    "MethodSourseCode": "\r\n\tpublic virtual void EndSleeping()\r\n\t{\r\n\t\tif (IsSleeping())\r\n\t\t{\r\n\t\t\tSetPlayerFlag(PlayerFlags.Sleeping, b: false);\r\n\t\t\tsleepingPlayerList.Remove(this);\r\n\t\t\tInvokeRepeating(InventoryUpdate, 1f, 0.1f * UnityEngine.Random.Range(0.99f, 1.01f));\r\n\t\t\tUpdatePlayerCollider(state: true);\r\n\t\t\tUpdatePlayerRigidbody(state: true);\r\n\t\t\tInterface.CallHook(\u0022OnPlayerSleepEnded\u0022, this);\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnPlayerTick(BasePlayer basePlayer, PlayerTick msg, bool wasPlayerStalled)",
    "MethodSignature": "OnReceiveTick(PlayerTick msg, bool wasPlayerStalled)",
    "MethodSourseCode": "\r\n\tprivate void OnReceiveTick(PlayerTick msg, bool wasPlayerStalled)\r\n\t{\r\n\t\tif (msg.inputState != null)\r\n\t\t{\r\n\t\t\tserverInput.Flip(msg.inputState);\r\n\t\t}\r\n\t\tif (Interface.CallHook(\u0022OnPlayerTick\u0022, this, msg, wasPlayerStalled) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (serverInput.current.buttons != serverInput.previous.buttons)\r\n\t\t{\r\n\t\t\tlastInputTime = UnityEngine.Time.time;\r\n\t\t}\r\n\t\tif (IsReceivingSnapshot)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (IsSpectating())\r\n\t\t{\r\n\t\t\tusing (TimeWarning.New(\u0022Tick_Spectator\u0022))\r\n\t\t\t{\r\n\t\t\t\tTick_Spectator();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (IsDead())\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (IsSleeping())\r\n\t\t{\r\n\t\t\tif (serverInput.WasJustPressed(BUTTON.FIRE_PRIMARY) || serverInput.WasJustPressed(BUTTON.FIRE_SECONDARY) || serverInput.WasJustPressed(BUTTON.JUMP) || serverInput.WasJustPressed(BUTTON.DUCK))\r\n\t\t\t{\r\n\t\t\t\tEndSleeping();\r\n\t\t\t\tSendNetworkUpdateImmediate();\r\n\t\t\t}\r\n\t\t\tUpdateActiveItem(0u);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tUpdateActiveItem(msg.activeItem);\r\n\t\tUpdateModelStateFromTick(msg);\r\n\t\tif (!IsWounded())\r\n\t\t{\r\n\t\t\tUpdatePositionFromTick(msg, wasPlayerStalled);\r\n\t\t\tUpdateRotationFromTick(msg);\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnPlayerAttack(BasePlayer basePlayer, HitInfo hitInfo)",
    "MethodSignature": "OnProjectileAttack(RPCMessage msg)",
    "MethodSourseCode": "\r\n\t[RPC_Server]\r\n\t[RPC_Server.FromOwner]\r\n\tpublic void OnProjectileAttack(RPCMessage msg)\r\n\t{\r\n\t\tPlayerProjectileAttack playerProjectileAttack = PlayerProjectileAttack.Deserialize(msg.read);\r\n\t\tif (playerProjectileAttack == null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tPlayerAttack playerAttack = playerProjectileAttack.playerAttack;\r\n\t\tHitInfo hitInfo = new HitInfo();\r\n\t\thitInfo.LoadFromAttack(playerAttack.attack, serverSide: true);\r\n\t\thitInfo.Initiator = this;\r\n\t\thitInfo.ProjectileID = playerAttack.projectileID;\r\n\t\thitInfo.ProjectileDistance = playerProjectileAttack.hitDistance;\r\n\t\thitInfo.ProjectileVelocity = playerProjectileAttack.hitVelocity;\r\n\t\thitInfo.Predicted = msg.connection;\r\n\t\tif (hitInfo.IsNaNOrInfinity())\r\n\t\t{\r\n\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Contains NaN (\u0022 \u002B playerAttack.projectileID \u002B \u0022)\u0022);\r\n\t\t\tplayerProjectileAttack.ResetToPool();\r\n\t\t\tplayerProjectileAttack = null;\r\n\t\t\tstats.combat.Log(hitInfo, \u0022projectile_nan\u0022);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (!firedProjectiles.TryGetValue(playerAttack.projectileID, out var value))\r\n\t\t{\r\n\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Missing ID (\u0022 \u002B playerAttack.projectileID \u002B \u0022)\u0022);\r\n\t\t\tplayerProjectileAttack.ResetToPool();\r\n\t\t\tplayerProjectileAttack = null;\r\n\t\t\tstats.combat.Log(hitInfo, \u0022projectile_invalid\u0022);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (value.integrity \u003C= 0f)\r\n\t\t{\r\n\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Integrity is zero (\u0022 \u002B playerAttack.projectileID \u002B \u0022)\u0022);\r\n\t\t\tplayerProjectileAttack.ResetToPool();\r\n\t\t\tplayerProjectileAttack = null;\r\n\t\t\tstats.combat.Log(hitInfo, \u0022projectile_integrity\u0022);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (value.firedTime \u003C UnityEngine.Time.realtimeSinceStartup - 8f)\r\n\t\t{\r\n\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Lifetime is zero (\u0022 \u002B playerAttack.projectileID \u002B \u0022)\u0022);\r\n\t\t\tplayerProjectileAttack.ResetToPool();\r\n\t\t\tplayerProjectileAttack = null;\r\n\t\t\tstats.combat.Log(hitInfo, \u0022projectile_lifetime\u0022);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\thitInfo.Weapon = value.weaponSource;\r\n\t\thitInfo.WeaponPrefab = value.weaponPrefab;\r\n\t\thitInfo.ProjectilePrefab = value.projectilePrefab;\r\n\t\thitInfo.damageProperties = value.projectilePrefab.damageProperties;\r\n\t\tif (ConVar.AntiHack.projectile_protection \u003E 0 \u0026\u0026 (bool)hitInfo.HitEntity)\r\n\t\t{\r\n\t\t\tbool flag = true;\r\n\t\t\tfloat num = 1f \u002B ConVar.AntiHack.projectile_forgiveness;\r\n\t\t\tfloat projectile_clientframes = ConVar.AntiHack.projectile_clientframes;\r\n\t\t\tfloat projectile_serverframes = ConVar.AntiHack.projectile_serverframes;\r\n\t\t\tfloat num2 = Mathx.Decrement(value.firedTime);\r\n\t\t\tfloat num3 = Mathx.Increment(UnityEngine.Time.realtimeSinceStartup);\r\n\t\t\tfloat num4 = num3 - num2;\r\n\t\t\tfloat num5 = projectile_clientframes / 60f;\r\n\t\t\tfloat num6 = projectile_serverframes * Mathx.Max(UnityEngine.Time.deltaTime, UnityEngine.Time.smoothDeltaTime, UnityEngine.Time.fixedDeltaTime);\r\n\t\t\tfloat num7 = (desyncTime \u002B num4 \u002B num5 \u002B num6) * num;\r\n\t\t\tif (ConVar.AntiHack.projectile_protection \u003E= 2)\r\n\t\t\t{\r\n\t\t\t\tfloat num8 = hitInfo.HitEntity.MaxVelocity();\r\n\t\t\t\tfloat num9 = hitInfo.HitEntity.BoundsPadding() \u002B num7 * num8;\r\n\t\t\t\tfloat num10 = hitInfo.HitEntity.Distance2D(hitInfo.HitPositionWorld);\r\n\t\t\t\tif (num10 \u003E num9)\r\n\t\t\t\t{\r\n\t\t\t\t\tstring text = hitInfo.ProjectilePrefab.name;\r\n\t\t\t\t\tstring shortPrefabName = hitInfo.HitEntity.ShortPrefabName;\r\n\t\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Entity too far away (\u0022 \u002B text \u002B \u0022 on \u0022 \u002B shortPrefabName \u002B \u0022 with \u0022 \u002B num10 \u002B \u0022m \u003E \u0022 \u002B num9 \u002B \u0022m in \u0022 \u002B num7 \u002B \u0022s)\u0022);\r\n\t\t\t\t\tstats.combat.Log(hitInfo, \u0022projectile_distance\u0022);\r\n\t\t\t\t\tflag = false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (ConVar.AntiHack.projectile_protection \u003E= 1)\r\n\t\t\t{\r\n\t\t\t\tfloat num11 = value.itemMod.GetMaxVelocity();\r\n\t\t\t\tBaseProjectile baseProjectile = hitInfo.Weapon as BaseProjectile;\r\n\t\t\t\tif ((bool)baseProjectile)\r\n\t\t\t\t{\r\n\t\t\t\t\tnum11 *= baseProjectile.projectileVelocityScale;\r\n\t\t\t\t}\r\n\t\t\t\tfloat num12 = hitInfo.ProjectilePrefab.initialDistance \u002B num7 * num11;\r\n\t\t\t\tfloat num13 = UnityEngine.Vector3.Distance(value.origin, hitInfo.HitPositionWorld);\r\n\t\t\t\tif (num13 \u003E num12)\r\n\t\t\t\t{\r\n\t\t\t\t\tstring text2 = hitInfo.ProjectilePrefab.name;\r\n\t\t\t\t\tstring shortPrefabName2 = hitInfo.HitEntity.ShortPrefabName;\r\n\t\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Traveled too fast (\u0022 \u002B text2 \u002B \u0022 on \u0022 \u002B shortPrefabName2 \u002B \u0022 with \u0022 \u002B num13 \u002B \u0022m \u003E \u0022 \u002B num12 \u002B \u0022m in \u0022 \u002B num7 \u002B \u0022s)\u0022);\r\n\t\t\t\t\tstats.combat.Log(hitInfo, \u0022projectile_speed\u0022);\r\n\t\t\t\t\tflag = false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (ConVar.AntiHack.projectile_protection \u003E= 3)\r\n\t\t\t{\r\n\t\t\t\tUnityEngine.Vector3 pointStart = hitInfo.PointStart;\r\n\t\t\t\tUnityEngine.Vector3 vector = hitInfo.HitPositionWorld \u002B hitInfo.HitNormalWorld.normalized * 0.001f;\r\n\t\t\t\tUnityEngine.Vector3 position = value.position;\r\n\t\t\t\tUnityEngine.Vector3 vector2 = pointStart;\r\n\t\t\t\tUnityEngine.Vector3 vector3 = hitInfo.PositionOnRay(vector);\r\n\t\t\t\tUnityEngine.Vector3 vector4 = vector;\r\n\t\t\t\tbool flag2 = GamePhysics.LineOfSight(position, vector2, vector3, vector4, 2162688);\r\n\t\t\t\tif (!flag2)\r\n\t\t\t\t{\r\n\t\t\t\t\tstats.Add(\u0022hit_\u0022 \u002B hitInfo.HitEntity.Categorize() \u002B \u0022_indirect_los\u0022, 1, Stats.Server);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tstats.Add(\u0022hit_\u0022 \u002B hitInfo.HitEntity.Categorize() \u002B \u0022_direct_los\u0022, 1, Stats.Server);\r\n\t\t\t\t}\r\n\t\t\t\tif (!flag2)\r\n\t\t\t\t{\r\n\t\t\t\t\tstring text3 = hitInfo.ProjectilePrefab.name;\r\n\t\t\t\t\tstring shortPrefabName3 = hitInfo.HitEntity.ShortPrefabName;\r\n\t\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, string.Concat(\u0022Line of sight (\u0022, text3, \u0022 on \u0022, shortPrefabName3, \u0022) \u0022, position, \u0022 \u0022, vector2, \u0022 \u0022, vector3, \u0022 \u0022, vector4));\r\n\t\t\t\t\tstats.combat.Log(hitInfo, \u0022projectile_los\u0022);\r\n\t\t\t\t\tflag = false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!flag)\r\n\t\t\t{\r\n\t\t\t\tAntiHack.AddViolation(this, AntiHackType.ProjectileHack, ConVar.AntiHack.projectile_penalty);\r\n\t\t\t\tplayerProjectileAttack.ResetToPool();\r\n\t\t\t\tplayerProjectileAttack = null;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t\tvalue.position = hitInfo.HitPositionWorld \u002B hitInfo.ProjectileVelocity.normalized * 0.001f;\r\n\t\thitInfo.ProjectilePrefab.CalculateDamage(hitInfo, value.projectileModifier, value.integrity);\r\n\t\tif (hitInfo.ProjectilePrefab.penetrationPower \u003C= 0f || hitInfo.HitEntity == null)\r\n\t\t{\r\n\t\t\tvalue.integrity = 0f;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tfloat num14 = hitInfo.HitEntity.PenetrationResistance(hitInfo) / hitInfo.ProjectilePrefab.penetrationPower;\r\n\t\t\tvalue.integrity = Mathf.Clamp01(value.integrity - num14);\r\n\t\t}\r\n\t\tvalue.itemMod.ServerProjectileHit(hitInfo);\r\n\t\tif ((bool)hitInfo.HitEntity)\r\n\t\t{\r\n\t\t\tstats.Add(value.itemMod.category \u002B \u0022_hit_\u0022 \u002B hitInfo.HitEntity.Categorize(), 1);\r\n\t\t}\r\n\t\tif (value.integrity \u003C= 0f \u0026\u0026 hitInfo.ProjectilePrefab.remainInWorld)\r\n\t\t{\r\n\t\t\tCreateWorldProjectile(hitInfo, value.itemDef, value.itemMod, hitInfo.ProjectilePrefab, value.pickupItem);\r\n\t\t}\r\n\t\tfiredProjectiles[playerAttack.projectileID] = value;\r\n\t\tif (Interface.CallHook(\u0022OnPlayerAttack\u0022, this, hitInfo) == null)\r\n\t\t{\r\n\t\t\tif ((bool)hitInfo.HitEntity)\r\n\t\t\t{\r\n\t\t\t\thitInfo.HitEntity.OnAttacked(hitInfo);\r\n\t\t\t}\r\n\t\t\tEffect.server.ImpactEffect(hitInfo);\r\n\t\t\tplayerProjectileAttack.ResetToPool();\r\n\t\t\tplayerProjectileAttack = null;\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 154
  },
  {
    "HookSignature": "OnEntitySpawned(BaseNetworkable baseNetworkable)",
    "MethodSignature": "Spawn()",
    "MethodSourseCode": "\r\n\tpublic virtual void Spawn()\r\n\t{\r\n\t\tSpawnShared();\r\n\t\tif (net == null)\r\n\t\t{\r\n\t\t\tnet = Network.Net.sv.CreateNetworkable();\r\n\t\t}\r\n\t\tcreationFrame = UnityEngine.Time.frameCount;\r\n\t\tPreInitShared();\r\n\t\tInitShared();\r\n\t\tServerInit();\r\n\t\tPostInitShared();\r\n\t\tUpdateNetworkGroup();\r\n\t\tisSpawned = true;\r\n\t\tInterface.CallHook(\u0022OnEntitySpawned\u0022, this);\r\n\t\tSendNetworkUpdateImmediate(justCreated: true);\r\n\t}\r\n",
    "ClassName": "BaseNetworkable",
    "HookLineInvoke": 15
  },
  {
    "HookSignature": "CanUseLockedEntity(BasePlayer player, KeyLock keyLock)",
    "MethodSignature": "OnTryToOpen(BasePlayer player)",
    "MethodSourseCode": "\r\n\tpublic override bool OnTryToOpen(BasePlayer player)\r\n\t{\r\n\t\tobject obj = Interface.CallHook(\u0022CanUseLockedEntity\u0022, player, this);\r\n\t\tif (obj is bool)\r\n\t\t{\r\n\t\t\treturn (bool)obj;\r\n\t\t}\r\n\t\tif (HasLockPermission(player))\r\n\t\t{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn !IsLocked();\r\n\t}\r\n",
    "ClassName": "KeyLock",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnCupboardClearList(BuildingPrivlidge buildingPrivlidge, BasePlayer rpcPlayer)",
    "MethodSignature": "ClearList(RPCMessage rpc)",
    "MethodSourseCode": "\r\n\t[RPC_Server]\r\n\t[RPC_Server.IsVisible(3f)]\r\n\tprivate void ClearList(RPCMessage rpc)\r\n\t{\r\n\t\tif (rpc.player.CanInteract() \u0026\u0026 Interface.CallHook(\u0022OnCupboardClearList\u0022, this, rpc.player) == null \u0026\u0026 CanAdministrate(rpc.player))\r\n\t\t{\r\n\t\t\tauthorizedPlayers.Clear();\r\n\t\t\tUpdateAllPlayers();\r\n\t\t\tSendNetworkUpdate();\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "BuildingPrivlidge",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnPlayerDisconnected(BasePlayer basePlayer, string strReason)",
    "MethodSignature": "OnDisconnected(string strReason, Connection connection)",
    "MethodSourseCode": "\r\n\tprivate void OnDisconnected(string strReason, Connection connection)\r\n\t{\r\n\t\tconnectionQueue.RemoveConnection(connection);\r\n\t\tConnectionAuth.OnDisconnect(connection);\r\n\t\tRust.Global.SteamServer.Auth.EndSession(connection.userid);\r\n\t\tEACServer.OnLeaveGame(connection);\r\n\t\tBasePlayer basePlayer = connection.player as BasePlayer;\r\n\t\tif ((bool)basePlayer)\r\n\t\t{\r\n\t\t\tInterface.CallHook(\u0022OnPlayerDisconnected\u0022, basePlayer, strReason);\r\n\t\t\tbasePlayer.OnDisconnected();\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "ServerMgr",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "CanPickupLock(BasePlayer rpcPlayer, BaseLock baseLock)",
    "MethodSignature": "RPC_TakeLock(RPCMessage rpc)",
    "MethodSourseCode": "\r\n\t[RPC_Server]\r\n\t[RPC_Server.MaxDistance(3f)]\r\n\tpublic void RPC_TakeLock(RPCMessage rpc)\r\n\t{\r\n\t\tif (rpc.player.CanInteract() \u0026\u0026 !IsLocked() \u0026\u0026 Interface.CallHook(\u0022CanPickupLock\u0022, rpc.player, this) == null)\r\n\t\t{\r\n\t\t\tItem item = ItemManager.Create(itemType, 1, skinID);\r\n\t\t\tif (item != null)\r\n\t\t\t{\r\n\t\t\t\trpc.player.GiveItem(item);\r\n\t\t\t}\r\n\t\t\tKill();\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "BaseLock",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnTurretShutdown(AutoTurret autoTurret)",
    "MethodSignature": "InitiateShutdown()",
    "MethodSourseCode": "\r\n\tpublic void InitiateShutdown()\r\n\t{\r\n\t\tif (!IsOffline() \u0026\u0026 Interface.CallHook(\u0022OnTurretShutdown\u0022, this) == null)\r\n\t\t{\r\n\t\t\tEffect.server.Run(offlineSound.resourcePath, this, 0u, Vector3.zero, Vector3.zero);\r\n\t\t\tSetIsOnline(online: false);\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "AutoTurret",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnBradleyApcHunt(BradleyAPC bradleyAPC)",
    "MethodSignature": "UpdateMovement_Hunt()",
    "MethodSourseCode": "\r\n\tpublic void UpdateMovement_Hunt()\r\n\t{\r\n\t\tif (Interface.CallHook(\u0022OnBradleyApcHunt\u0022, this) != null || patrolPath == null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tTargetInfo targetInfo = targetList[0];\r\n\t\tif (!targetInfo.IsValid())\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (HasPath() \u0026\u0026 targetInfo.IsVisible())\r\n\t\t{\r\n\t\t\tif (currentPath.Count \u003E 1)\r\n\t\t\t{\r\n\t\t\t\tVector3 item = currentPath[currentPathIndex];\r\n\t\t\t\tClearPath();\r\n\t\t\t\tcurrentPath.Add(item);\r\n\t\t\t\tfinalDestination = item;\r\n\t\t\t\tcurrentPathIndex = 0;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tif (!(UnityEngine.Time.time \u003E nextEngagementPathTime) || HasPath() || targetInfo.IsVisible())\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tbool flag = false;\r\n\t\t\tBasePathNode start = patrolPath.GetClosestToPoint(base.transform.position);\r\n\t\t\tList\u003CBasePathNode\u003E nodes = Facepunch.Pool.GetList\u003CBasePathNode\u003E();\r\n\t\t\tif (GetEngagementPath(ref nodes))\r\n\t\t\t{\r\n\t\t\t\tflag = true;\r\n\t\t\t\tstart = nodes[nodes.Count - 1];\r\n\t\t\t}\r\n\t\t\tBasePathNode basePathNode = null;\r\n\t\t\tList\u003CBasePathNode\u003E nearNodes = Facepunch.Pool.GetList\u003CBasePathNode\u003E();\r\n\t\t\tpatrolPath.GetNodesNear(targetInfo.lastSeenPosition, ref nearNodes, 30f);\r\n\t\t\tStack\u003CBasePathNode\u003E stack = null;\r\n\t\t\tfloat num = float.PositiveInfinity;\r\n\t\t\tfloat y = mainTurretEyePos.localPosition.y;\r\n\t\t\tforeach (BasePathNode item2 in nearNodes)\r\n\t\t\t{\r\n\t\t\t\tStack\u003CBasePathNode\u003E path = new Stack\u003CBasePathNode\u003E();\r\n\t\t\t\tif (targetInfo.entity.IsVisible(item2.transform.position \u002B new Vector3(0f, y, 0f)) \u0026\u0026 AStarPath.FindPath(start, item2, out path, out var pathCost) \u0026\u0026 pathCost \u003C num)\r\n\t\t\t\t{\r\n\t\t\t\t\tstack = path;\r\n\t\t\t\t\tnum = pathCost;\r\n\t\t\t\t\tbasePathNode = item2;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (stack != null)\r\n\t\t\t{\r\n\t\t\t\tcurrentPath.Clear();\r\n\t\t\t\tif (flag)\r\n\t\t\t\t{\r\n\t\t\t\t\tfor (int i = 0; i \u003C nodes.Count - 1; i\u002B\u002B)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcurrentPath.Add(nodes[i].transform.position);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tforeach (BasePathNode item3 in stack)\r\n\t\t\t\t{\r\n\t\t\t\t\tcurrentPath.Add(item3.transform.position);\r\n\t\t\t\t}\r\n\t\t\t\tcurrentPathIndex = -1;\r\n\t\t\t\tpathLooping = false;\r\n\t\t\t\tfinalDestination = basePathNode.transform.position;\r\n\t\t\t}\r\n\t\t\tFacepunch.Pool.FreeList(ref nearNodes);\r\n\t\t\tFacepunch.Pool.FreeList(ref nodes);\r\n\t\t\tnextEngagementPathTime = UnityEngine.Time.time \u002B 5f;\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "BradleyAPC",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnQuarryEnabled(MiningQuarry miningQuarry)",
    "MethodSignature": "SetOn(bool isOn)",
    "MethodSourseCode": "\r\n\tprivate void SetOn(bool isOn)\r\n\t{\r\n\t\tSetFlag(Flags.On, isOn);\r\n\t\tengineSwitchPrefab.instance.SetFlag(Flags.On, isOn);\r\n\t\tSendNetworkUpdate();\r\n\t\tengineSwitchPrefab.instance.SendNetworkUpdate();\r\n\t\tif (isOn)\r\n\t\t{\r\n\t\t\tInvokeRepeating(ProcessResources, processRate, processRate);\r\n\t\t\tInterface.CallHook(\u0022OnQuarryEnabled\u0022, this);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tCancelInvoke(ProcessResources);\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "MiningQuarry",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnOpenVendingAdmin(VendingMachine vendingMachine, BasePlayer player)",
    "MethodSignature": "RPC_OpenAdmin(RPCMessage msg)",
    "MethodSourseCode": "\r\n\t[RPC_Server.IsVisible(3f)]\r\n\t[RPC_Server]\r\n\tpublic void RPC_OpenAdmin(RPCMessage msg)\r\n\t{\r\n\t\tBasePlayer player = msg.player;\r\n\t\tif (CanPlayerAdmin(player))\r\n\t\t{\r\n\t\t\tSendSellOrders(player);\r\n\t\t\tPlayerOpenLoot(player);\r\n\t\t\tClientRPCPlayer(null, player, \u0022CLIENT_OpenAdminMenu\u0022);\r\n\t\t\tInterface.CallHook(\u0022OnOpenVendingAdmin\u0022, this, player);\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnPlayerLanded(BasePlayer basePlayer, float num2)",
    "MethodSignature": "OnPlayerLanded(RPCMessage msg)",
    "MethodSourseCode": "\r\n\t[RPC_Server.FromOwner]\r\n\t[RPC_Server]\r\n\tprivate void OnPlayerLanded(RPCMessage msg)\r\n\t{\r\n\t\tfloat num = msg.read.Float();\r\n\t\tif (float.IsNaN(num) || float.IsInfinity(num))\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tfloat num2 = Mathf.InverseLerp(-15f, -100f, num);\r\n\t\tif (num2 != 0f \u0026\u0026 Interface.CallHook(\u0022OnPlayerLand\u0022, this, num2) == null)\r\n\t\t{\r\n\t\t\tmetabolism.bleeding.Add(num2 * 0.5f);\r\n\t\t\tfloat num3 = num2 * 500f;\r\n\t\t\tHurt(num3, DamageType.Fall);\r\n\t\t\tif (num3 \u003E 20f \u0026\u0026 fallDamageEffect.isValid)\r\n\t\t\t{\r\n\t\t\t\tEffect.server.Run(fallDamageEffect.resourcePath, base.transform.position, UnityEngine.Vector3.zero);\r\n\t\t\t}\r\n\t\t\tInterface.CallHook(\u0022OnPlayerLanded\u0022, this, num2);\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 20
  },
  {
    "HookSignature": "OnSignLocked(Signage signage, BasePlayer msgPlayer)",
    "MethodSignature": "LockSign(RPCMessage msg)",
    "MethodSourseCode": "\r\n\t[RPC_Server.MaxDistance(3f)]\r\n\t[RPC_Server]\r\n\tpublic void LockSign(RPCMessage msg)\r\n\t{\r\n\t\tif (msg.player.CanInteract() \u0026\u0026 CanUpdateSign(msg.player))\r\n\t\t{\r\n\t\t\tSetFlag(Flags.Locked, b: true);\r\n\t\t\tSendNetworkUpdate();\r\n\t\t\tbase.OwnerID = msg.player.userID;\r\n\t\t\tInterface.CallHook(\u0022OnSignLocked\u0022, this, msg.player);\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "Signage",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnRefreshVendingStock(VendingMachine vendingMachine, ItemDefinition itemDef)",
    "MethodSignature": "RefreshSellOrderStockLevel(ItemDefinition itemDef)",
    "MethodSourseCode": "\r\n\tpublic void RefreshSellOrderStockLevel(ItemDefinition itemDef = null)\r\n\t{\r\n\t\tforeach (ProtoBuf.VendingMachine.SellOrder sellOrder in sellOrders.sellOrders)\r\n\t\t{\r\n\t\t\tif (!(itemDef == null) \u0026\u0026 itemDef.itemid != sellOrder.itemToSellID)\r\n\t\t\t{\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tList\u003CItem\u003E list = inventory.FindItemsByItemID(sellOrder.itemToSellID);\r\n\t\t\tint inStock;\r\n\t\t\tif (list != null \u0026\u0026 list.Count \u003E= 0)\r\n\t\t\t{\r\n\t\t\t\tInterface.CallHook(\u0022OnRefreshVendingStock\u0022, this, itemDef);\r\n\t\t\t\tinStock = list.Sum((Item x) =\u003E x.amount) / sellOrder.itemToSellAmount;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tinStock = 0;\r\n\t\t\t}\r\n\t\t\tsellOrder.inStock = inStock;\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "IOnEnableServerConsole(ServerConsole serverConsole)",
    "MethodSignature": "OnEnable()",
    "MethodSourseCode": "\r\n\tpublic void OnEnable()\r\n\t{\r\n\t\tif (!Facepunch.CommandLine.HasSwitch(\u0022-keeplogs\u0022))\r\n\t\t{\r\n\t\t\tConVar.Server.LogCreate(\u0022Log.Warning.txt\u0022);\r\n\t\t\tConVar.Server.LogCreate(\u0022Log.Error.txt\u0022);\r\n\t\t\tConVar.Server.LogCreate(\u0022Log.Exception.txt\u0022);\r\n\t\t\tConVar.Server.LogCreate(\u0022Log.Log.txt\u0022);\r\n\t\t\tConVar.Server.LogCreate(\u0022Log.Chat.txt\u0022);\r\n\t\t\tConVar.Server.LogCreate(\u0022Log.EAC.txt\u0022);\r\n\t\t\tConVar.Server.LogCreate(\u0022Log.Assert.txt\u0022);\r\n\t\t}\r\n\t\tif (Interface.CallHook(\u0022IOnEnableServerConsole\u0022, this) == null)\r\n\t\t{\r\n\t\t\tconsole.Initialize();\r\n\t\t\tinput.OnInputText \u002B= OnInputText;\r\n\t\t\tOutput.OnMessage \u002B= HandleLog;\r\n\t\t\tinput.ClearLine(System.Console.WindowHeight);\r\n\t\t\tfor (int i = 0; i \u003C System.Console.WindowHeight; i\u002B\u002B)\r\n\t\t\t{\r\n\t\t\t\tSystem.Console.WriteLine(string.Empty);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "ServerConsole",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "OnServerMessage(string message, string username, string color, ulong userid)",
    "MethodSignature": "Broadcast(string message, string username, string color, ulong userid)",
    "MethodSourseCode": "\r\n\tpublic static void Broadcast(string message, string username = \u0022SERVER\u0022, string color = \u0022#eee\u0022, ulong userid = 0uL)\r\n\t{\r\n\t\tif (Interface.CallHook(\u0022OnServerMessage\u0022, message, username, color, userid) == null)\r\n\t\t{\r\n\t\t\tConsoleNetwork.BroadcastToAllClients(\u0022chat.add\u0022, 0, \u0022\u003Ccolor=\u0022 \u002B color \u002B \u0022\u003E\u0022 \u002B username \u002B \u0022\u003C/color\u003E \u0022 \u002B message);\r\n\t\t\tChatEntry chatEntry = default(ChatEntry);\r\n\t\t\tchatEntry.Message = message;\r\n\t\t\tchatEntry.UserId = userid;\r\n\t\t\tchatEntry.Username = username;\r\n\t\t\tchatEntry.Color = color;\r\n\t\t\tchatEntry.Time = Epoch.Current;\r\n\t\t\tChatEntry chatEntry2 = chatEntry;\r\n\t\t\tHistory.Add(chatEntry2);\r\n\t\t\tRCon.Broadcast(RCon.LogType.Chat, chatEntry2);\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "Chat",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "IOnStructureImmediateDemolish(BuildingBlock buildingBlock, BasePlayer msgPlayer)",
    "MethodSignature": "DoImmediateDemolish(RPCMessage msg)",
    "MethodSourseCode": "\r\n\t[RPC_Server.MaxDistance(3f)]\r\n\t[RPC_Server]\r\n\tprivate void DoImmediateDemolish(RPCMessage msg)\r\n\t{\r\n\t\tif (msg.player.CanInteract() \u0026\u0026 msg.player.IsAdmin \u0026\u0026 Interface.CallHook(\u0022IOnStructureImmediateDemolish\u0022, this, msg.player) == null)\r\n\t\t{\r\n\t\t\tKill(DestroyMode.Gib);\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "BuildingBlock",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnShopCompleteTrade(ShopFront shopFront)",
    "MethodSignature": "CompleteTrade()",
    "MethodSourseCode": "\r\n\tpublic void CompleteTrade()\r\n\t{\r\n\t\tif (vendorPlayer != null \u0026\u0026 customerPlayer != null \u0026\u0026 HasFlag(Flags.Reserved1) \u0026\u0026 HasFlag(Flags.Reserved2))\r\n\t\t{\r\n\t\t\tif (Interface.CallHook(\u0022OnShopCompleteTrade\u0022, this) != null)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tfor (int num = vendorInventory.capacity - 1; num \u003E= 0; num--)\r\n\t\t\t{\r\n\t\t\t\tItem slot = vendorInventory.GetSlot(num);\r\n\t\t\t\tItem slot2 = customerInventory.GetSlot(num);\r\n\t\t\t\tif ((bool)customerPlayer \u0026\u0026 slot != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tcustomerPlayer.GiveItem(slot);\r\n\t\t\t\t}\r\n\t\t\t\tif ((bool)vendorPlayer \u0026\u0026 slot2 != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tvendorPlayer.GiveItem(slot2);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tEffect.server.Run(transactionCompleteEffect.resourcePath, this, 0u, new Vector3(0f, 1f, 0f), Vector3.zero);\r\n\t\t}\r\n\t\tResetTrade();\r\n\t\tSendNetworkUpdate();\r\n\t}\r\n",
    "ClassName": "ShopFront",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnPlayerLand(BasePlayer basePlayer, float num2)",
    "MethodSignature": "OnPlayerLanded(RPCMessage msg)",
    "MethodSourseCode": "\r\n\t[RPC_Server.FromOwner]\r\n\t[RPC_Server]\r\n\tprivate void OnPlayerLanded(RPCMessage msg)\r\n\t{\r\n\t\tfloat num = msg.read.Float();\r\n\t\tif (float.IsNaN(num) || float.IsInfinity(num))\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tfloat num2 = Mathf.InverseLerp(-15f, -100f, num);\r\n\t\tif (num2 != 0f \u0026\u0026 Interface.CallHook(\u0022OnPlayerLand\u0022, this, num2) == null)\r\n\t\t{\r\n\t\t\tmetabolism.bleeding.Add(num2 * 0.5f);\r\n\t\t\tfloat num3 = num2 * 500f;\r\n\t\t\tHurt(num3, DamageType.Fall);\r\n\t\t\tif (num3 \u003E 20f \u0026\u0026 fallDamageEffect.isValid)\r\n\t\t\t{\r\n\t\t\t\tEffect.server.Run(fallDamageEffect.resourcePath, base.transform.position, UnityEngine.Vector3.zero);\r\n\t\t\t}\r\n\t\t\tInterface.CallHook(\u0022OnPlayerLanded\u0022, this, num2);\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnTrapTrigger(BearTrap bearTrap, UnityEngine.GameObject obj)",
    "MethodSignature": "ObjectEntered(GameObject obj)",
    "MethodSourseCode": "\r\n\tpublic override void ObjectEntered(GameObject obj)\r\n\t{\r\n\t\tif (Armed() \u0026\u0026 Interface.CallHook(\u0022OnTrapTrigger\u0022, this, obj) == null)\r\n\t\t{\r\n\t\t\thurtTarget = obj;\r\n\t\t\tInvoke(DelayedFire, 0.05f);\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "BearTrap",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanStackItem(Item item, Item item)",
    "MethodSignature": "CanStack(Item item)",
    "MethodSourseCode": "\r\n\tpublic bool CanStack(Item item)\r\n\t{\r\n\t\tobject obj = Interface.CallHook(\u0022CanStackItem\u0022, this, item);\r\n\t\tif (obj is bool)\r\n\t\t{\r\n\t\t\treturn (bool)obj;\r\n\t\t}\r\n\t\tif (item == this)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (info.stackable \u003C= 1)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (item.info.stackable \u003C= 1)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (item.info.itemid != info.itemid)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (hasCondition || item.hasCondition)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (!IsValid())\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (IsBlueprint() \u0026\u0026 blueprintTarget != item.blueprintTarget)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n",
    "ClassName": "Item",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnOpenVendingShop(VendingMachine vendingMachine, BasePlayer msgPlayer)",
    "MethodSignature": "RPC_OpenShop(RPCMessage msg)",
    "MethodSourseCode": "\r\n\t[RPC_Server]\r\n\t[RPC_Server.IsVisible(3f)]\r\n\tpublic void RPC_OpenShop(RPCMessage msg)\r\n\t{\r\n\t\tSendSellOrders(msg.player);\r\n\t\tPlayerOpenLoot(msg.player, customerPanel);\r\n\t\tInterface.CallHook(\u0022OnOpenVendingShop\u0022, this, msg.player);\r\n\t}\r\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "InitLogging()",
    "MethodSignature": "StartupShared()",
    "MethodSourseCode": "\r\n\tprivate void StartupShared()\r\n\t{\r\n\t\tInterface.CallHook(\u0022InitLogging\u0022, null);\r\n\t\tItemManager.Initialize();\r\n\t}\r\n",
    "ClassName": "Bootstrap",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnDoorClosed(Door door, BasePlayer rpcPlayer)",
    "MethodSignature": "RPC_CloseDoor(RPCMessage rpc)",
    "MethodSourseCode": "\r\n\t[RPC_Server.MaxDistance(3f)]\r\n\t[RPC_Server]\r\n\tprivate void RPC_CloseDoor(RPCMessage rpc)\r\n\t{\r\n\t\tif (rpc.player.CanInteract() \u0026\u0026 IsOpen() \u0026\u0026 !IsBusy() \u0026\u0026 !IsLocked())\r\n\t\t{\r\n\t\t\tBaseLock baseLock = GetSlot(Slot.Lock) as BaseLock;\r\n\t\t\tif (!(baseLock != null) || baseLock.OnTryToClose(rpc.player))\r\n\t\t\t{\r\n\t\t\t\tSetFlag(Flags.Open, b: false);\r\n\t\t\t\tSendNetworkUpdateImmediate();\r\n\t\t\t\tInterface.CallHook(\u0022OnDoorClosed\u0022, this, rpc.player);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "Door",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "OnRocketLaunched(BasePlayer msgPlayer, BaseEntity baseEntity)",
    "MethodSignature": "SV_Launch(RPCMessage msg)",
    "MethodSourseCode": "\r\n\t[RPC_Server]\r\n\t[RPC_Server.IsActiveItem]\r\n\tprivate void SV_Launch(RPCMessage msg)\r\n\t{\r\n\t\tBasePlayer player = msg.player;\r\n\t\tif (!VerifyClientAttack(player))\r\n\t\t{\r\n\t\t\tSendNetworkUpdate();\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (reloadFinished \u0026\u0026 HasReloadCooldown())\r\n\t\t{\r\n\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Reloading (\u0022 \u002B base.ShortPrefabName \u002B \u0022)\u0022);\r\n\t\t\tplayer.stats.combat.Log(this, \u0022reload_cooldown\u0022);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\treloadStarted = false;\r\n\t\treloadFinished = false;\r\n\t\tif (primaryMagazine.contents \u003C= 0)\r\n\t\t{\r\n\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Magazine empty (\u0022 \u002B base.ShortPrefabName \u002B \u0022)\u0022);\r\n\t\t\tplayer.stats.combat.Log(this, \u0022magazine_empty\u0022);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tprimaryMagazine.contents--;\r\n\t\tVector3 vector = msg.read.Vector3();\r\n\t\tVector3 vector2 = msg.read.Vector3().normalized;\r\n\t\tif (!ValidateEyePos(player, vector))\r\n\t\t{\r\n\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Eye position (\u0022 \u002B base.ShortPrefabName \u002B \u0022)\u0022);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tItemModProjectile component = primaryMagazine.ammoType.GetComponent\u003CItemModProjectile\u003E();\r\n\t\tif (!component)\r\n\t\t{\r\n\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Item mod not found (\u0022 \u002B base.ShortPrefabName \u002B \u0022)\u0022);\r\n\t\t\tplayer.stats.combat.Log(this, \u0022mod_missing\u0022);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tfloat num = GetAimCone() \u002B component.projectileSpread;\r\n\t\tif (num \u003E 0f)\r\n\t\t{\r\n\t\t\tvector2 = AimConeUtil.GetModifiedAimConeDirection(num, vector2);\r\n\t\t}\r\n\t\tfloat num2 = 1f;\r\n\t\tif (UnityEngine.Physics.Raycast(vector, vector2, out var hitInfo, num2, 1101212417))\r\n\t\t{\r\n\t\t\tnum2 = hitInfo.distance - 0.1f;\r\n\t\t}\r\n\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(component.projectileObject.resourcePath, vector \u002B vector2 * num2);\r\n\t\tif (!(baseEntity == null))\r\n\t\t{\r\n\t\t\tbaseEntity.creatorEntity = player;\r\n\t\t\tbaseEntity.SendMessage(\u0022InitializeVelocity\u0022, vector2 * 1f);\r\n\t\t\tbaseEntity.Spawn();\r\n\t\t\tInterface.CallHook(\u0022OnRocketLaunched\u0022, msg.player, baseEntity);\r\n\t\t\tStartAttackCooldown(ScaleRepeatDelay(repeatDelay));\r\n\t\t\tGetOwnerItem()?.LoseCondition(UnityEngine.Random.Range(1f, 2f));\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "BaseLauncher",
    "HookLineInvoke": 56
  },
  {
    "HookSignature": "OnPlayerSpawn(BasePlayer basePlayer)",
    "MethodSignature": "SpawnNewPlayer(Connection connection)",
    "MethodSourseCode": "\r\n\tprivate void SpawnNewPlayer(Connection connection)\r\n\t{\r\n\t\tBasePlayer.SpawnPoint spawnPoint = FindSpawnPoint();\r\n\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(\u0022assets/prefabs/player/player.prefab\u0022, spawnPoint.pos, spawnPoint.rot);\r\n\t\tBasePlayer basePlayer = baseEntity.ToPlayer();\r\n\t\tif (Interface.CallHook(\u0022OnPlayerSpawn\u0022, basePlayer) == null)\r\n\t\t{\r\n\t\t\tbasePlayer.health = 0f;\r\n\t\t\tbasePlayer.lifestate = BaseCombatEntity.LifeState.Dead;\r\n\t\t\tbasePlayer.ResetLifeStateOnSpawn = false;\r\n\t\t\tbasePlayer.limitNetworking = true;\r\n\t\t\tbasePlayer.Spawn();\r\n\t\t\tbasePlayer.limitNetworking = false;\r\n\t\t\tbasePlayer.PlayerInit(connection);\r\n\t\t\tif (SleepingBag.FindForPlayer(basePlayer.userID, ignoreTimers: true).Length == 0 \u0026\u0026 !basePlayer.hasPreviousLife)\r\n\t\t\t{\r\n\t\t\t\tbasePlayer.Respawn();\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tbasePlayer.SendRespawnOptions();\r\n\t\t\t}\r\n\t\t\tUnityEngine.Debug.Log(basePlayer.net.connection.ToString() \u002B \u0022 joined [\u0022 \u002B basePlayer.net.connection.os \u002B \u0022/\u0022 \u002B basePlayer.net.connection.ownerid \u002B \u0022]\u0022);\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "ServerMgr",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "IOnUserApprove(Network.Connection connection)",
    "MethodSignature": "OnNewConnection(Connection connection)",
    "MethodSourseCode": "\r\n\tpublic void OnNewConnection(Connection connection)\r\n\t{\r\n\t\tconnection.connected = false;\r\n\t\tif (connection.token == null || connection.token.Length \u003C 32)\r\n\t\t{\r\n\t\t\tReject(connection, \u0022Invalid Token\u0022);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (connection.userid == 0)\r\n\t\t{\r\n\t\t\tReject(connection, \u0022Invalid SteamID\u0022);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (connection.protocol != 2013)\r\n\t\t{\r\n\t\t\tif (!DeveloperList.Contains(connection.userid))\r\n\t\t\t{\r\n\t\t\t\tReject(connection, \u0022Incompatible Version\u0022);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tDebug.Log(\u0022Not kicking \u0022 \u002B connection.userid \u002B \u0022 for incompatible protocol (is a developer)\u0022);\r\n\t\t}\r\n\t\tif (ServerUsers.Is(connection.userid, ServerUsers.UserGroup.Banned))\r\n\t\t{\r\n\t\t\tReject(connection, \u0022You are banned from this server\u0022);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (ServerUsers.Is(connection.userid, ServerUsers.UserGroup.Moderator))\r\n\t\t{\r\n\t\t\tDebug.Log(connection.ToString() \u002B \u0022 has auth level 1\u0022);\r\n\t\t\tconnection.authLevel = 1;\r\n\t\t}\r\n\t\tif (ServerUsers.Is(connection.userid, ServerUsers.UserGroup.Owner))\r\n\t\t{\r\n\t\t\tDebug.Log(connection.ToString() \u002B \u0022 has auth level 2\u0022);\r\n\t\t\tconnection.authLevel = 2;\r\n\t\t}\r\n\t\tif (DeveloperList.Contains(connection.userid))\r\n\t\t{\r\n\t\t\tDebug.Log(connection.ToString() \u002B \u0022 is a developer\u0022);\r\n\t\t\tconnection.authLevel = 1;\r\n\t\t}\r\n\t\tif (IsConnected(connection.userid))\r\n\t\t{\r\n\t\t\tReject(connection, \u0022You are already connected!\u0022);\r\n\t\t}\r\n\t\telse if (Interface.CallHook(\u0022IOnUserApprove\u0022, connection) == null)\r\n\t\t{\r\n\t\t\tm_AuthConnection.Add(connection);\r\n\t\t\tStartCoroutine(AuthorisationRoutine(connection));\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "ConnectionAuth",
    "HookLineInvoke": 47
  },
  {
    "HookSignature": "CanLootPlayer(BasePlayer basePlayer, BasePlayer player)",
    "MethodSignature": "CanBeLooted(BasePlayer player)",
    "MethodSourseCode": "\r\n\tpublic override bool CanBeLooted(BasePlayer player)\r\n\t{\r\n\t\tobject obj = Interface.CallHook(\u0022CanLootPlayer\u0022, this, player);\r\n\t\tif (obj is bool)\r\n\t\t{\r\n\t\t\treturn (bool)obj;\r\n\t\t}\r\n\t\tif (player == this)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\treturn IsWounded() || IsSleeping();\r\n\t}\r\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPlayerLootEnd(PlayerLoot playerLoot)",
    "MethodSignature": "Clear()",
    "MethodSourseCode": "\r\n\tpublic void Clear()\r\n\t{\r\n\t\tif (!IsLooting())\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tInterface.CallHook(\u0022OnPlayerLootEnd\u0022, this);\r\n\t\tMarkDirty();\r\n\t\tif ((bool)entitySource)\r\n\t\t{\r\n\t\t\tentitySource.SendMessage(\u0022PlayerStoppedLooting\u0022, base.baseEntity, SendMessageOptions.DontRequireReceiver);\r\n\t\t}\r\n\t\tforeach (ItemContainer container in containers)\r\n\t\t{\r\n\t\t\tif (container != null)\r\n\t\t\t{\r\n\t\t\t\tcontainer.onDirty -= MarkDirty;\r\n\t\t\t}\r\n\t\t}\r\n\t\tcontainers.Clear();\r\n\t\tentitySource = null;\r\n\t\titemSource = null;\r\n\t}\r\n",
    "ClassName": "PlayerLoot",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnItemSplit(Item item, int split_Amount)",
    "MethodSignature": "SplitItem(int split_Amount)",
    "MethodSourseCode": "\r\n\tpublic Item SplitItem(int split_Amount)\r\n\t{\r\n\t\tAssert.IsTrue(split_Amount \u003E 0, \u0022split_Amount \u003C= 0\u0022);\r\n\t\tif (split_Amount \u003C= 0)\r\n\t\t{\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tif (split_Amount \u003E= amount)\r\n\t\t{\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tobject obj = Interface.CallHook(\u0022OnItemSplit\u0022, this, split_Amount);\r\n\t\tif (obj is Item)\r\n\t\t{\r\n\t\t\treturn (Item)obj;\r\n\t\t}\r\n\t\tamount -= split_Amount;\r\n\t\tItem item = ItemManager.CreateByItemID(info.itemid, 1, 0uL);\r\n\t\titem.amount = split_Amount;\r\n\t\tif (IsBlueprint())\r\n\t\t{\r\n\t\t\titem.blueprintTarget = blueprintTarget;\r\n\t\t}\r\n\t\tMarkDirty();\r\n\t\treturn item;\r\n\t}\r\n",
    "ClassName": "Item",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "CanWearItem(PlayerInventory playerInventory, Item item)",
    "MethodSignature": "CanWearItem(Item item)",
    "MethodSourseCode": "\r\n\tprivate bool CanWearItem(Item item)\r\n\t{\r\n\t\tItemModWearable component = item.info.GetComponent\u003CItemModWearable\u003E();\r\n\t\tif (component == null)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tobject obj = Interface.CallHook(\u0022CanWearItem\u0022, this, item);\r\n\t\tif (obj is bool)\r\n\t\t{\r\n\t\t\treturn (bool)obj;\r\n\t\t}\r\n\t\tItem[] array = containerWear.itemList.ToArray();\r\n\t\tforeach (Item item2 in array)\r\n\t\t{\r\n\t\t\tif (item2 != item)\r\n\t\t\t{\r\n\t\t\t\tItemModWearable component2 = item2.info.GetComponent\u003CItemModWearable\u003E();\r\n\t\t\t\tif (!(component2 == null) \u0026\u0026 !component.CanExistWith(component2) \u0026\u0026 !item2.MoveToContainer(containerMain))\r\n\t\t\t\t{\r\n\t\t\t\t\titem2.Drop(base.baseEntity.eyes.position, base.baseEntity.eyes.BodyForward() * 2f);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n",
    "ClassName": "PlayerInventory",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "IOnDisableServerConsole()",
    "MethodSignature": "OnDisable()",
    "MethodSourseCode": "\r\n\tprivate void OnDisable()\r\n\t{\r\n\t\tif (Interface.CallHook(\u0022IOnDisableServerConsole\u0022, null) == null)\r\n\t\t{\r\n\t\t\tOutput.OnMessage -= HandleLog;\r\n\t\t\tinput.OnInputText -= OnInputText;\r\n\t\t\tconsole.Shutdown();\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "ServerConsole",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanAffordUpgrade(BasePlayer player, BuildingBlock buildingBlock, BuildingGrade.Enum iGrade)",
    "MethodSignature": "CanAffordUpgrade(BuildingGrade.Enum iGrade, BasePlayer player)",
    "MethodSourseCode": "\r\n\tprivate bool CanAffordUpgrade(BuildingGrade.Enum iGrade, BasePlayer player)\r\n\t{\r\n\t\tobject obj = Interface.CallHook(\u0022CanAffordUpgrade\u0022, player, this, iGrade);\r\n\t\tif (obj is bool)\r\n\t\t{\r\n\t\t\treturn (bool)obj;\r\n\t\t}\r\n\t\tConstructionGrade constructionGrade = GetGrade(iGrade);\r\n\t\tforeach (ItemAmount item in constructionGrade.costToBuild)\r\n\t\t{\r\n\t\t\tif ((float)player.inventory.GetAmount(item.itemid) \u003C item.amount)\r\n\t\t\t{\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n",
    "ClassName": "BuildingBlock",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnItemRepair(BasePlayer player, Item slot)",
    "MethodSignature": "RepairItem(RPCMessage msg)",
    "MethodSourseCode": "\r\n\t[RPC_Server]\r\n\tpublic void RepairItem(RPCMessage msg)\r\n\t{\r\n\t\tItem slot = inventory.GetSlot(0);\r\n\t\tif (slot == null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tItemDefinition info = slot.info;\r\n\t\tItemBlueprint component = info.GetComponent\u003CItemBlueprint\u003E();\r\n\t\tif (!component || !info.condition.repairable || slot.condition == slot.maxCondition)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tBasePlayer player = msg.player;\r\n\t\tif (Interface.CallHook(\u0022OnItemRepair\u0022, player, slot) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tfloat num = RepairCostFraction(slot);\r\n\t\tbool flag = false;\r\n\t\tList\u003CItemAmount\u003E obj = GetRepairCostList(component);\r\n\t\tforeach (ItemAmount item in obj)\r\n\t\t{\r\n\t\t\tif (item.itemDef.category != ItemCategory.Component)\r\n\t\t\t{\r\n\t\t\t\tint amount = player.inventory.GetAmount(item.itemDef.itemid);\r\n\t\t\t\tint num2 = Mathf.CeilToInt(item.amount * num);\r\n\t\t\t\tif (num2 \u003E amount)\r\n\t\t\t\t{\r\n\t\t\t\t\tflag = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (flag)\r\n\t\t{\r\n\t\t\tFacepunch.Pool.Free(ref obj);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tforeach (ItemAmount item2 in obj)\r\n\t\t{\r\n\t\t\tif (item2.itemDef.category != ItemCategory.Component)\r\n\t\t\t{\r\n\t\t\t\tint amount2 = Mathf.CeilToInt(item2.amount * num);\r\n\t\t\t\tplayer.inventory.Take(null, item2.itemid, amount2);\r\n\t\t\t}\r\n\t\t}\r\n\t\tFacepunch.Pool.Free(ref obj);\r\n\t\tslot.DoRepair(maxConditionLostOnRepair);\r\n\t\tif (ConVar.Global.developer \u003E 0)\r\n\t\t{\r\n\t\t\tDebug.Log(\u0022Item repaired! condition : \u0022 \u002B slot.condition \u002B \u0022/\u0022 \u002B slot.maxCondition);\r\n\t\t}\r\n\t\tEffect.server.Run(\u0022assets/bundled/prefabs/fx/repairbench/itemrepair.prefab\u0022, this, 0u, Vector3.zero, Vector3.zero);\r\n\t}\r\n",
    "ClassName": "RepairBench",
    "HookLineInvoke": 16
  },
  {
    "HookSignature": "OnCreateWorldProjectile(HitInfo info, Item item)",
    "MethodSignature": "CreateWorldProjectile(HitInfo info, ItemDefinition itemDef, ItemModProjectile itemMod, Projectile projectilePrefab, Item recycleItem)",
    "MethodSourseCode": "\r\n\tprotected virtual void CreateWorldProjectile(HitInfo info, ItemDefinition itemDef, ItemModProjectile itemMod, Projectile projectilePrefab, Item recycleItem)\r\n\t{\r\n\t\tUnityEngine.Vector3 projectileVelocity = info.ProjectileVelocity;\r\n\t\tItem item = ((recycleItem == null) ? ItemManager.Create(itemDef, 1, 0uL) : recycleItem);\r\n\t\tBaseEntity baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));\r\n\t\tRigidbody component = baseEntity.GetComponent\u003CRigidbody\u003E();\r\n\t\tif (Interface.CallHook(\u0022OnCreateWorldProjectile\u0022, info, item) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (!info.DidHit)\r\n\t\t{\r\n\t\t\tbaseEntity.Kill(DestroyMode.Gib);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (projectilePrefab.breakProbability \u003E 0f \u0026\u0026 UnityEngine.Random.value \u003C= projectilePrefab.breakProbability)\r\n\t\t{\r\n\t\t\tbaseEntity.Kill(DestroyMode.Gib);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (projectilePrefab.conditionLoss \u003E 0f)\r\n\t\t{\r\n\t\t\titem.LoseCondition(projectilePrefab.conditionLoss * 100f);\r\n\t\t\tif (item.isBroken)\r\n\t\t\t{\r\n\t\t\t\tbaseEntity.Kill(DestroyMode.Gib);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (projectilePrefab.stickProbability \u003E 0f \u0026\u0026 UnityEngine.Random.value \u003C= projectilePrefab.stickProbability)\r\n\t\t{\r\n\t\t\tif (info.HitEntity == null)\r\n\t\t\t{\r\n\t\t\t\tcomponent.isKinematic = true;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tQuaternion rotation = ((info.HitBone != 0) ? Quaternion.LookRotation(info.HitNormalLocal * -1f) : Quaternion.LookRotation(info.HitEntity.transform.InverseTransformDirection(projectileVelocity.normalized)));\r\n\t\t\tcomponent.isKinematic = true;\r\n\t\t\tbaseEntity.SetParent(info.HitEntity, info.HitBone);\r\n\t\t\tbaseEntity.transform.position = info.HitPositionLocal;\r\n\t\t\tbaseEntity.transform.rotation = rotation;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tcomponent.AddForce(projectileVelocity.normalized * 200f);\r\n\t\t\tcomponent.WakeUp();\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnItemCraftFinished(ItemCraftTask task, Item item)",
    "MethodSignature": "FinishCrafting(ItemCraftTask task)",
    "MethodSourseCode": "\r\n\tprivate void FinishCrafting(ItemCraftTask task)\r\n\t{\r\n\t\ttask.amount--;\r\n\t\ttask.numCrafted\u002B\u002B;\r\n\t\tulong num = 0uL;\r\n\t\tFacepunch.Steamworks.Inventory.Definition definition = Rust.Global.SteamServer.Inventory.FindDefinition(task.skinID);\r\n\t\tif (definition != null)\r\n\t\t{\r\n\t\t\tnum = definition.GetProperty\u003Culong\u003E(\u0022workshopdownload\u0022);\r\n\t\t}\r\n\t\tif (num == 0)\r\n\t\t{\r\n\t\t\tnum = (ulong)task.skinID;\r\n\t\t}\r\n\t\tItem item = ItemManager.CreateByItemID(task.blueprint.targetItem.itemid, 1, num);\r\n\t\titem.amount = task.blueprint.amountToCreate;\r\n\t\tif (item.hasCondition \u0026\u0026 task.conditionScale != 1f)\r\n\t\t{\r\n\t\t\titem.maxCondition *= task.conditionScale;\r\n\t\t\titem.condition = item.maxCondition;\r\n\t\t}\r\n\t\titem.OnVirginSpawn();\r\n\t\tforeach (ItemAmount ingredient in task.blueprint.ingredients)\r\n\t\t{\r\n\t\t\tint num2 = (int)ingredient.amount;\r\n\t\t\tif (task.takenItems == null)\r\n\t\t\t{\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tforeach (Item takenItem in task.takenItems)\r\n\t\t\t{\r\n\t\t\t\tif (takenItem.info == ingredient.itemDef)\r\n\t\t\t\t{\r\n\t\t\t\t\tint amount = takenItem.amount;\r\n\t\t\t\t\tint num3 = Mathf.Min(amount, num2);\r\n\t\t\t\t\ttakenItem.UseItem(num2);\r\n\t\t\t\t\tnum2 -= num3;\r\n\t\t\t\t}\r\n\t\t\t\tif (num2 \u003E 0)\r\n\t\t\t\t{\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tFacepunch.Rust.Analytics.Crafting(task.blueprint.targetItem.shortname, task.skinID);\r\n\t\ttask.owner.Command(\u0022note.craft_done\u0022, task.taskUID, 1, task.amount);\r\n\t\tInterface.CallHook(\u0022OnItemCraftFinished\u0022, task, item);\r\n\t\titem.instanceData = task.instanceData;\r\n\t\tif (!string.IsNullOrEmpty(task.blueprint.UnlockAchievment))\r\n\t\t{\r\n\t\t\ttask.owner.GiveAchievement(task.blueprint.UnlockAchievment);\r\n\t\t}\r\n\t\tif (task.owner.inventory.GiveItem(item))\r\n\t\t{\r\n\t\t\ttask.owner.Command(\u0022note.inv\u0022, item.info.itemid, item.amount);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tItemContainer itemContainer = containers.First();\r\n\t\ttask.owner.Command(\u0022note.inv\u0022, item.info.itemid, item.amount);\r\n\t\ttask.owner.Command(\u0022note.inv\u0022, item.info.itemid, -item.amount);\r\n\t\titem.Drop(itemContainer.dropPosition, itemContainer.dropVelocity);\r\n\t}\r\n",
    "ClassName": "ItemCrafter",
    "HookLineInvoke": 46
  },
  {
    "HookSignature": "OnPlayerWound(BasePlayer basePlayer)",
    "MethodSignature": "StartWounded()",
    "MethodSourseCode": "\r\n\tpublic void StartWounded()\r\n\t{\r\n\t\tif (!IsWounded() \u0026\u0026 Interface.CallHook(\u0022OnPlayerWound\u0022, this) == null)\r\n\t\t{\r\n\t\t\tstats.Add(\u0022wounded\u0022, 1);\r\n\t\t\twoundedDuration = UnityEngine.Random.Range(40f, 50f);\r\n\t\t\twoundedStartTime = UnityEngine.Time.realtimeSinceStartup;\r\n\t\t\tSetPlayerFlag(PlayerFlags.Wounded, b: true);\r\n\t\t\tSendNetworkUpdateImmediate();\r\n\t\t\tInvoke(WoundingTick, 1f);\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnCropGather(PlantEntity plantEntity, Item item2, BasePlayer msgPlayer)",
    "MethodSignature": "RPC_PickFruit(RPCMessage msg)",
    "MethodSourseCode": "\r\n\t[RPC_Server.MaxDistance(3f)]\r\n\t[RPC_Server]\r\n\tpublic void RPC_PickFruit(RPCMessage msg)\r\n\t{\r\n\t\tif (!CanPick())\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tharvests\u002B\u002B;\r\n\t\tfloat num = YieldBonusScale() * (float)plantProperty.waterYieldBonus;\r\n\t\tint num2 = Mathf.RoundToInt((currentStage.resources \u002B num) * (float)plantProperty.pickupAmount);\r\n\t\tResetSeason();\r\n\t\tif (plantProperty.pickupItem.condition.enabled)\r\n\t\t{\r\n\t\t\tfor (int i = 0; i \u003C num2; i\u002B\u002B)\r\n\t\t\t{\r\n\t\t\t\tItem item = ItemManager.Create(plantProperty.pickupItem, 1, 0uL);\r\n\t\t\t\titem.conditionNormalized = plantProperty.fruitCurve.Evaluate(ageFraction);\r\n\t\t\t\tInterface.CallHook(\u0022OnCropGather\u0022, this, item, msg.player);\r\n\t\t\t\tmsg.player.GiveItem(item, GiveItemReason.PickedUp);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tItem item2 = ItemManager.Create(plantProperty.pickupItem, num2, 0uL);\r\n\t\t\tInterface.CallHook(\u0022OnCropGather\u0022, this, item2, msg.player);\r\n\t\t\tmsg.player.GiveItem(item2, GiveItemReason.PickedUp);\r\n\t\t}\r\n\t\tif (plantProperty.pickEffect.isValid)\r\n\t\t{\r\n\t\t\tEffect.server.Run(plantProperty.pickEffect.resourcePath, GetEstimatedWorldPosition(), Vector3.up);\r\n\t\t}\r\n\t\tif (harvests \u003E= plantProperty.maxHarvests)\r\n\t\t{\r\n\t\t\tif (plantProperty.disappearAfterHarvest)\r\n\t\t\t{\r\n\t\t\t\tDie();\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tBecomeState(PlantProperties.State.Dying);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tBecomeState(PlantProperties.State.Mature);\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "PlantEntity",
    "HookLineInvoke": 26
  },
  {
    "HookSignature": "OnPlayerRespawn(BasePlayer basePlayer)",
    "MethodSignature": "Respawn()",
    "MethodSourseCode": "\r\n\tpublic void Respawn()\r\n\t{\r\n\t\tSpawnPoint spawnPoint = ServerMgr.FindSpawnPoint();\r\n\t\tobject obj = Interface.CallHook(\u0022OnPlayerRespawn\u0022, this);\r\n\t\tif (obj is SpawnPoint)\r\n\t\t{\r\n\t\t\tspawnPoint = (SpawnPoint)obj;\r\n\t\t}\r\n\t\tRespawnAt(spawnPoint.pos, spawnPoint.rot);\r\n\t}\r\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "CanBeTargeted(BasePlayer item, FlameTurret flameTurret)",
    "MethodSignature": "CheckTrigger()",
    "MethodSourseCode": "\r\n\tpublic bool CheckTrigger()\r\n\t{\r\n\t\tif (Time.realtimeSinceStartup \u003C nextTriggerCheckTime)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tnextTriggerCheckTime = Time.realtimeSinceStartup \u002B 1f / triggerCheckRate;\r\n\t\tList\u003CRaycastHit\u003E obj = Pool.GetList\u003CRaycastHit\u003E();\r\n\t\tList\u003CBasePlayer\u003E obj2 = Pool.GetList\u003CBasePlayer\u003E();\r\n\t\tVis.Entities(GetEyePosition() \u002B base.transform.forward * 3f, 2.5f, obj2, 131072);\r\n\t\tbool flag = false;\r\n\t\tforeach (BasePlayer item in obj2)\r\n\t\t{\r\n\t\t\tif (item.IsSleeping() || !item.IsAlive() || (item.HasPlayerFlag(BasePlayer.PlayerFlags.InBuildingPrivilege) \u0026\u0026 item.CanBuild()))\r\n\t\t\t{\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tobject obj3 = Interface.CallHook(\u0022CanBeTargeted\u0022, item, this);\r\n\t\t\tif (obj3 is bool)\r\n\t\t\t{\r\n\t\t\t\treturn (bool)obj3;\r\n\t\t\t}\r\n\t\t\tif (item.GetEstimatedWorldPosition().y \u003E GetEyePosition().y \u002B 0.5f)\r\n\t\t\t{\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tobj.Clear();\r\n\t\t\tGamePhysics.TraceAll(new Ray(item.eyes.position, (GetEyePosition() - item.eyes.position).normalized), 0f, obj, 9f, 1075904769);\r\n\t\t\tfor (int i = 0; i \u003C obj.Count; i\u002B\u002B)\r\n\t\t\t{\r\n\t\t\t\tRaycastHit hit = obj[i];\r\n\t\t\t\tBaseEntity entity = RaycastHitEx.GetEntity(hit);\r\n\t\t\t\tif (entity != null \u0026\u0026 (entity == this || entity.EqualNetID(this)))\r\n\t\t\t\t{\r\n\t\t\t\t\tflag = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tif (!(entity != null) || entity.ShouldBlockProjectiles())\r\n\t\t\t\t{\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!flag)\r\n\t\t\t{\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tPool.FreeList(ref obj);\r\n\t\tPool.FreeList(ref obj2);\r\n\t\treturn flag;\r\n\t}\r\n",
    "ClassName": "FlameTurret",
    "HookLineInvoke": 18
  },
  {
    "HookSignature": "OnQuarryGather(MiningQuarry miningQuarry, Item item)",
    "MethodSignature": "ProcessResources()",
    "MethodSourseCode": "\r\n\tpublic void ProcessResources()\r\n\t{\r\n\t\tif (_linkedDeposit == null || hopperPrefab.instance == null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tforeach (ResourceDepositManager.ResourceDeposit.ResourceDepositEntry resource in _linkedDeposit._resources)\r\n\t\t{\r\n\t\t\tif ((!canExtractLiquid \u0026\u0026 resource.isLiquid) || (!canExtractSolid \u0026\u0026 !resource.isLiquid))\r\n\t\t\t{\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tresource.workDone \u002B= workToAdd;\r\n\t\t\tif (!(resource.workDone \u003C resource.workNeeded))\r\n\t\t\t{\r\n\t\t\t\tint num = Mathf.FloorToInt(resource.workDone / resource.workNeeded);\r\n\t\t\t\tresource.workDone -= (float)num * resource.workNeeded;\r\n\t\t\t\tItem item = ItemManager.Create(resource.type, num, 0uL);\r\n\t\t\t\tInterface.CallHook(\u0022OnQuarryGather\u0022, this, item);\r\n\t\t\t\tif (!item.MoveToContainer(hopperPrefab.instance.GetComponent\u003CStorageContainer\u003E().inventory))\r\n\t\t\t\t{\r\n\t\t\t\t\titem.Remove();\r\n\t\t\t\t\tSetOn(isOn: false);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!FuelCheck())\r\n\t\t{\r\n\t\t\tSetOn(isOn: false);\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "MiningQuarry",
    "HookLineInvoke": 19
  },
  {
    "HookSignature": "CanAssignBed(SleepingBag sleepingBag, BasePlayer msgPlayer, ulong num)",
    "MethodSignature": "AssignToFriend(RPCMessage msg)",
    "MethodSourseCode": "\r\n\t[RPC_Server.MaxDistance(3f)]\r\n\t[RPC_Server]\r\n\tpublic void AssignToFriend(RPCMessage msg)\r\n\t{\r\n\t\tif (msg.player.CanInteract() \u0026\u0026 deployerUserID == msg.player.userID)\r\n\t\t{\r\n\t\t\tulong num = msg.read.UInt64();\r\n\t\t\tif (num != 0 \u0026\u0026 Interface.CallHook(\u0022CanAssignBed\u0022, this, msg.player, num) == null)\r\n\t\t\t{\r\n\t\t\t\tdeployerUserID = num;\r\n\t\t\t\tSendNetworkUpdate();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "SleepingBag",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnMaxStackable(Item item)",
    "MethodSignature": "MaxStackable()",
    "MethodSourseCode": "\r\n\tpublic int MaxStackable()\r\n\t{\r\n\t\tint num = info.stackable;\r\n\t\tif (parent != null \u0026\u0026 parent.maxStackSize \u003E 0)\r\n\t\t{\r\n\t\t\tnum = Mathf.Min(parent.maxStackSize, num);\r\n\t\t}\r\n\t\tobject obj = Interface.CallHook(\u0022OnMaxStackable\u0022, this);\r\n\t\tif (obj is int)\r\n\t\t{\r\n\t\t\treturn (int)obj;\r\n\t\t}\r\n\t\treturn num;\r\n\t}\r\n",
    "ClassName": "Item",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnTurretAuthorize(AutoTurret autoTurret, BasePlayer rpcPlayer)",
    "MethodSignature": "AddSelfAuthorize(RPCMessage rpc)",
    "MethodSourseCode": "\r\n\t[RPC_Server.MaxDistance(3f)]\r\n\t[RPC_Server]\r\n\tprivate void AddSelfAuthorize(RPCMessage rpc)\r\n\t{\r\n\t\tRPCMessage rpc2 = rpc;\r\n\t\tif (!IsOnline() \u0026\u0026 Interface.CallHook(\u0022OnTurretAuthorize\u0022, this, rpc.player) == null)\r\n\t\t{\r\n\t\t\tauthorizedPlayers.RemoveAll((PlayerNameID x) =\u003E x.userid == rpc2.player.userID);\r\n\t\t\tPlayerNameID playerNameID = new PlayerNameID();\r\n\t\t\tplayerNameID.userid = rpc2.player.userID;\r\n\t\t\tplayerNameID.username = rpc2.player.displayName;\r\n\t\t\tauthorizedPlayers.Add(playerNameID);\r\n\t\t\tSendNetworkUpdate();\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "AutoTurret",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnTick()",
    "MethodSignature": "DoTick()",
    "MethodSourseCode": "\r\n\tprivate void DoTick()\r\n\t{\r\n\t\tif (Rust.Global.SteamServer != null)\r\n\t\t{\r\n\t\t\tInterface.CallHook(\u0022OnTick\u0022, null);\r\n\t\t\tRust.Global.SteamServer.Update();\r\n\t\t}\r\n\t\tRCon.Update();\r\n\t\tfor (int i = 0; i \u003C Network.Net.sv.connections.Count; i\u002B\u002B)\r\n\t\t{\r\n\t\t\tConnection connection = Network.Net.sv.connections[i];\r\n\t\t\tif (!connection.isAuthenticated \u0026\u0026 !(connection.GetSecondsConnected() \u003C (float)ConVar.Server.authtimeout))\r\n\t\t\t{\r\n\t\t\t\tNetwork.Net.sv.Kick(connection, \u0022Authentication Timed Out\u0022);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "ServerMgr",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnMessagePlayer(string msg, BasePlayer basePlayer)",
    "MethodSignature": "ChatMessage(string msg)",
    "MethodSourseCode": "\r\n\tpublic void ChatMessage(string msg)\r\n\t{\r\n\t\tif (base.isServer \u0026\u0026 Interface.CallHook(\u0022OnMessagePlayer\u0022, msg, this) == null)\r\n\t\t{\r\n\t\t\tSendConsoleCommand(\u0022chat.add\u0022, 0, msg);\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanCraft(ItemCrafter itemCrafter, ItemBlueprint bp, int amount)",
    "MethodSignature": "CanCraft(ItemBlueprint bp, int amount)",
    "MethodSourseCode": "\r\n\tpublic bool CanCraft(ItemBlueprint bp, int amount = 1)\r\n\t{\r\n\t\tif (amount \u003C 1 || amount \u003E 9000)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tobject obj = Interface.CallHook(\u0022CanCraft\u0022, this, bp, amount);\r\n\t\tif (obj is bool)\r\n\t\t{\r\n\t\t\treturn (bool)obj;\r\n\t\t}\r\n\t\tforeach (ItemAmount ingredient in bp.ingredients)\r\n\t\t{\r\n\t\t\tif (!DoesHaveUsableItem(ingredient.itemid, (int)ingredient.amount * amount))\r\n\t\t\t{\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n",
    "ClassName": "ItemCrafter",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnItemRemovedFromContainer(ItemContainer itemContainer, Item item)",
    "MethodSignature": "Remove(Item item)",
    "MethodSourseCode": "\r\n\tpublic bool Remove(Item item)\r\n\t{\r\n\t\tif (!itemList.Contains(item))\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (onPreItemRemove != null)\r\n\t\t{\r\n\t\t\tonPreItemRemove(item);\r\n\t\t}\r\n\t\titemList.Remove(item);\r\n\t\titem.parent = null;\r\n\t\tMarkDirty();\r\n\t\tif (onItemAddedRemoved != null)\r\n\t\t{\r\n\t\t\tonItemAddedRemoved(item, arg2: false);\r\n\t\t}\r\n\t\tInterface.CallHook(\u0022OnItemRemovedFromContainer\u0022, this, item);\r\n\t\treturn true;\r\n\t}\r\n",
    "ClassName": "ItemContainer",
    "HookLineInvoke": 18
  },
  {
    "HookSignature": "OnStructureRepair(BaseCombatEntity baseCombatEntity, BasePlayer player)",
    "MethodSignature": "DoRepair(BasePlayer player)",
    "MethodSourseCode": "\r\n\tpublic virtual void DoRepair(BasePlayer player)\r\n\t{\r\n\t\tBasePlayer player2 = player;\r\n\t\tif (!repair.enabled || Interface.CallHook(\u0022OnStructureRepair\u0022, this, player) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (SecondsSinceAttacked \u003C= 8f)\r\n\t\t{\r\n\t\t\tOnRepairFailed();\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tfloat num = MaxHealth() - health;\r\n\t\tfloat num2 = num / MaxHealth();\r\n\t\tif (num \u003C= 0f || num2 \u003C= 0f)\r\n\t\t{\r\n\t\t\tOnRepairFailed();\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tList\u003CItemAmount\u003E list = RepairCost(num2);\r\n\t\tif (list == null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tfloat num3 = list.Sum((ItemAmount x) =\u003E x.amount);\r\n\t\tif (num3 \u003E 0f)\r\n\t\t{\r\n\t\t\tfloat a = list.Min((ItemAmount x) =\u003E Mathf.Clamp01((float)player2.inventory.GetAmount(x.itemid) / x.amount));\r\n\t\t\ta = Mathf.Min(a, 50f / num);\r\n\t\t\tif (a \u003C= 0f)\r\n\t\t\t{\r\n\t\t\t\tOnRepairFailed();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tint num4 = 0;\r\n\t\t\tforeach (ItemAmount item in list)\r\n\t\t\t{\r\n\t\t\t\tint amount = Mathf.CeilToInt(a * item.amount);\r\n\t\t\t\tint num5 = player2.inventory.Take(null, item.itemid, amount);\r\n\t\t\t\tif (num5 \u003E 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tnum4 \u002B= num5;\r\n\t\t\t\t\tplayer2.Command(\u0022note.inv\u0022, item.itemid, num5 * -1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfloat num6 = (float)num4 / num3;\r\n\t\t\thealth \u002B= num * num6;\r\n\t\t\tSendNetworkUpdate();\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\thealth \u002B= num;\r\n\t\t\tSendNetworkUpdate();\r\n\t\t}\r\n\t\tif (health \u003E= MaxHealth())\r\n\t\t{\r\n\t\t\tOnRepairFinished();\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tOnRepair();\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "BaseCombatEntity",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnDispenserBonus(ResourceDispenser resourceDispenser, BasePlayer player, Item item)",
    "MethodSignature": "AssignFinishBonus(BasePlayer player, float fraction)",
    "MethodSourseCode": "\r\n\tpublic void AssignFinishBonus(BasePlayer player, float fraction)\r\n\t{\r\n\t\tSendMessage(\u0022FinishBonusAssigned\u0022, SendMessageOptions.DontRequireReceiver);\r\n\t\tif (fraction \u003C= 0f || finishBonus == null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tforeach (ItemAmount finishBonu in finishBonus)\r\n\t\t{\r\n\t\t\tItem item = ItemManager.Create(finishBonu.itemDef, Mathf.CeilToInt((float)(int)finishBonu.amount * Mathf.Clamp01(fraction)), 0uL);\r\n\t\t\tif (item != null)\r\n\t\t\t{\r\n\t\t\t\tobject obj = Interface.CallHook(\u0022OnDispenserBonus\u0022, this, player, item);\r\n\t\t\t\tif (obj is Item)\r\n\t\t\t\t{\r\n\t\t\t\t\titem = (Item)obj;\r\n\t\t\t\t}\r\n\t\t\t\tplayer.GiveItem(item, BaseEntity.GiveItemReason.ResourceHarvested);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "ResourceDispenser",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "OnDeleteVendingOffer(VendingMachine vendingMachine, BasePlayer player)",
    "MethodSignature": "RPC_DeleteSellOrder(RPCMessage msg)",
    "MethodSourseCode": "\r\n\t[RPC_Server]\r\n\t[RPC_Server.IsVisible(3f)]\r\n\tpublic void RPC_DeleteSellOrder(RPCMessage msg)\r\n\t{\r\n\t\tBasePlayer player = msg.player;\r\n\t\tif (CanPlayerAdmin(player))\r\n\t\t{\r\n\t\t\tint num = msg.read.Int32();\r\n\t\t\tif (num \u003E= 0 \u0026\u0026 num \u003C sellOrders.sellOrders.Count)\r\n\t\t\t{\r\n\t\t\t\tsellOrders.sellOrders.RemoveAt(num);\r\n\t\t\t}\r\n\t\t\tInterface.CallHook(\u0022OnDeleteVendingOffer\u0022, this, player);\r\n\t\t\tRefreshSellOrderStockLevel();\r\n\t\t\tUpdateMapMarker();\r\n\t\t\tSendSellOrders(player);\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "OnEntityGroundMissing(BaseEntity baseEntity)",
    "MethodSignature": "OnGroundMissing()",
    "MethodSourseCode": "\tprivate void OnGroundMissing()\r\n\t{\r\n\t\tBaseEntity baseEntity = GameObjectEx.ToBaseEntity(base.gameObject);\r\n\t\tif (Interface.CallHook(\u0022OnEntityGroundMissing\u0022, baseEntity) == null \u0026\u0026 baseEntity != null)\r\n\t\t{\r\n\t\t\tbaseEntity.SendMessage(\u0022PreDie\u0022, SendMessageOptions.DontRequireReceiver);\r\n\t\t\tbaseEntity.Kill(BaseNetworkable.DestroyMode.Gib);\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "DestroyOnGroundMissing",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnHelicopterTarget(HelicopterTurret helicopterTurret, BaseCombatEntity newTarget)",
    "MethodSignature": "SetTarget(BaseCombatEntity newTarget)",
    "MethodSourseCode": "\r\n\tpublic void SetTarget(BaseCombatEntity newTarget)\r\n\t{\r\n\t\tif (Interface.CallHook(\u0022OnHelicopterTarget\u0022, this, newTarget) == null)\r\n\t\t{\r\n\t\t\t_target = newTarget;\r\n\t\t\tUpdateTargetVisibility();\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "HelicopterTurret",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanNpcEat(BaseNpc baseNpc, BaseEntity best)",
    "MethodSignature": "WantsToEat(BaseEntity best)",
    "MethodSourseCode": "\r\n\tpublic virtual bool WantsToEat(BaseEntity best)\r\n\t{\r\n\t\tobject obj = Interface.CallHook(\u0022CanNpcEat\u0022, this, best);\r\n\t\tif (obj is bool)\r\n\t\t{\r\n\t\t\treturn (bool)obj;\r\n\t\t}\r\n\t\tif (!best.HasTrait(TraitFlag.Food))\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (best.HasTrait(TraitFlag.Alive))\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n",
    "ClassName": "BaseNpc",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnStructureUpgrade(BuildingBlock buildingBlock, BasePlayer msgPlayer, BuildingGrade.Enum @enum)",
    "MethodSignature": "DoUpgradeToGrade(RPCMessage msg)",
    "MethodSourseCode": "\r\n\t[RPC_Server]\r\n\t[RPC_Server.MaxDistance(3f)]\r\n\tprivate void DoUpgradeToGrade(RPCMessage msg)\r\n\t{\r\n\t\tif (msg.player.CanInteract())\r\n\t\t{\r\n\t\t\tBuildingGrade.Enum @enum = (BuildingGrade.Enum)msg.read.Int32();\r\n\t\t\tConstructionGrade constructionGrade = GetGrade(@enum);\r\n\t\t\tif (!(constructionGrade == null) \u0026\u0026 CanChangeToGrade(@enum, msg.player) \u0026\u0026 CanAffordUpgrade(@enum, msg.player) \u0026\u0026 !(base.SecondsSinceAttacked \u003C 8f) \u0026\u0026 Interface.CallHook(\u0022OnStructureUpgrade\u0022, this, msg.player, @enum) == null)\r\n\t\t\t{\r\n\t\t\t\tPayForUpgrade(constructionGrade, msg.player);\r\n\t\t\t\tSetGrade(@enum);\r\n\t\t\t\tSetHealthToMax();\r\n\t\t\t\tStartBeingRotatable();\r\n\t\t\t\tSendNetworkUpdate();\r\n\t\t\t\tUpdateSkin();\r\n\t\t\t\tEffect.server.Run(\u0022assets/bundled/prefabs/fx/build/promote_\u0022 \u002B @enum.ToString().ToLower() \u002B \u0022.prefab\u0022, this, 0u, Vector3.zero, Vector3.zero);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "BuildingBlock",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "CanCombineDroppedItem(DroppedItem droppedItem, DroppedItem di)",
    "MethodSignature": "OnDroppedOn(DroppedItem di)",
    "MethodSourseCode": "\r\n\tpublic void OnDroppedOn(DroppedItem di)\r\n\t{\r\n\t\tif (item != null \u0026\u0026 di.item != null \u0026\u0026 Interface.CallHook(\u0022CanCombineDroppedItem\u0022, this, di) == null \u0026\u0026 item.info.stackable \u003E 1 \u0026\u0026 !(di.item.info != item.info) \u0026\u0026 (!di.item.IsBlueprint() || di.item.blueprintTarget == item.blueprintTarget))\r\n\t\t{\r\n\t\t\tint num = di.item.amount \u002B item.amount;\r\n\t\t\tif (num \u003C= item.info.stackable \u0026\u0026 num != 0)\r\n\t\t\t{\r\n\t\t\t\tdi.DestroyItem();\r\n\t\t\t\tdi.Kill();\r\n\t\t\t\titem.amount = num;\r\n\t\t\t\titem.MarkDirty();\r\n\t\t\t\tInvoke(IdleDestroy, GetDespawnDuration());\r\n\t\t\t\tEffect.server.Run(\u0022assets/bundled/prefabs/fx/notice/stack.world.fx.prefab\u0022, this, 0u, Vector3.zero, Vector3.zero);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "DroppedItem",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnEntityBuilt(Planner planner, UnityEngine.GameObject gameObject)",
    "MethodSignature": "DoBuild(Construction.Target target, Construction component)",
    "MethodSourseCode": "\r\n\tpublic void DoBuild(Construction.Target target, Construction component)\r\n\t{\r\n\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\r\n\t\tif (!ownerPlayer || RayEx.IsNaNOrInfinity(target.ray) || target.position.IsNaNOrInfinity() || target.normal.IsNaNOrInfinity())\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (target.socket != null)\r\n\t\t{\r\n\t\t\tif (!target.socket.female)\r\n\t\t\t{\r\n\t\t\t\townerPlayer.ChatMessage(\u0022Target socket is not female. (\u0022 \u002B target.socket.socketName \u002B \u0022)\u0022);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tif (target.construction != null \u0026\u0026 target.construction.IsOccupied(target.socket))\r\n\t\t\t{\r\n\t\t\t\townerPlayer.ChatMessage(\u0022Target socket is occupied. (\u0022 \u002B target.socket.socketName \u002B \u0022)\u0022);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t\tConstruction.lastPlacementError = \u0022No Error\u0022;\r\n\t\tGameObject gameObject = DoPlacement(target, component);\r\n\t\tif (gameObject == null)\r\n\t\t{\r\n\t\t\townerPlayer.ChatMessage(\u0022Can\u0027t place: \u0022 \u002B Construction.lastPlacementError);\r\n\t\t}\r\n\t\tif (!(gameObject != null))\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tInterface.CallHook(\u0022OnEntityBuilt\u0022, this, gameObject);\r\n\t\tDeployable deployable = GetDeployable();\r\n\t\tif (deployable != null)\r\n\t\t{\r\n\t\t\tBaseEntity baseEntity = GameObjectEx.ToBaseEntity(gameObject);\r\n\t\t\tif (deployable.setSocketParent \u0026\u0026 target.transformParent != null \u0026\u0026 (bool)baseEntity)\r\n\t\t\t{\r\n\t\t\t\tbaseEntity.SetParent(target.transformParent);\r\n\t\t\t\tbaseEntity.transform.position = target.transformParent.transform.InverseTransformPoint(baseEntity.transform.position);\r\n\t\t\t}\r\n\t\t\tif (deployable.wantsInstanceData \u0026\u0026 GetOwnerItem().instanceData != null)\r\n\t\t\t{\r\n\t\t\t\t(baseEntity as IInstanceDataReceiver).ReceiveInstanceData(GetOwnerItem().instanceData);\r\n\t\t\t}\r\n\t\t\tif (deployable.copyInventoryFromItem)\r\n\t\t\t{\r\n\t\t\t\tStorageContainer component2 = baseEntity.GetComponent\u003CStorageContainer\u003E();\r\n\t\t\t\tif ((bool)component2)\r\n\t\t\t\t{\r\n\t\t\t\t\tcomponent2.ReceiveInventoryFromItem(GetOwnerItem());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tItemModDeployable modDeployable = GetModDeployable();\r\n\t\t\tif (modDeployable != null)\r\n\t\t\t{\r\n\t\t\t\tmodDeployable.OnDeployed(baseEntity, ownerPlayer);\r\n\t\t\t}\r\n\t\t}\r\n\t\tPayForPlacement(ownerPlayer, component);\r\n\t}\r\n",
    "ClassName": "Planner",
    "HookLineInvoke": 31
  },
  {
    "HookSignature": "OnPlayerConnected(Network.Message packet)",
    "MethodSignature": "ClientReady(Message packet)",
    "MethodSourseCode": "\r\n\tprivate void ClientReady(Message packet)\r\n\t{\r\n\t\tusing ClientReady clientReady = ProtoBuf.ClientReady.Deserialize(packet.read);\r\n\t\tforeach (ClientReady.ClientInfo item in clientReady.clientInfo)\r\n\t\t{\r\n\t\t\tpacket.connection.info.Set(item.name, item.value);\r\n\t\t}\r\n\t\tconnectionQueue.JoinedGame(packet.connection);\r\n\t\tInterface.CallHook(\u0022OnPlayerConnected\u0022, packet);\r\n\t\tusing (TimeWarning.New(\u0022ClientReady\u0022))\r\n\t\t{\r\n\t\t\tusing (TimeWarning.New(\u0022SpawnPlayerSleeping\u0022))\r\n\t\t\t{\r\n\t\t\t\tif (SpawnPlayerSleeping(packet.connection))\r\n\t\t\t\t{\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tusing (TimeWarning.New(\u0022SpawnNewPlayer\u0022))\r\n\t\t\t{\r\n\t\t\t\tSpawnNewPlayer(packet.connection);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "ServerMgr",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "IOnLoseCondition(Item item, float amount)",
    "MethodSignature": "LoseCondition(float amount)",
    "MethodSourseCode": "\r\n\tpublic void LoseCondition(float amount)\r\n\t{\r\n\t\tif (hasCondition \u0026\u0026 Interface.CallHook(\u0022IOnLoseCondition\u0022, this, amount) == null \u0026\u0026 !Debugging.disablecondition)\r\n\t\t{\r\n\t\t\tfloat num = condition;\r\n\t\t\tcondition -= amount;\r\n\t\t\tif (ConVar.Global.developer \u003E 0)\r\n\t\t\t{\r\n\t\t\t\tDebug.Log(info.shortname \u002B \u0022 was damaged by: \u0022 \u002B amount \u002B \u0022cond is: \u0022 \u002B condition \u002B \u0022/\u0022 \u002B maxCondition);\r\n\t\t\t}\r\n\t\t\tif (condition \u003C= 0f \u0026\u0026 condition \u003C num)\r\n\t\t\t{\r\n\t\t\t\tOnBroken();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "Item",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnMeleeAttack(BasePlayer player, HitInfo hitInfo)",
    "MethodSignature": "PlayerAttack(RPCMessage msg)",
    "MethodSourseCode": "\r\n\t[RPC_Server]\r\n\t[RPC_Server.IsActiveItem]\r\n\tpublic void PlayerAttack(RPCMessage msg)\r\n\t{\r\n\t\tBasePlayer player = msg.player;\r\n\t\tif (!VerifyClientAttack(player))\r\n\t\t{\r\n\t\t\tSendNetworkUpdate();\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tusing (TimeWarning.New(\u0022PlayerAttack\u0022, 50L))\r\n\t\t{\r\n\t\t\tusing PlayerAttack playerAttack = ProtoBuf.PlayerAttack.Deserialize(msg.read);\r\n\t\t\tif (playerAttack == null)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tHitInfo hitInfo = Facepunch.Pool.Get\u003CHitInfo\u003E();\r\n\t\t\thitInfo.LoadFromAttack(playerAttack.attack, serverSide: true);\r\n\t\t\thitInfo.Initiator = player;\r\n\t\t\thitInfo.Weapon = this;\r\n\t\t\thitInfo.WeaponPrefab = this;\r\n\t\t\thitInfo.Predicted = msg.connection;\r\n\t\t\thitInfo.damageProperties = damageProperties;\r\n\t\t\tif (Interface.CallHook(\u0022OnMeleeAttack\u0022, player, hitInfo) != null)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tif (hitInfo.IsNaNOrInfinity())\r\n\t\t\t{\r\n\t\t\t\tstring shortPrefabName = base.ShortPrefabName;\r\n\t\t\t\tAntiHack.Log(player, AntiHackType.MeleeHack, \u0022Contains NaN (\u0022 \u002B shortPrefabName \u002B \u0022)\u0022);\r\n\t\t\t\tplayer.stats.combat.Log(hitInfo, \u0022melee_nan\u0022);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tif (ConVar.AntiHack.melee_protection \u003E 0 \u0026\u0026 (bool)hitInfo.HitEntity)\r\n\t\t\t{\r\n\t\t\t\tbool flag = true;\r\n\t\t\t\tfloat num = 1f \u002B ConVar.AntiHack.melee_forgiveness;\r\n\t\t\t\tfloat melee_clientframes = ConVar.AntiHack.melee_clientframes;\r\n\t\t\t\tfloat melee_serverframes = ConVar.AntiHack.melee_serverframes;\r\n\t\t\t\tfloat num2 = melee_clientframes / 60f;\r\n\t\t\t\tfloat num3 = melee_serverframes * Mathx.Max(UnityEngine.Time.deltaTime, UnityEngine.Time.smoothDeltaTime, UnityEngine.Time.fixedDeltaTime);\r\n\t\t\t\tfloat num4 = (player.desyncTime \u002B num2 \u002B num3) * num;\r\n\t\t\t\tif (ConVar.AntiHack.projectile_protection \u003E= 2)\r\n\t\t\t\t{\r\n\t\t\t\t\tfloat num5 = hitInfo.HitEntity.MaxVelocity();\r\n\t\t\t\t\tfloat num6 = hitInfo.HitEntity.BoundsPadding() \u002B num4 * num5;\r\n\t\t\t\t\tfloat num7 = hitInfo.HitEntity.Distance(hitInfo.HitPositionWorld);\r\n\t\t\t\t\tif (num7 \u003E num6)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tstring shortPrefabName2 = base.ShortPrefabName;\r\n\t\t\t\t\t\tstring shortPrefabName3 = hitInfo.HitEntity.ShortPrefabName;\r\n\t\t\t\t\t\tAntiHack.Log(player, AntiHackType.MeleeHack, \u0022Entity too far away (\u0022 \u002B shortPrefabName2 \u002B \u0022 on \u0022 \u002B shortPrefabName3 \u002B \u0022 with \u0022 \u002B num7 \u002B \u0022m \u003E \u0022 \u002B num6 \u002B \u0022m in \u0022 \u002B num4 \u002B \u0022s)\u0022);\r\n\t\t\t\t\t\tplayer.stats.combat.Log(hitInfo, \u0022melee_distance\u0022);\r\n\t\t\t\t\t\tflag = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (ConVar.AntiHack.melee_protection \u003E= 1)\r\n\t\t\t\t{\r\n\t\t\t\t\tfloat num8 = hitInfo.Initiator.MaxVelocity();\r\n\t\t\t\t\tfloat num9 = hitInfo.Initiator.BoundsPadding() \u002B num4 * num8 \u002B num * maxDistance;\r\n\t\t\t\t\tfloat num10 = hitInfo.Initiator.Distance(hitInfo.HitPositionWorld);\r\n\t\t\t\t\tif (num10 \u003E num9)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tstring shortPrefabName4 = base.ShortPrefabName;\r\n\t\t\t\t\t\tstring shortPrefabName5 = hitInfo.HitEntity.ShortPrefabName;\r\n\t\t\t\t\t\tAntiHack.Log(player, AntiHackType.MeleeHack, \u0022Initiator too far away (\u0022 \u002B shortPrefabName4 \u002B \u0022 on \u0022 \u002B shortPrefabName5 \u002B \u0022 with \u0022 \u002B num10 \u002B \u0022m \u003E \u0022 \u002B num9 \u002B \u0022m in \u0022 \u002B num4 \u002B \u0022s)\u0022);\r\n\t\t\t\t\t\tplayer.stats.combat.Log(hitInfo, \u0022melee_distance\u0022);\r\n\t\t\t\t\t\tflag = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (ConVar.AntiHack.melee_protection \u003E= 3)\r\n\t\t\t\t{\r\n\t\t\t\t\tVector3 pointStart = hitInfo.PointStart;\r\n\t\t\t\t\tVector3 vector = hitInfo.HitPositionWorld \u002B hitInfo.HitNormalWorld.normalized * 0.001f;\r\n\t\t\t\t\tVector3 position = player.eyes.position;\r\n\t\t\t\t\tVector3 vector2 = pointStart;\r\n\t\t\t\t\tVector3 vector3 = hitInfo.PositionOnRay(vector);\r\n\t\t\t\t\tVector3 vector4 = vector;\r\n\t\t\t\t\tbool flag2 = GamePhysics.LineOfSight(position, vector2, vector3, vector4, 2162688);\r\n\t\t\t\t\tif (!flag2)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tplayer.stats.Add(\u0022hit_\u0022 \u002B hitInfo.HitEntity.Categorize() \u002B \u0022_indirect_los\u0022, 1, Stats.Server);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tplayer.stats.Add(\u0022hit_\u0022 \u002B hitInfo.HitEntity.Categorize() \u002B \u0022_direct_los\u0022, 1, Stats.Server);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (!flag2)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tstring shortPrefabName6 = base.ShortPrefabName;\r\n\t\t\t\t\t\tstring shortPrefabName7 = hitInfo.HitEntity.ShortPrefabName;\r\n\t\t\t\t\t\tAntiHack.Log(player, AntiHackType.MeleeHack, string.Concat(\u0022Line of sight (\u0022, shortPrefabName6, \u0022 on \u0022, shortPrefabName7, \u0022) \u0022, position, \u0022 \u0022, vector2, \u0022 \u0022, vector3, \u0022 \u0022, vector4));\r\n\t\t\t\t\t\tplayer.stats.combat.Log(hitInfo, \u0022melee_los\u0022);\r\n\t\t\t\t\t\tflag = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (!flag)\r\n\t\t\t\t{\r\n\t\t\t\t\tAntiHack.AddViolation(player, AntiHackType.MeleeHack, ConVar.AntiHack.melee_penalty);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tplayer.metabolism.UseHeart(heartStress * 0.2f);\r\n\t\t\tusing (TimeWarning.New(\u0022DoAttackShared\u0022, 50L))\r\n\t\t\t{\r\n\t\t\t\tDoAttackShared(hitInfo);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "BaseMelee",
    "HookLineInvoke": 25
  },
  {
    "HookSignature": "OnServerShutdown()",
    "MethodSignature": "Shutdown()",
    "MethodSourseCode": "\r\n\tinternal void Shutdown()\r\n\t{\r\n\t\tInterface.CallHook(\u0022OnServerShutdown\u0022, null);\r\n\t\tBasePlayer[] array = BasePlayer.activePlayerList.ToArray();\r\n\t\tforeach (BasePlayer basePlayer in array)\r\n\t\t{\r\n\t\t\tbasePlayer.Kick(\u0022Server Shutting Down\u0022);\r\n\t\t}\r\n\t\tConsoleSystem.Run(ConsoleSystem.Option.Server, \u0022server.save\u0022);\r\n\t\tConsoleSystem.Run(ConsoleSystem.Option.Server, \u0022server.writecfg\u0022);\r\n\t}\r\n",
    "ClassName": "ServerMgr",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanPickupEntity(BaseCombatEntity baseCombatEntity, BasePlayer player)",
    "MethodSignature": "CanPickup(BasePlayer player)",
    "MethodSourseCode": "\r\n\tpublic virtual bool CanPickup(BasePlayer player)\r\n\t{\r\n\t\tobject obj = Interface.CallHook(\u0022CanPickupEntity\u0022, this, player);\r\n\t\tif (obj is bool)\r\n\t\t{\r\n\t\t\treturn (bool)obj;\r\n\t\t}\r\n\t\treturn pickup.enabled \u0026\u0026 (!pickup.requireBuildingPrivilege || (player.CanBuild() \u0026\u0026 (!pickup.requireHammer || ((bool)player.GetHeldEntity() \u0026\u0026 player.GetHeldEntity().GetComponent\u003CHammer\u003E() != null))));\r\n\t}\r\n",
    "ClassName": "BaseCombatEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnTurretDeauthorize(AutoTurret autoTurret, BasePlayer rpcPlayer)",
    "MethodSignature": "RemoveSelfAuthorize(RPCMessage rpc)",
    "MethodSourseCode": "\r\n\t[RPC_Server]\r\n\t[RPC_Server.MaxDistance(3f)]\r\n\tprivate void RemoveSelfAuthorize(RPCMessage rpc)\r\n\t{\r\n\t\tRPCMessage rpc2 = rpc;\r\n\t\tif (!booting \u0026\u0026 !IsOnline() \u0026\u0026 IsAuthed(rpc2.player) \u0026\u0026 Interface.CallHook(\u0022OnTurretDeauthorize\u0022, this, rpc.player) == null)\r\n\t\t{\r\n\t\t\tauthorizedPlayers.RemoveAll((PlayerNameID x) =\u003E x.userid == rpc2.player.userID);\r\n\t\t\tSendNetworkUpdate();\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "AutoTurret",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnBradleyApcPatrol(BradleyAPC bradleyAPC)",
    "MethodSignature": "UpdateMovement_Patrol()",
    "MethodSourseCode": "\r\n\tpublic void UpdateMovement_Patrol()\r\n\t{\r\n\t\tif (patrolPath == null || UnityEngine.Time.time \u003C nextPatrolTime)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tnextPatrolTime = UnityEngine.Time.time \u002B 20f;\r\n\t\tif ((HasPath() \u0026\u0026 !IsAtFinalDestination()) || Interface.CallHook(\u0022OnBradleyApcPatrol\u0022, this) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tPathInterestNode randomInterestNodeAwayFrom = patrolPath.GetRandomInterestNodeAwayFrom(base.transform.position);\r\n\t\tBasePathNode closestToPoint = patrolPath.GetClosestToPoint(randomInterestNodeAwayFrom.transform.position);\r\n\t\tBasePathNode basePathNode = null;\r\n\t\tbool flag = false;\r\n\t\tList\u003CBasePathNode\u003E nodes = Facepunch.Pool.GetList\u003CBasePathNode\u003E();\r\n\t\tif (GetEngagementPath(ref nodes))\r\n\t\t{\r\n\t\t\tflag = true;\r\n\t\t\tbasePathNode = nodes[nodes.Count - 1];\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tbasePathNode = patrolPath.GetClosestToPoint(base.transform.position);\r\n\t\t}\r\n\t\tif (!(Vector3.Distance(finalDestination, closestToPoint.transform.position) \u003E 2f))\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (closestToPoint == basePathNode)\r\n\t\t{\r\n\t\t\tcurrentPath.Clear();\r\n\t\t\tcurrentPath.Add(closestToPoint.transform.position);\r\n\t\t\tcurrentPathIndex = -1;\r\n\t\t\tpathLooping = false;\r\n\t\t\tfinalDestination = closestToPoint.transform.position;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tif (!AStarPath.FindPath(basePathNode, closestToPoint, out var path, out var _))\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tcurrentPath.Clear();\r\n\t\t\tif (flag)\r\n\t\t\t{\r\n\t\t\t\tfor (int i = 0; i \u003C nodes.Count - 1; i\u002B\u002B)\r\n\t\t\t\t{\r\n\t\t\t\t\tcurrentPath.Add(nodes[i].transform.position);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tforeach (BasePathNode item in path)\r\n\t\t\t{\r\n\t\t\t\tcurrentPath.Add(item.transform.position);\r\n\t\t\t}\r\n\t\t\tcurrentPathIndex = -1;\r\n\t\t\tpathLooping = false;\r\n\t\t\tfinalDestination = closestToPoint.transform.position;\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "BradleyAPC",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "CanHelicopterStrafeTarget(PatrolHelicopterAI patrolHelicopterAI, BasePlayer ply)",
    "MethodSignature": "ValidStrafeTarget(BasePlayer ply)",
    "MethodSourseCode": "\r\n\tpublic bool ValidStrafeTarget(BasePlayer ply)\r\n\t{\r\n\t\tobject obj = Interface.CallHook(\u0022CanHelicopterStrafeTarget\u0022, this, ply);\r\n\t\tif (obj is bool)\r\n\t\t{\r\n\t\t\treturn (bool)obj;\r\n\t\t}\r\n\t\tif (ply.CanBuild())\r\n\t\t{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tBuildingPrivlidge buildingPrivilege = ply.GetBuildingPrivilege();\r\n\t\tif (buildingPrivilege == null || !buildingPrivilege.AnyAuthed())\r\n\t\t{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n",
    "ClassName": "PatrolHelicopterAI",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanUseLockedEntity(BasePlayer player, CodeLock codeLock)",
    "MethodSignature": "OnTryToOpen(BasePlayer player)",
    "MethodSourseCode": "\r\n\tpublic override bool OnTryToOpen(BasePlayer player)\r\n\t{\r\n\t\tobject obj = Interface.CallHook(\u0022CanUseLockedEntity\u0022, player, this);\r\n\t\tif (obj is bool)\r\n\t\t{\r\n\t\t\treturn (bool)obj;\r\n\t\t}\r\n\t\tif (!IsLocked())\r\n\t\t{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tif (whitelistPlayers.Contains(player.userID) || guestPlayers.Contains(player.userID))\r\n\t\t{\r\n\t\t\tDoEffect(effectUnlocked.resourcePath);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tDoEffect(effectDenied.resourcePath);\r\n\t\treturn false;\r\n\t}\r\n",
    "ClassName": "CodeLock",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanLock(CodeLock codeLock, BasePlayer rpcPlayer)",
    "MethodSignature": "TryLock(RPCMessage rpc)",
    "MethodSourseCode": "\r\n\t[RPC_Server]\r\n\t[RPC_Server.MaxDistance(3f)]\r\n\tprivate void TryLock(RPCMessage rpc)\r\n\t{\r\n\t\tif (rpc.player.CanInteract() \u0026\u0026 !IsLocked() \u0026\u0026 code.Length == 4 \u0026\u0026 Interface.CallHook(\u0022CanLock\u0022, this, rpc.player) == null \u0026\u0026 whitelistPlayers.Contains(rpc.player.userID))\r\n\t\t{\r\n\t\t\tDoEffect(effectLocked.resourcePath);\r\n\t\t\tSetFlag(Flags.Locked, b: true);\r\n\t\t\tSendNetworkUpdate();\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "CodeLock",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnPlayerViolation(BasePlayer ply, AntiHackType type, float amount)",
    "MethodSignature": "AddViolation(BasePlayer ply, AntiHackType type, float amount)",
    "MethodSourseCode": "\r\n\tpublic static void AddViolation(BasePlayer ply, AntiHackType type, float amount)\r\n\t{\r\n\t\tif (Interface.CallHook(\u0022OnPlayerViolation\u0022, ply, type, amount) == null)\r\n\t\t{\r\n\t\t\tply.lastViolationType = type;\r\n\t\t\tply.lastViolationTime = UnityEngine.Time.realtimeSinceStartup;\r\n\t\t\tply.violationLevel \u002B= amount;\r\n\t\t\tif ((ConVar.AntiHack.debuglevel \u003E= 2 \u0026\u0026 amount \u003E 0f) || ConVar.AntiHack.debuglevel \u003E= 3)\r\n\t\t\t{\r\n\t\t\t\tLogToConsole(ply, type, \u0022Added violation of \u0022 \u002B amount \u002B \u0022 in frame \u0022 \u002B UnityEngine.Time.frameCount \u002B \u0022 (now has \u0022 \u002B ply.violationLevel \u002B \u0022)\u0022);\r\n\t\t\t}\r\n\t\t\tEnforceViolations(ply);\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "AntiHack",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnItemResearchStart(ResearchTable researchTable)",
    "MethodSignature": "DoResearch(RPCMessage msg)",
    "MethodSourseCode": "\r\n\t[RPC_Server]\r\n\tpublic void DoResearch(RPCMessage msg)\r\n\t{\r\n\t\tif (IsResearching())\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tBasePlayer player = msg.player;\r\n\t\tItem targetItem = GetTargetItem();\r\n\t\tif (targetItem != null \u0026\u0026 Interface.CallHook(\u0022OnItemResearch\u0022, targetItem, player) == null \u0026\u0026 targetItem.amount \u003C= 1 \u0026\u0026 IsItemResearchable(targetItem))\r\n\t\t{\r\n\t\t\tInterface.CallHook(\u0022OnItemResearchStart\u0022, this);\r\n\t\t\ttargetItem.CollectedForCrafting(player);\r\n\t\t\tresearchFinishedTime = UnityEngine.Time.realtimeSinceStartup \u002B researchDuration;\r\n\t\t\tInvoke(ResearchAttemptFinished, researchDuration);\r\n\t\t\tinventory.SetLocked(isLocked: true);\r\n\t\t\tSetFlag(Flags.On, b: true);\r\n\t\t\tSendNetworkUpdate();\r\n\t\t\tplayer.inventory.loot.SendImmediate();\r\n\t\t\tif (researchStartEffect.isValid)\r\n\t\t\t{\r\n\t\t\t\tEffect.server.Run(researchStartEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "ResearchTable",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "OnRconConnection(System.Net.IPEndPoint iPEndPoint)",
    "MethodSignature": "ProcessConnections()",
    "MethodSourseCode": "\r\n\t\tprivate void ProcessConnections()\r\n\t\t{\r\n\t\t\tif (!server.Pending())\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tSocket socket = server.AcceptSocket();\r\n\t\t\tif (socket != null)\r\n\t\t\t{\r\n\t\t\t\tIPEndPoint iPEndPoint = socket.RemoteEndPoint as IPEndPoint;\r\n\t\t\t\tif (Interface.CallHook(\u0022OnRconConnection\u0022, iPEndPoint) != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tsocket.Close();\r\n\t\t\t\t}\r\n\t\t\t\telse if (IsBanned(iPEndPoint.Address))\r\n\t\t\t\t{\r\n\t\t\t\t\tDebug.Log(\u0022[RCON] Ignoring connection - banned. \u0022 \u002B iPEndPoint.Address.ToString());\r\n\t\t\t\t\tsocket.Close();\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tclients.Add(new RConClient(socket));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n",
    "ClassName": "RCon",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "CanHelicopterStrafe(PatrolHelicopterAI patrolHelicopterAI)",
    "MethodSignature": "CanStrafe()",
    "MethodSourseCode": "\r\n\tpublic bool CanStrafe()\r\n\t{\r\n\t\tobject obj = Interface.CallHook(\u0022CanHelicopterStrafe\u0022, this);\r\n\t\tif (obj is bool)\r\n\t\t{\r\n\t\t\treturn (bool)obj;\r\n\t\t}\r\n\t\treturn UnityEngine.Time.realtimeSinceStartup - lastStrafeTime \u003E= 20f \u0026\u0026 CanInterruptState();\r\n\t}\r\n",
    "ClassName": "PatrolHelicopterAI",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnItemResearchEnd(ResearchTable researchTable, float num)",
    "MethodSignature": "ResearchAttemptFinished()",
    "MethodSourseCode": "\r\n\tpublic void ResearchAttemptFinished()\r\n\t{\r\n\t\tItem targetItem = GetTargetItem();\r\n\t\tItem scrapItem = GetScrapItem();\r\n\t\tif (targetItem != null)\r\n\t\t{\r\n\t\t\tfloat num = UnityEngine.Random.Range(0f, 1f);\r\n\t\t\tobject obj = Interface.CallHook(\u0022OnItemResearchEnd\u0022, this, num);\r\n\t\t\tif (obj is float)\r\n\t\t\t{\r\n\t\t\t\tnum = (float)obj;\r\n\t\t\t}\r\n\t\t\tint num2 = ScrapForFullChance(targetItem);\r\n\t\t\tif (num \u003C= GetSuccessChance(targetItem, inventory.GetSlot(1)))\r\n\t\t\t{\r\n\t\t\t\tint iAmount = 1;\r\n\t\t\t\tItem item = ItemManager.Create(targetItem.info, iAmount, 0uL);\r\n\t\t\t\tif (!item.MoveToContainer(inventory, 0))\r\n\t\t\t\t{\r\n\t\t\t\t\titem.Drop(GetDropPosition(), GetDropVelocity());\r\n\t\t\t\t}\r\n\t\t\t\tif (researchSuccessEffect.isValid)\r\n\t\t\t\t{\r\n\t\t\t\t\tEffect.server.Run(researchSuccessEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (researchFailEffect.isValid)\r\n\t\t\t{\r\n\t\t\t\tEffect.server.Run(researchFailEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);\r\n\t\t\t}\r\n\t\t\tif (scrapItem != null)\r\n\t\t\t{\r\n\t\t\t\tif (scrapItem.amount \u003C= num2)\r\n\t\t\t\t{\r\n\t\t\t\t\tinventory.Remove(scrapItem);\r\n\t\t\t\t\tscrapItem.RemoveFromContainer();\r\n\t\t\t\t\tscrapItem.Remove();\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tscrapItem.UseItem(num2);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tSendNetworkUpdateImmediate();\r\n\t\tif (user != null)\r\n\t\t{\r\n\t\t\tuser.inventory.loot.SendImmediate();\r\n\t\t}\r\n\t\tEndResearch();\r\n\t}\r\n",
    "ClassName": "ResearchTable",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "CanAcceptItem(ItemContainer itemContainer, Item item)",
    "MethodSignature": "CanAcceptItem(Item item)",
    "MethodSourseCode": "\r\n\tpublic CanAcceptResult CanAcceptItem(Item item)\r\n\t{\r\n\t\tif (canAcceptItem != null \u0026\u0026 !canAcceptItem(item))\r\n\t\t{\r\n\t\t\treturn CanAcceptResult.CannotAccept;\r\n\t\t}\r\n\t\tif ((allowedContents \u0026 item.info.itemType) != item.info.itemType)\r\n\t\t{\r\n\t\t\treturn CanAcceptResult.CannotAccept;\r\n\t\t}\r\n\t\tif (onlyAllowedItem != null \u0026\u0026 onlyAllowedItem != item.info)\r\n\t\t{\r\n\t\t\treturn CanAcceptResult.CannotAccept;\r\n\t\t}\r\n\t\tif (availableSlots != null \u0026\u0026 availableSlots.Count \u003E 0)\r\n\t\t{\r\n\t\t\tif (item.info.occupySlots == (ItemSlot)0 || item.info.occupySlots == ItemSlot.None)\r\n\t\t\t{\r\n\t\t\t\treturn CanAcceptResult.CannotAccept;\r\n\t\t\t}\r\n\t\t\tint[] array = new int[32];\r\n\t\t\tforeach (ItemSlot availableSlot in availableSlots)\r\n\t\t\t{\r\n\t\t\t\tarray[(int)Mathf.Log((float)availableSlot, 2f)]\u002B\u002B;\r\n\t\t\t}\r\n\t\t\tforeach (Item item2 in itemList)\r\n\t\t\t{\r\n\t\t\t\tfor (int i = 0; i \u003C 32; i\u002B\u002B)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (((uint)item2.info.occupySlots \u0026 (uint)(1 \u003C\u003C i)) != 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tarray[i]--;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor (int j = 0; j \u003C 32; j\u002B\u002B)\r\n\t\t\t{\r\n\t\t\t\tif (((uint)item.info.occupySlots \u0026 (uint)(1 \u003C\u003C j)) != 0 \u0026\u0026 array[j] \u003C= 0)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn CanAcceptResult.CannotAcceptRightNow;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tobject obj = Interface.CallHook(\u0022CanAcceptItem\u0022, this, item);\r\n\t\tif (obj is CanAcceptResult)\r\n\t\t{\r\n\t\t\treturn (CanAcceptResult)obj;\r\n\t\t}\r\n\t\treturn CanAcceptResult.CanAccept;\r\n\t}\r\n",
    "ClassName": "ItemContainer",
    "HookLineInvoke": 44
  },
  {
    "HookSignature": "IOnRconInitialize()",
    "MethodSignature": "Initialize()",
    "MethodSourseCode": "\r\n\tpublic static void Initialize()\r\n\t{\r\n\t\tif (Interface.CallHook(\u0022IOnRconInitialize\u0022, null) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (Port == 0)\r\n\t\t{\r\n\t\t\tPort = Server.port;\r\n\t\t}\r\n\t\tPassword = CommandLine.GetSwitch(\u0022-rcon.password\u0022, CommandLine.GetSwitch(\u0022\u002Brcon.password\u0022, string.Empty));\r\n\t\tif (Password == \u0022password\u0022 || Password == string.Empty)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tOutput.OnMessage \u002B= OnMessage;\r\n\t\tif (Web)\r\n\t\t{\r\n\t\t\tlistenerNew = new Listener();\r\n\t\t\tif (!string.IsNullOrEmpty(Ip))\r\n\t\t\t{\r\n\t\t\t\tlistenerNew.Address = Ip;\r\n\t\t\t}\r\n\t\t\tlistenerNew.Password = Password;\r\n\t\t\tlistenerNew.Port = Port;\r\n\t\t\tlistenerNew.SslCertificate = CommandLine.GetSwitch(\u0022-rcon.ssl\u0022, null);\r\n\t\t\tlistenerNew.SslCertificatePassword = CommandLine.GetSwitch(\u0022-rcon.sslpwd\u0022, null);\r\n\t\t\tlistenerNew.OnMessage = delegate(IPEndPoint ip, string id, string msg)\r\n\t\t\t{\r\n\t\t\t\tlock (Commands)\r\n\t\t\t\t{\r\n\t\t\t\t\tCommand item = JsonConvert.DeserializeObject\u003CCommand\u003E(msg);\r\n\t\t\t\t\titem.Ip = ip;\r\n\t\t\t\t\titem.ConnectionId = id;\r\n\t\t\t\t\tCommands.Enqueue(item);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\tlistenerNew.Start();\r\n\t\t\tDebug.Log(\u0022WebSocket RCon Started on \u0022 \u002B Port);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tlistener = new RConListener();\r\n\t\t\tDebug.Log(\u0022RCon Started on \u0022 \u002B Port);\r\n\t\t\tDebug.Log(\u0022Source style TCP Rcon is deprecated. Please switch to Websocket Rcon before it goes away.\u0022);\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "RCon",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnLootEntityEnd(BasePlayer player, StorageContainer storageContainer)",
    "MethodSignature": "PlayerStoppedLooting(BasePlayer player)",
    "MethodSourseCode": "\r\n\tpublic virtual void PlayerStoppedLooting(BasePlayer player)\r\n\t{\r\n\t\tInterface.CallHook(\u0022OnLootEntityEnd\u0022, player, this);\r\n\t\tSetFlag(Flags.Open, b: false);\r\n\t\tSendNetworkUpdate();\r\n\t}\r\n",
    "ClassName": "StorageContainer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "IOnServerUsersSet(ulong iUID, ServerUsers.UserGroup group, string username, string notes)",
    "MethodSignature": "Set(ulong iUID, UserGroup group, string username, string notes)",
    "MethodSourseCode": "\r\n\tpublic static void Set(ulong iUID, UserGroup group, string username, string notes)\r\n\t{\r\n\t\tInterface.CallHook(\u0022IOnServerUsersSet\u0022, iUID, group, username, notes);\r\n\t\tulong iUID2 = iUID;\r\n\t\tusers.RemoveAll((User x) =\u003E x.steamid == iUID2);\r\n\t\tUser user = new User();\r\n\t\tuser.steamid = iUID2;\r\n\t\tuser.group = group;\r\n\t\tuser.username = username;\r\n\t\tuser.notes = notes;\r\n\t\tusers.Add(user);\r\n\t}\r\n",
    "ClassName": "ServerUsers",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnExplosiveDropped(BasePlayer msgPlayer, BaseEntity baseEntity)",
    "MethodSignature": "DoDrop(RPCMessage msg)",
    "MethodSourseCode": "\r\n\t[RPC_Server]\r\n\t[RPC_Server.IsActiveItem]\r\n\tprivate void DoDrop(RPCMessage msg)\r\n\t{\r\n\t\tif (!HasItemAmount() || HasAttackCooldown())\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tVector3 vector = msg.read.Vector3();\r\n\t\tVector3 normalized = msg.read.Vector3().normalized;\r\n\t\tif (!ValidateEyePos(msg.player, vector))\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(prefabToThrow.resourcePath, vector, Quaternion.LookRotation(Vector3.up));\r\n\t\tif (baseEntity == null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (UnityEngine.Physics.SphereCast(new Ray(vector, normalized), 0.05f, out var hitInfo, 1.5f, 1101212417))\r\n\t\t{\r\n\t\t\tVector3 point = hitInfo.point;\r\n\t\t\tVector3 normal = hitInfo.normal;\r\n\t\t\tBaseEntity entity = RaycastHitEx.GetEntity(hitInfo);\r\n\t\t\tif ((bool)entity \u0026\u0026 entity is StabilityEntity \u0026\u0026 baseEntity is TimedExplosive)\r\n\t\t\t{\r\n\t\t\t\tentity = entity.ToServer\u003CBaseEntity\u003E();\r\n\t\t\t\tTimedExplosive timedExplosive = baseEntity as TimedExplosive;\r\n\t\t\t\ttimedExplosive.onlyDamageParent = true;\r\n\t\t\t\ttimedExplosive.DoStick(point, normal, entity);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tbaseEntity.SetVelocity(normalized);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tbaseEntity.SetVelocity(normalized);\r\n\t\t}\r\n\t\tbaseEntity.creatorEntity = msg.player;\r\n\t\tbaseEntity.Spawn();\r\n\t\tInterface.CallHook(\u0022OnExplosiveDropped\u0022, msg.player, baseEntity);\r\n\t\tStartAttackCooldown(repeatDelay);\r\n\t\tUseItemAmount(1);\r\n\t}\r\n",
    "ClassName": "ThrownWeapon",
    "HookLineInvoke": 43
  },
  {
    "HookSignature": "OnFindBurnable(BaseOven baseOven)",
    "MethodSignature": "FindBurnable()",
    "MethodSourseCode": "\r\n\tprivate Item FindBurnable()\r\n\t{\r\n\t\tobject obj = Interface.CallHook(\u0022OnFindBurnable\u0022, this);\r\n\t\tif (obj is Item)\r\n\t\t{\r\n\t\t\treturn (Item)obj;\r\n\t\t}\r\n\t\tif (inventory == null)\r\n\t\t{\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tforeach (Item item in inventory.itemList)\r\n\t\t{\r\n\t\t\tItemModBurnable component = item.info.GetComponent\u003CItemModBurnable\u003E();\r\n\t\t\tif ((bool)component \u0026\u0026 (fuelType == null || item.info == fuelType))\r\n\t\t\t{\r\n\t\t\t\treturn item;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n",
    "ClassName": "BaseOven",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnContainerDropItems(ItemContainer container)",
    "MethodSignature": "DropItems(ItemContainer container, Vector3 position, float chance)",
    "MethodSourseCode": "\tpublic static void DropItems(ItemContainer container, Vector3 position, float chance = 1f)\r\n\t{\r\n\t\tif (!Server.dropitems || container == null || container.itemList == null || Interface.CallHook(\u0022OnContainerDropItems\u0022, container) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tfloat num = 0.25f;\r\n\t\tItem[] array = container.itemList.ToArray();\r\n\t\tforeach (Item item in array)\r\n\t\t{\r\n\t\t\tif (!(UnityEngine.Random.Range(0f, 1f) \u003E chance))\r\n\t\t\t{\r\n\t\t\t\tfloat num2 = UnityEngine.Random.Range(0f, 2f);\r\n\t\t\t\titem.RemoveFromContainer();\r\n\t\t\t\tBaseEntity baseEntity = item.CreateWorldObject(position \u002B new Vector3(UnityEngine.Random.Range(0f - num, num), 1f, UnityEngine.Random.Range(0f - num, num)));\r\n\t\t\t\tif (baseEntity == null)\r\n\t\t\t\t{\r\n\t\t\t\t\titem.Remove();\r\n\t\t\t\t}\r\n\t\t\t\telse if (num2 \u003E 0f)\r\n\t\t\t\t{\r\n\t\t\t\t\tbaseEntity.SetVelocity(new Vector3(UnityEngine.Random.Range(-1f, 1f), UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(-1f, 1f)) * num2);\r\n\t\t\t\t\tbaseEntity.SetAngularVelocity(new Vector3(UnityEngine.Random.Range(-10f, 10f), UnityEngine.Random.Range(-10f, 10f), UnityEngine.Random.Range(-10f, 10f)) * num2);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "DropUtil",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnRecycleItem(Recycler recycler, Item slot)",
    "MethodSignature": "RecycleThink()",
    "MethodSourseCode": "\r\n\tpublic void RecycleThink()\r\n\t{\r\n\t\tbool flag = false;\r\n\t\tfloat num = recycleEfficiency;\r\n\t\tfor (int i = 0; i \u003C 6; i\u002B\u002B)\r\n\t\t{\r\n\t\t\tItem slot = inventory.GetSlot(i);\r\n\t\t\tif (slot == null)\r\n\t\t\t{\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif (Interface.CallHook(\u0022OnRecycleItem\u0022, this, slot) != null)\r\n\t\t\t{\r\n\t\t\t\tif (!HasRecyclable())\r\n\t\t\t\t{\r\n\t\t\t\t\tStopRecycling();\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tif (!(slot.info.Blueprint != null))\r\n\t\t\t{\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif (slot.hasCondition)\r\n\t\t\t{\r\n\t\t\t\tnum = Mathf.Clamp01(num * slot.conditionNormalized * slot.maxConditionNormalized);\r\n\t\t\t}\r\n\t\t\tint num2 = 1;\r\n\t\t\tif (slot.amount \u003E 1)\r\n\t\t\t{\r\n\t\t\t\tnum2 = Mathf.CeilToInt(Mathf.Min(slot.amount, (float)slot.info.stackable * 0.1f));\r\n\t\t\t}\r\n\t\t\tif (slot.info.Blueprint.scrapFromRecycle \u003E 0)\r\n\t\t\t{\r\n\t\t\t\tItem newItem = ItemManager.CreateByName(\u0022scrap\u0022, slot.info.Blueprint.scrapFromRecycle * num2, 0uL);\r\n\t\t\t\tMoveItemToOutput(newItem);\r\n\t\t\t}\r\n\t\t\tslot.UseItem(num2);\r\n\t\t\tforeach (ItemAmount ingredient in slot.info.Blueprint.ingredients)\r\n\t\t\t{\r\n\t\t\t\tfloat num3 = ingredient.amount / (float)slot.info.Blueprint.amountToCreate;\r\n\t\t\t\tint num4 = 0;\r\n\t\t\t\tif (num3 \u003C= 1f)\r\n\t\t\t\t{\r\n\t\t\t\t\tfor (int j = 0; j \u003C num2; j\u002B\u002B)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (UnityEngine.Random.Range(0f, 1f) \u003C= num)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tnum4\u002B\u002B;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tnum4 = Mathf.CeilToInt(Mathf.Clamp(num3 * num * UnityEngine.Random.Range(1f, 1f), 1f, ingredient.amount) * (float)num2);\r\n\t\t\t\t}\r\n\t\t\t\tif (num4 \u003C= 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tint num5 = Mathf.CeilToInt((float)num4 / (float)ingredient.itemDef.stackable);\r\n\t\t\t\tfor (int k = 0; k \u003C num5; k\u002B\u002B)\r\n\t\t\t\t{\r\n\t\t\t\t\tint num6 = ((num4 \u003C= ingredient.itemDef.stackable) ? num4 : ingredient.itemDef.stackable);\r\n\t\t\t\t\tItem newItem2 = ItemManager.Create(ingredient.itemDef, num6, 0uL);\r\n\t\t\t\t\tif (!MoveItemToOutput(newItem2))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tflag = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnum4 -= num6;\r\n\t\t\t\t\tif (num4 \u003C= 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tif (flag || !HasRecyclable())\r\n\t\t{\r\n\t\t\tStopRecycling();\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "Recycler",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "OnClientAuth(Network.Connection packetConnection)",
    "MethodSignature": "OnGiveUserInformation(Message packet)",
    "MethodSourseCode": "\r\n\tprivate void OnGiveUserInformation(Message packet)\r\n\t{\r\n\t\tif (packet.connection.state != 0)\r\n\t\t{\r\n\t\t\tNetwork.Net.sv.Kick(packet.connection, \u0022Invalid connection state\u0022);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tpacket.connection.state = Connection.State.Connecting;\r\n\t\tbyte b = packet.read.UInt8();\r\n\t\tif (b != 228)\r\n\t\t{\r\n\t\t\tNetwork.Net.sv.Kick(packet.connection, \u0022Invalid Connection Protocol\u0022);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tpacket.connection.userid = packet.read.UInt64();\r\n\t\tpacket.connection.protocol = packet.read.UInt32();\r\n\t\tpacket.connection.os = packet.read.String();\r\n\t\tpacket.connection.username = packet.read.String();\r\n\t\tInterface.CallHook(\u0022OnClientAuth\u0022, packet.connection);\r\n\t\tif (string.IsNullOrEmpty(packet.connection.os))\r\n\t\t{\r\n\t\t\tthrow new Exception(\u0022Invalid OS\u0022);\r\n\t\t}\r\n\t\tif (string.IsNullOrEmpty(packet.connection.username))\r\n\t\t{\r\n\t\t\tNetwork.Net.sv.Kick(packet.connection, \u0022Invalid Username\u0022);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tpacket.connection.username = packet.connection.username.Replace(\u0027\\n\u0027, \u0027 \u0027).Replace(\u0027\\r\u0027, \u0027 \u0027).Replace(\u0027\\t\u0027, \u0027 \u0027)\r\n\t\t\t.Trim();\r\n\t\tif (string.IsNullOrEmpty(packet.connection.username))\r\n\t\t{\r\n\t\t\tNetwork.Net.sv.Kick(packet.connection, \u0022Invalid Username\u0022);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tstring text = string.Empty;\r\n\t\tstring branch = ConVar.Server.branch;\r\n\t\tif (packet.read.unread \u003E= 4)\r\n\t\t{\r\n\t\t\ttext = packet.read.String();\r\n\t\t}\r\n\t\tif (branch != string.Empty \u0026\u0026 branch != text)\r\n\t\t{\r\n\t\t\tUnityEngine.Debug.Log(string.Concat(\u0022Kicking \u0022, packet.connection, \u0022 - their branch is \u0027\u0022, text, \u0022\u0027 not \u0027\u0022, branch, \u0022\u0027\u0022));\r\n\t\t\tNetwork.Net.sv.Kick(packet.connection, \u0022Wrong Steam Beta: Requires \u0027\u0022 \u002B branch \u002B \u0022\u0027 branch!\u0022);\r\n\t\t}\r\n\t\telse if (packet.connection.protocol \u003E 2013)\r\n\t\t{\r\n\t\t\tUnityEngine.Debug.Log(string.Concat(\u0022Kicking \u0022, packet.connection, \u0022 - their protocol is \u0022, packet.connection.protocol, \u0022 not \u0022, 2013));\r\n\t\t\tNetwork.Net.sv.Kick(packet.connection, \u0022Wrong Connection Protocol: Server update required!\u0022);\r\n\t\t}\r\n\t\telse if (packet.connection.protocol \u003C 2013)\r\n\t\t{\r\n\t\t\tUnityEngine.Debug.Log(string.Concat(\u0022Kicking \u0022, packet.connection, \u0022 - their protocol is \u0022, packet.connection.protocol, \u0022 not \u0022, 2013));\r\n\t\t\tNetwork.Net.sv.Kick(packet.connection, \u0022Wrong Connection Protocol: Client update required!\u0022);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tpacket.connection.token = packet.read.BytesWithSize();\r\n\t\t\tif (packet.connection.token == null || packet.connection.token.Length \u003C 1)\r\n\t\t\t{\r\n\t\t\t\tNetwork.Net.sv.Kick(packet.connection, \u0022Invalid Token\u0022);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tauth.OnNewConnection(packet.connection);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "ServerMgr",
    "HookLineInvoke": 19
  },
  {
    "HookSignature": "OnItemPickup(Item item, BasePlayer msgPlayer)",
    "MethodSignature": "Pickup(RPCMessage msg)",
    "MethodSourseCode": "\r\n\t[RPC_Server]\r\n\t[RPC_Server.MaxDistance(3f)]\r\n\tpublic void Pickup(RPCMessage msg)\r\n\t{\r\n\t\tif (msg.player.CanInteract() \u0026\u0026 item != null \u0026\u0026 allowPickup \u0026\u0026 Interface.CallHook(\u0022OnItemPickup\u0022, item, msg.player) == null)\r\n\t\t{\r\n\t\t\tClientRPC(null, \u0022PickupSound\u0022);\r\n\t\t\tmsg.player.GiveItem(item, GiveItemReason.PickedUp);\r\n\t\t\tmsg.player.SignalBroadcast(Signal.Gesture, \u0022pickup_item\u0022);\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "WorldItem",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnPlayerInit(BasePlayer basePlayer)",
    "MethodSignature": "PlayerInit(Connection c)",
    "MethodSourseCode": "\r\n\tpublic void PlayerInit(Connection c)\r\n\t{\r\n\t\tusing (TimeWarning.New(\u0022PlayerInit\u0022, 10L))\r\n\t\t{\r\n\t\t\tCancelInvoke(base.KillMessage);\r\n\t\t\tSetPlayerFlag(PlayerFlags.Connected, b: true);\r\n\t\t\tactivePlayerList.Add(this);\r\n\t\t\tuserID = c.userid;\r\n\t\t\tUserIDString = userID.ToString();\r\n\t\t\t_displayName = StringEx.ToPrintable(c.username, 32);\r\n\t\t\tc.player = this;\r\n\t\t\ttickInterpolator.Reset(base.transform.position);\r\n\t\t\tlastTickTime = 0f;\r\n\t\t\tlastInputTime = 0f;\r\n\t\t\tSetPlayerFlag(PlayerFlags.ReceivingSnapshot, b: true);\r\n\t\t\tstats.Init();\r\n\t\t\tpreviousLifeStory = SingletonComponent\u003CServerMgr\u003E.Instance.persistance.GetLastLifeStory(userID);\r\n\t\t\tSetPlayerFlag(PlayerFlags.IsAdmin, c.authLevel \u003E 0);\r\n\t\t\tSetPlayerFlag(PlayerFlags.IsDeveloper, DeveloperList.IsDeveloper(this));\r\n\t\t\tif (IsDead() \u0026\u0026 net.SwitchGroup(BaseNetworkable.LimboNetworkGroup))\r\n\t\t\t{\r\n\t\t\t\tSendNetworkGroupChange();\r\n\t\t\t}\r\n\t\t\tnet.OnConnected(c);\r\n\t\t\tnet.StartSubscriber();\r\n\t\t\tSendAsSnapshot(net.connection);\r\n\t\t\tClientRPCPlayer(null, this, \u0022StartLoading\u0022);\r\n\t\t\tInterface.CallHook(\u0022OnPlayerInit\u0022, this);\r\n\t\t\tif (net != null)\r\n\t\t\t{\r\n\t\t\t\tEACServer.OnStartLoading(net.connection);\r\n\t\t\t}\r\n\t\t\tSendGlobalSnapshot();\r\n\t\t\tSendFullSnapshot();\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 28
  },
  {
    "HookSignature": "IOnLootPlayer(PlayerLoot playerLoot, BasePlayer player)",
    "MethodSignature": "StartLootingPlayer(BasePlayer player)",
    "MethodSourseCode": "\r\n\tpublic void StartLootingPlayer(BasePlayer player)\r\n\t{\r\n\t\tClear();\r\n\t\tif ((bool)player \u0026\u0026 (bool)player.inventory)\r\n\t\t{\r\n\t\t\tAddContainer(player.inventory.containerWear);\r\n\t\t\tAddContainer(player.inventory.containerMain);\r\n\t\t\tAddContainer(player.inventory.containerBelt);\r\n\t\t\tPositionChecks = true;\r\n\t\t\tentitySource = player;\r\n\t\t\titemSource = null;\r\n\t\t\tMarkDirty();\r\n\t\t\tInterface.CallHook(\u0022IOnLootPlayer\u0022, this, player);\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "PlayerLoot",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "OnBuyVendingItem(VendingMachine vendingMachine, BasePlayer rpcPlayer, int num, int num2)",
    "MethodSignature": "BuyItem(RPCMessage rpc)",
    "MethodSourseCode": "\r\n\t[RPC_Server.IsVisible(3f)]\r\n\t[RPC_Server]\r\n\tpublic void BuyItem(RPCMessage rpc)\r\n\t{\r\n\t\tint num = rpc.read.Int32();\r\n\t\tint num2 = rpc.read.Int32();\r\n\t\tInterface.CallHook(\u0022OnBuyVendingItem\u0022, this, rpc.player, num, num2);\r\n\t\tSetPendingOrder(rpc.player, num, num2);\r\n\t\tInvoke(CompletePendingOrder, 2.5f);\r\n\t}\r\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "CanHideStash(StashContainer stashContainer, BasePlayer rpcPlayer)",
    "MethodSignature": "RPC_HideStash(RPCMessage rpc)",
    "MethodSourseCode": "\r\n\t[RPC_Server]\r\n\tpublic void RPC_HideStash(RPCMessage rpc)\r\n\t{\r\n\t\tif (Interface.CallHook(\u0022CanHideStash\u0022, this, rpc.player) == null)\r\n\t\t{\r\n\t\t\tSetHidden(isHidden: true);\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "StashContainer",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnTrapTrigger(Landmine landmine, UnityEngine.GameObject obj)",
    "MethodSignature": "ObjectEntered(GameObject obj)",
    "MethodSourseCode": "\r\n\tpublic override void ObjectEntered(GameObject obj)\r\n\t{\r\n\t\tif (!base.isClient)\r\n\t\t{\r\n\t\t\tif (!Armed())\r\n\t\t\t{\r\n\t\t\t\tCancelInvoke(Arm);\r\n\t\t\t\tblocked = true;\r\n\t\t\t}\r\n\t\t\telse if (Interface.CallHook(\u0022OnTrapTrigger\u0022, this, obj) == null)\r\n\t\t\t{\r\n\t\t\t\tBasePlayer ply = GameObjectEx.ToBaseEntity(obj) as BasePlayer;\r\n\t\t\t\tTrigger(ply);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "Landmine",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnItemDropped(Item item, BaseEntity baseEntity)",
    "MethodSignature": "Drop(Vector3 vPos, Vector3 vVelocity, Quaternion rotation)",
    "MethodSourseCode": "\r\n\tpublic BaseEntity Drop(Vector3 vPos, Vector3 vVelocity, Quaternion rotation = default(Quaternion))\r\n\t{\r\n\t\tRemoveFromWorld();\r\n\t\tBaseEntity baseEntity = null;\r\n\t\tif (vPos != Vector3.zero \u0026\u0026 !info.HasFlag(ItemDefinition.Flag.NoDropping))\r\n\t\t{\r\n\t\t\tbaseEntity = CreateWorldObject(vPos, rotation);\r\n\t\t\tif ((bool)baseEntity)\r\n\t\t\t{\r\n\t\t\t\tbaseEntity.SetVelocity(vVelocity);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tRemove();\r\n\t\t}\r\n\t\tRemoveFromContainer();\r\n\t\tInterface.CallHook(\u0022OnItemDropped\u0022, this, baseEntity);\r\n\t\treturn baseEntity;\r\n\t}\r\n",
    "ClassName": "Item",
    "HookLineInvoke": 18
  },
  {
    "HookSignature": "IOnServerCommand(ConsoleSystem.Arg arg)",
    "MethodSignature": "Internal(Arg arg)",
    "MethodSourseCode": "\r\n\tprivate static bool Internal(Arg arg)\r\n\t{\r\n\t\tif (arg.Invalid)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tobject obj = Interface.CallHook(\u0022IOnServerCommand\u0022, arg);\r\n\t\tif (obj is bool)\r\n\t\t{\r\n\t\t\treturn (bool)obj;\r\n\t\t}\r\n\t\tif (!arg.HasPermission())\r\n\t\t{\r\n\t\t\targ.ReplyWith(\u0022You cannot run this command\u0022);\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\ttry\r\n\t\t{\r\n\t\t\tusing (TimeWarning.New(\u0022ConsoleSystem: \u0022 \u002B arg.cmd.FullName))\r\n\t\t\t{\r\n\t\t\t\targ.cmd.Call(arg);\r\n\t\t\t}\r\n\t\t}\r\n\t\tcatch (Exception ex)\r\n\t\t{\r\n\t\t\targ.ReplyWith(\u0022Error: \u0022 \u002B arg.cmd.FullName \u002B \u0022 - \u0022 \u002B ex.Message \u002B \u0022 (\u0022 \u002B ex.Source \u002B \u0022)\u0022);\r\n\t\t\tDebug.LogException(ex);\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (arg.cmd.Variable \u0026\u0026 arg.cmd.GetOveride != null)\r\n\t\t{\r\n\t\t\tstring @string = arg.cmd.String;\r\n\t\t\tstring text = (arg.cmd.Variable ? arg.cmd.String : \u0022\u0022);\r\n\t\t\tif (text != @string)\r\n\t\t\t{\r\n\t\t\t\targ.ReplyWith($\u0022{arg.cmd.FullName}: changed from {Facepunch.Extend.StringExtensions.QuoteSafe(text)} to {Facepunch.Extend.StringExtensions.QuoteSafe(@string)}\u0022);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\targ.ReplyWith($\u0022{arg.cmd.FullName}: {Facepunch.Extend.StringExtensions.QuoteSafe(@string)}\u0022);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n",
    "ClassName": "ConsoleSystem",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "IOnRunCommandLine()",
    "MethodSignature": "UpdateValuesFromCommandLine()",
    "MethodSourseCode": "\r\n\tpublic static void UpdateValuesFromCommandLine()\r\n\t{\r\n\t\tif (Interface.CallHook(\u0022IOnRunCommandLine\u0022, null) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tforeach (KeyValuePair\u003Cstring, string\u003E @switch in Facepunch.CommandLine.GetSwitches())\r\n\t\t{\r\n\t\t\tstring text = @switch.Value;\r\n\t\t\tif (text == \u0022\u0022)\r\n\t\t\t{\r\n\t\t\t\ttext = \u00221\u0022;\r\n\t\t\t}\r\n\t\t\tstring strCommand = @switch.Key.Substring(1);\r\n\t\t\tRun(Option.Unrestricted, strCommand, text);\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "ConsoleSystem",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "Loaded()",
    "MethodSignature": "HandleAddedToManager(PluginManager manager)",
    "MethodSourseCode": "\r\n\tpublic override void HandleAddedToManager(PluginManager manager)\r\n\t{\r\n\t\tbase.HandleAddedToManager(manager);\r\n\t\tif (base.Filename != null)\r\n\t\t{\r\n\t\t\tWatcher.AddMapping(base.Name);\r\n\t\t}\r\n\t\tforeach (string key in pluginReferenceFields.Keys)\r\n\t\t{\r\n\t\t\tpluginReferenceFields[key].SetValue(this, manager.GetPlugin(key));\r\n\t\t}\r\n\t\ttry\r\n\t\t{\r\n\t\t\tOnCallHook(\u0022Loaded\u0022, null);\r\n\t\t}\r\n\t\tcatch (Exception ex)\r\n\t\t{\r\n\t\t\tInterface.Oxide.LogException($\u0022Failed to initialize plugin \u0027{base.Name} v{base.Version}\u0027\u0022, ex);\r\n\t\t\tbase.Loader.PluginErrors[base.Name] = ex.Message;\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "CSharpPlugin",
    "HookLineInvoke": 14
  },
  {
    "HookSignature": "OnFrame(object[] args)",
    "MethodSignature": "OnFrame(float delta)",
    "MethodSourseCode": "\r\n\tprivate void OnFrame(float delta)\r\n\t{\r\n\t\tobject[] args = new object[1] { delta };\r\n\t\tforeach (KeyValuePair\u003Cstring, Plugin\u003E loadedPlugin in loader.LoadedPlugins)\r\n\t\t{\r\n\t\t\tif (loadedPlugin.Value is CSharpPlugin { HookedOnFrame: not false } cSharpPlugin)\r\n\t\t\t{\r\n\t\t\t\tcSharpPlugin.CallHook(\u0022OnFrame\u0022, args);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "CSharpExtension",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "Unload()",
    "MethodSignature": "HandleRemovedFromManager(PluginManager manager)",
    "MethodSourseCode": "\r\n\tpublic override void HandleRemovedFromManager(PluginManager manager)\r\n\t{\r\n\t\tif (base.IsLoaded)\r\n\t\t{\r\n\t\t\tCallHook(\u0022Unload\u0022, null);\r\n\t\t}\r\n\t\tWatcher.RemoveMapping(base.Name);\r\n\t\tforeach (string key in pluginReferenceFields.Keys)\r\n\t\t{\r\n\t\t\tpluginReferenceFields[key].SetValue(this, null);\r\n\t\t}\r\n\t\tbase.HandleRemovedFromManager(manager);\r\n\t}\r\n",
    "ClassName": "CSharpPlugin",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnGroupPermissionGranted(string name, string perm)",
    "MethodSignature": "GrantGroupPermission(string name, string perm, Plugin owner)",
    "MethodSourseCode": "\r\n\t[LibraryFunction(\u0022GrantGroupPermission\u0022)]\r\n\tpublic void GrantGroupPermission(string name, string perm, Plugin owner)\r\n\t{\r\n\t\tif (!PermissionExists(perm, owner) || !GroupExists(name) || !groupdata.TryGetValue(name.ToLower(), out var data))\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tperm = perm.ToLower();\r\n\t\tif (perm.EndsWith(\u0022*\u0022))\r\n\t\t{\r\n\t\t\tHashSet\u003Cstring\u003E value;\r\n\t\t\tif (owner == null)\r\n\t\t\t{\r\n\t\t\t\tvalue = new HashSet\u003Cstring\u003E(permset.Values.SelectMany((HashSet\u003Cstring\u003E v) =\u003E v));\r\n\t\t\t}\r\n\t\t\telse if (!permset.TryGetValue(owner, out value))\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tif (perm.Equals(\u0022*\u0022))\r\n\t\t\t{\r\n\t\t\t\tif (!value.Aggregate(seed: false, (bool c, string s) =\u003E c | data.Perms.Add(s)))\r\n\t\t\t\t{\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tperm = perm.TrimEnd(\u0027*\u0027).ToLower();\r\n\t\t\t\tif (!value.Where((string s) =\u003E s.StartsWith(perm)).Aggregate(seed: false, (bool c, string s) =\u003E c | data.Perms.Add(s)))\r\n\t\t\t\t{\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tSaveGroups();\r\n\t\t}\r\n\t\telse if (data.Perms.Add(perm))\r\n\t\t{\r\n\t\t\tSaveGroups();\r\n\t\t\tInterface.Call(\u0022OnGroupPermissionGranted\u0022, name, perm);\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "Permission",
    "HookLineInvoke": 40
  },
  {
    "HookSignature": "OnPluginLoaded(Oxide.Core.Plugins.Plugin plugin)",
    "MethodSignature": "PluginLoaded(Plugin plugin)",
    "MethodSourseCode": "\r\n\tpublic bool PluginLoaded(Plugin plugin)\r\n\t{\r\n\t\tplugin.OnError \u002B= plugin_OnError;\r\n\t\tLogInfo(\u0022Loaded plugin {0} v{1} by {2}\u0022, plugin.Title, plugin.Version, plugin.Author);\r\n\t\ttry\r\n\t\t{\r\n\t\t\tplugin.Loader?.PluginErrors.Remove(plugin.Name);\r\n\t\t\tRootPluginManager.AddPlugin(plugin);\r\n\t\t\tif (plugin.Loader != null \u0026\u0026 plugin.Loader.PluginErrors.ContainsKey(plugin.Name))\r\n\t\t\t{\r\n\t\t\t\tUnloadPlugin(plugin.Name);\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tplugin.IsLoaded = true;\r\n\t\t\tCallHook(\u0022OnPluginLoaded\u0022, plugin);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tcatch (Exception ex)\r\n\t\t{\r\n\t\t\tif (plugin.Loader != null)\r\n\t\t\t{\r\n\t\t\t\tplugin.Loader.PluginErrors[plugin.Name] = ex.Message;\r\n\t\t\t}\r\n\t\t\tLogException($\u0022Failed to initialize plugin \u0027{plugin.Name} v{plugin.Version}\u0027\u0022, ex);\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "OxideMod",
    "HookLineInvoke": 15
  },
  {
    "HookSignature": "OnUserPermissionRevoked(string id, string perm)",
    "MethodSignature": "RevokeUserPermission(string id, string perm)",
    "MethodSourseCode": "\r\n\t[LibraryFunction(\u0022RevokeUserPermission\u0022)]\r\n\tpublic void RevokeUserPermission(string id, string perm)\r\n\t{\r\n\t\tif (string.IsNullOrEmpty(perm))\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tUserData userData = GetUserData(id);\r\n\t\tperm = perm.ToLower();\r\n\t\tif (perm.EndsWith(\u0022*\u0022))\r\n\t\t{\r\n\t\t\tif (perm.Equals(\u0022*\u0022))\r\n\t\t\t{\r\n\t\t\t\tif (userData.Perms.Count \u003C= 0)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tuserData.Perms.Clear();\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tperm = perm.TrimEnd(\u0027*\u0027);\r\n\t\t\t\tif (userData.Perms.RemoveWhere((string s) =\u003E s.StartsWith(perm)) \u003C= 0)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tSaveUsers();\r\n\t\t}\r\n\t\telse if (userData.Perms.Remove(perm))\r\n\t\t{\r\n\t\t\tSaveUsers();\r\n\t\t\tInterface.Call(\u0022OnUserPermissionRevoked\u0022, id, perm);\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "Permission",
    "HookLineInvoke": 33
  },
  {
    "HookSignature": "Init()",
    "MethodSignature": "HandleAddedToManager(PluginManager manager)",
    "MethodSourseCode": "\r\n\tpublic override void HandleAddedToManager(PluginManager manager)\r\n\t{\r\n\t\tbase.HandleAddedToManager(manager);\r\n\t\tforeach (string key in hooks.Keys)\r\n\t\t{\r\n\t\t\tSubscribe(key);\r\n\t\t}\r\n\t\ttry\r\n\t\t{\r\n\t\t\tOnCallHook(\u0022Init\u0022, null);\r\n\t\t}\r\n\t\tcatch (Exception ex)\r\n\t\t{\r\n\t\t\tInterface.Oxide.LogException($\u0022Failed to initialize plugin \u0027{base.Name} v{base.Version}\u0027\u0022, ex);\r\n\t\t\tif (base.Loader != null)\r\n\t\t\t{\r\n\t\t\t\tbase.Loader.PluginErrors[base.Name] = ex.Message;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "CSPlugin",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnUserGroupAdded(string id, string name)",
    "MethodSignature": "AddUserGroup(string id, string name)",
    "MethodSourseCode": "\r\n\t[LibraryFunction(\u0022AddUserGroup\u0022)]\r\n\tpublic void AddUserGroup(string id, string name)\r\n\t{\r\n\t\tif (GroupExists(name) \u0026\u0026 GetUserData(id).Groups.Add(name.ToLower()))\r\n\t\t{\r\n\t\t\tSaveUsers();\r\n\t\t\tInterface.Call(\u0022OnUserGroupAdded\u0022, id, name);\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "Permission",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnGroupPermissionRevoked(string name, string perm)",
    "MethodSignature": "RevokeGroupPermission(string name, string perm)",
    "MethodSourseCode": "\r\n\t[LibraryFunction(\u0022RevokeGroupPermission\u0022)]\r\n\tpublic void RevokeGroupPermission(string name, string perm)\r\n\t{\r\n\t\tif (!GroupExists(name) || string.IsNullOrEmpty(perm) || !groupdata.TryGetValue(name.ToLower(), out var value))\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tperm = perm.ToLower();\r\n\t\tif (perm.EndsWith(\u0022*\u0022))\r\n\t\t{\r\n\t\t\tif (perm.Equals(\u0022*\u0022))\r\n\t\t\t{\r\n\t\t\t\tif (value.Perms.Count \u003C= 0)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tvalue.Perms.Clear();\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tperm = perm.TrimEnd(\u0027*\u0027).ToLower();\r\n\t\t\t\tif (value.Perms.RemoveWhere((string s) =\u003E s.StartsWith(perm)) \u003C= 0)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tSaveGroups();\r\n\t\t}\r\n\t\telse if (value.Perms.Remove(perm))\r\n\t\t{\r\n\t\t\tSaveGroups();\r\n\t\t\tInterface.Call(\u0022OnGroupPermissionRevoked\u0022, name, perm);\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "Permission",
    "HookLineInvoke": 32
  },
  {
    "HookSignature": "OnUserGroupRemoved(string id, string name)",
    "MethodSignature": "RemoveUserGroup(string id, string name)",
    "MethodSourseCode": "\r\n\t[LibraryFunction(\u0022RemoveUserGroup\u0022)]\r\n\tpublic void RemoveUserGroup(string id, string name)\r\n\t{\r\n\t\tif (!GroupExists(name))\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tUserData userData = GetUserData(id);\r\n\t\tif (name.Equals(\u0022*\u0022))\r\n\t\t{\r\n\t\t\tif (userData.Groups.Count \u003E 0)\r\n\t\t\t{\r\n\t\t\t\tuserData.Groups.Clear();\r\n\t\t\t\tSaveUsers();\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (userData.Groups.Remove(name.ToLower()))\r\n\t\t{\r\n\t\t\tSaveUsers();\r\n\t\t\tInterface.Call(\u0022OnUserGroupRemoved\u0022, id, name);\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "Permission",
    "HookLineInvoke": 20
  },
  {
    "HookSignature": "LoadDefaultMessages()",
    "MethodSignature": "LoadDefaultMessages()",
    "MethodSourseCode": "\r\n\tprotected virtual void LoadDefaultMessages()\r\n\t{\r\n\t\tCallHook(\u0022LoadDefaultMessages\u0022, null);\r\n\t}\r\n",
    "ClassName": "Plugin",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "LoadDefaultConfig()",
    "MethodSignature": "LoadDefaultConfig()",
    "MethodSourseCode": "\r\n\tprotected virtual void LoadDefaultConfig()\r\n\t{\r\n\t\tCallHook(\u0022LoadDefaultConfig\u0022, null);\r\n\t}\r\n",
    "ClassName": "Plugin",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPluginUnloaded(Oxide.Core.Plugins.Plugin plugin)",
    "MethodSignature": "UnloadPlugin(string name)",
    "MethodSourseCode": "\r\n\tpublic bool UnloadPlugin(string name)\r\n\t{\r\n\t\tPlugin plugin = RootPluginManager.GetPlugin(name);\r\n\t\tif (plugin == null)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\textensionManager.GetPluginLoaders().SingleOrDefault((PluginLoader l) =\u003E l.LoadedPlugins.ContainsKey(name))?.Unloading(plugin);\r\n\t\tRootPluginManager.RemovePlugin(plugin);\r\n\t\tif (plugin.IsLoaded)\r\n\t\t{\r\n\t\t\tCallHook(\u0022OnPluginUnloaded\u0022, plugin);\r\n\t\t}\r\n\t\tplugin.IsLoaded = false;\r\n\t\tLogInfo(\u0022Unloaded plugin {0} v{1} by {2}\u0022, plugin.Title, plugin.Version, plugin.Author);\r\n\t\treturn true;\r\n\t}\r\n",
    "ClassName": "OxideMod",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "OnUserPermissionGranted(string id, string perm)",
    "MethodSignature": "GrantUserPermission(string id, string perm, Plugin owner)",
    "MethodSourseCode": "\r\n\t[LibraryFunction(\u0022GrantUserPermission\u0022)]\r\n\tpublic void GrantUserPermission(string id, string perm, Plugin owner)\r\n\t{\r\n\t\tif (!PermissionExists(perm, owner))\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tUserData data = GetUserData(id);\r\n\t\tperm = perm.ToLower();\r\n\t\tif (perm.EndsWith(\u0022*\u0022))\r\n\t\t{\r\n\t\t\tHashSet\u003Cstring\u003E value;\r\n\t\t\tif (owner == null)\r\n\t\t\t{\r\n\t\t\t\tvalue = new HashSet\u003Cstring\u003E(permset.Values.SelectMany((HashSet\u003Cstring\u003E v) =\u003E v));\r\n\t\t\t}\r\n\t\t\telse if (!permset.TryGetValue(owner, out value))\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tif (perm.Equals(\u0022*\u0022))\r\n\t\t\t{\r\n\t\t\t\tif (!value.Aggregate(seed: false, (bool c, string s) =\u003E c | data.Perms.Add(s)))\r\n\t\t\t\t{\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tperm = perm.TrimEnd(\u0027*\u0027);\r\n\t\t\t\tif (!value.Where((string s) =\u003E s.StartsWith(perm)).Aggregate(seed: false, (bool c, string s) =\u003E c | data.Perms.Add(s)))\r\n\t\t\t\t{\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tSaveUsers();\r\n\t\t}\r\n\t\telse if (data.Perms.Add(perm))\r\n\t\t{\r\n\t\t\tSaveUsers();\r\n\t\t\tInterface.Call(\u0022OnUserPermissionGranted\u0022, id, perm);\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "Permission",
    "HookLineInvoke": 41
  },
  {
    "HookSignature": "OnServerShutdown()",
    "MethodSignature": "OnApplicationQuit()",
    "MethodSourseCode": "\r\n\tprivate void OnApplicationQuit()\r\n\t{\r\n\t\tif (!oxideMod.IsShuttingDown)\r\n\t\t{\r\n\t\t\tInterface.Call(\u0022OnServerShutdown\u0022);\r\n\t\t\tInterface.Oxide.OnShutdown();\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "UnityScript",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "CanUserLogin(string username, string text, string text2)",
    "MethodSignature": "IOnUserApprove(Connection connection)",
    "MethodSourseCode": "\r\n\t[HookMethod(\u0022IOnUserApprove\u0022)]\r\n\tprivate object IOnUserApprove(Connection connection)\r\n\t{\r\n\t\tstring username = connection.username;\r\n\t\tstring text = connection.userid.ToString();\r\n\t\tint authLevel = connection.authLevel;\r\n\t\tstring text2 = Regex.Replace(connection.ipaddress, ipPattern, \u0022\u0022);\r\n\t\tif (permission.IsLoaded)\r\n\t\t{\r\n\t\t\tpermission.UpdateNickname(text, username);\r\n\t\t\tOxideConfig.DefaultGroups defaultGroups = Interface.Oxide.Config.Options.DefaultGroups;\r\n\t\t\tif (!permission.UserHasGroup(text, defaultGroups.Players))\r\n\t\t\t{\r\n\t\t\t\tpermission.AddUserGroup(text, defaultGroups.Players);\r\n\t\t\t}\r\n\t\t\tif (authLevel == 2 \u0026\u0026 !permission.UserHasGroup(text, defaultGroups.Administrators))\r\n\t\t\t{\r\n\t\t\t\tpermission.AddUserGroup(text, defaultGroups.Administrators);\r\n\t\t\t}\r\n\t\t}\r\n\t\tCovalence.PlayerManager.PlayerJoin(connection.userid, username);\r\n\t\tobject obj = Interface.Call(\u0022CanClientLogin\u0022, connection);\r\n\t\tobject obj2 = Interface.Call(\u0022CanUserLogin\u0022, username, text, text2);\r\n\t\tobject obj3 = obj ?? obj2;\r\n\t\tif (obj3 is string || (obj3 is bool \u0026\u0026 !(bool)obj3))\r\n\t\t{\r\n\t\t\tConnectionAuth.Reject(connection, (obj3 is string) ? obj3.ToString() : lang.GetMessage(\u0022ConnectionRejected\u0022, this, text));\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tobject obj4 = Interface.Call(\u0022OnUserApprove\u0022, connection);\r\n\t\tobject obj5 = Interface.Call(\u0022OnUserApproved\u0022, username, text, text2);\r\n\t\treturn obj4 ?? obj5;\r\n\t}\r\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 23
  },
  {
    "HookSignature": "OnUserRespawned(Oxide.Core.Libraries.Covalence.IPlayer iPlayer)",
    "MethodSignature": "OnPlayerRespawned(BasePlayer player)",
    "MethodSourseCode": "\r\n\t[HookMethod(\u0022OnPlayerRespawned\u0022)]\r\n\tprivate void OnPlayerRespawned(BasePlayer player)\r\n\t{\r\n\t\tIPlayer iPlayer = player.IPlayer;\r\n\t\tif (iPlayer != null)\r\n\t\t{\r\n\t\t\tInterface.Call(\u0022OnUserRespawned\u0022, iPlayer);\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnUserBanned(string name, string text, string player?Address ?? \u00220\u0022, string reason)",
    "MethodSignature": "IOnServerUsersSet(ulong steamId, ServerUsers.UserGroup group, string name, string reason)",
    "MethodSourseCode": "\r\n\t[HookMethod(\u0022IOnServerUsersSet\u0022)]\r\n\tprivate void IOnServerUsersSet(ulong steamId, ServerUsers.UserGroup group, string name, string reason)\r\n\t{\r\n\t\tif (serverInitialized)\r\n\t\t{\r\n\t\t\tstring text = steamId.ToString();\r\n\t\t\tIPlayer player = Covalence.PlayerManager.FindPlayerById(text);\r\n\t\t\tif (group == ServerUsers.UserGroup.Banned)\r\n\t\t\t{\r\n\t\t\t\tInterface.Oxide.CallHook(\u0022OnPlayerBanned\u0022, name, steamId, player?.Address ?? \u00220\u0022, reason);\r\n\t\t\t\tInterface.Oxide.CallHook(\u0022OnUserBanned\u0022, name, text, player?.Address ?? \u00220\u0022, reason);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnUserRespawn(Oxide.Core.Libraries.Covalence.IPlayer iPlayer)",
    "MethodSignature": "OnPlayerRespawn(BasePlayer player)",
    "MethodSourseCode": "\r\n\t[HookMethod(\u0022OnPlayerRespawn\u0022)]\r\n\tprivate object OnPlayerRespawn(BasePlayer player)\r\n\t{\r\n\t\tIPlayer iPlayer = player.IPlayer;\r\n\t\tif (iPlayer == null)\r\n\t\t{\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\treturn Interface.Call(\u0022OnUserRespawn\u0022, iPlayer);\r\n\t}\r\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnUserKicked(Oxide.Core.Libraries.Covalence.IPlayer playerIPlayer, string reason)",
    "MethodSignature": "OnPlayerKicked(BasePlayer player, string reason)",
    "MethodSourseCode": "\r\n\t[HookMethod(\u0022OnPlayerKicked\u0022)]\r\n\tprivate void OnPlayerKicked(BasePlayer player, string reason)\r\n\t{\r\n\t\tif (player.IPlayer != null)\r\n\t\t{\r\n\t\t\tInterface.Oxide.CallHook(\u0022OnUserKicked\u0022, player.IPlayer, reason);\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnUserChat(Oxide.Core.Libraries.Covalence.IPlayer iPlayer, string argGetString)",
    "MethodSignature": "OnPlayerChat(ConsoleSystem.Arg arg)",
    "MethodSourseCode": "\r\n\t[HookMethod(\u0022OnPlayerChat\u0022)]\r\n\tprivate object OnPlayerChat(ConsoleSystem.Arg arg)\r\n\t{\r\n\t\tIPlayer iPlayer = (arg.Connection.player as BasePlayer).IPlayer;\r\n\t\tif (!string.IsNullOrEmpty(arg.GetString(0)))\r\n\t\t{\r\n\t\t\treturn Interface.Call(\u0022OnUserChat\u0022, iPlayer, arg.GetString(0));\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnPlayerBanned(string connectionUsername, ulong connectionUserid, string text, string text2)",
    "MethodSignature": "IOnPlayerBanned(Connection connection)",
    "MethodSourseCode": "\r\n\t[HookMethod(\u0022IOnPlayerBanned\u0022)]\r\n\tprivate void IOnPlayerBanned(Connection connection)\r\n\t{\r\n\t\tstring text = Regex.Replace(connection.ipaddress, ipPattern, \u0022\u0022) ?? \u00220\u0022;\r\n\t\tstring text2 = connection.authStatus ?? \u0022Unknown\u0022;\r\n\t\tInterface.Oxide.CallHook(\u0022OnPlayerBanned\u0022, connection.username, connection.userid, text, text2);\r\n\t\tInterface.Oxide.CallHook(\u0022OnUserBanned\u0022, connection.username, connection.userid.ToString(), text, text2);\r\n\t}\r\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnEntityTakeDamage(BasePlayer player, HitInfo info)",
    "MethodSignature": "IOnBasePlayerAttacked(BasePlayer player, HitInfo info)",
    "MethodSourseCode": "\r\n\t[HookMethod(\u0022IOnBasePlayerAttacked\u0022)]\r\n\tprivate object IOnBasePlayerAttacked(BasePlayer player, HitInfo info)\r\n\t{\r\n\t\tif (!serverInitialized || player == null || info == null || player.IsDead() || isPlayerTakingDamage)\r\n\t\t{\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tif (Interface.Call(\u0022OnEntityTakeDamage\u0022, player, info) != null)\r\n\t\t{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tisPlayerTakingDamage = true;\r\n\t\ttry\r\n\t\t{\r\n\t\t\tplayer.OnAttacked(info);\r\n\t\t}\r\n\t\tfinally\r\n\t\t{\r\n\t\t\tisPlayerTakingDamage = false;\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnUserUnbanned(string player?Name ?? \u0022Unnamed\u0022, string text, string player?Address ?? \u00220\u0022)",
    "MethodSignature": "IOnServerUsersRemove(ulong steamId)",
    "MethodSourseCode": "\r\n\t[HookMethod(\u0022IOnServerUsersRemove\u0022)]\r\n\tprivate void IOnServerUsersRemove(ulong steamId)\r\n\t{\r\n\t\tif (serverInitialized)\r\n\t\t{\r\n\t\t\tstring text = steamId.ToString();\r\n\t\t\tIPlayer player = Covalence.PlayerManager.FindPlayerById(text);\r\n\t\t\tif (ServerUsers.Is(steamId, ServerUsers.UserGroup.Banned))\r\n\t\t\t{\r\n\t\t\t\tInterface.Oxide.CallHook(\u0022OnPlayerUnbanned\u0022, player?.Name ?? \u0022Unnamed\u0022, steamId, player?.Address ?? \u00220\u0022);\r\n\t\t\t\tInterface.Oxide.CallHook(\u0022OnUserUnbanned\u0022, player?.Name ?? \u0022Unnamed\u0022, text, player?.Address ?? \u00220\u0022);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnPlayerCommand(ConsoleSystem.Arg arg)",
    "MethodSignature": "IOnServerCommand(ConsoleSystem.Arg arg)",
    "MethodSourseCode": "\r\n\t[HookMethod(\u0022IOnServerCommand\u0022)]\r\n\tprivate object IOnServerCommand(ConsoleSystem.Arg arg)\r\n\t{\r\n\t\tif (arg?.cmd == null)\r\n\t\t{\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tif (Interface.Call(\u0022OnServerCommand\u0022, arg) != null)\r\n\t\t{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tstring @string = arg.GetString(0);\r\n\t\tif (string.IsNullOrEmpty(@string))\r\n\t\t{\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tBasePlayer basePlayer = arg.Connection?.player as BasePlayer;\r\n\t\tif (basePlayer == null)\r\n\t\t{\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tstring argstr = @string.TrimStart(\u0027/\u0027);\r\n\t\tParseCommand(argstr, out var command, out var args);\r\n\t\tif (command == null)\r\n\t\t{\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tIPlayer iPlayer = basePlayer.IPlayer;\r\n\t\tif (iPlayer == null)\r\n\t\t{\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tobject obj = Interface.Call(\u0022OnPlayerCommand\u0022, arg);\r\n\t\tobject obj2 = Interface.Call(\u0022OnUserCommand\u0022, iPlayer, command, args);\r\n\t\tif (obj != null || obj2 != null)\r\n\t\t{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tif (arg.cmd.FullName != \u0022chat.say\u0022)\r\n\t\t{\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tif (@string[0] != \u0027/\u0027)\r\n\t\t{\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tif (!Covalence.CommandSystem.HandleChatMessage(iPlayer, @string) \u0026\u0026 !cmdlib.HandleChatCommand(basePlayer, command, args))\r\n\t\t{\r\n\t\t\tif (!Interface.Oxide.Config.Options.Modded)\r\n\t\t\t{\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t\tiPlayer.Reply(lang.GetMessage(\u0022UnknownCommand\u0022, this, iPlayer.Id), command);\r\n\t\t\targ.ReplyWith(string.Empty);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 33
  },
  {
    "HookSignature": "OnUserConnected(Oxide.Core.Libraries.Covalence.IPlayer player2)",
    "MethodSignature": "OnPlayerInit(BasePlayer player)",
    "MethodSourseCode": "\r\n\t[HookMethod(\u0022OnPlayerInit\u0022)]\r\n\tprivate void OnPlayerInit(BasePlayer player)\r\n\t{\r\n\t\tlang.SetLanguage(player.net.connection.info.GetString(\u0022global.language\u0022, \u0022en\u0022), player.UserIDString);\r\n\t\tCovalence.PlayerManager.PlayerConnected(player);\r\n\t\tIPlayer player2 = Covalence.PlayerManager.FindPlayerById(player.UserIDString);\r\n\t\tif (player2 != null)\r\n\t\t{\r\n\t\t\tplayer.IPlayer = player2;\r\n\t\t\tInterface.Call(\u0022OnUserConnected\u0022, player2);\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnUserApprove(Network.Connection connection)",
    "MethodSignature": "IOnUserApprove(Connection connection)",
    "MethodSourseCode": "\r\n\t[HookMethod(\u0022IOnUserApprove\u0022)]\r\n\tprivate object IOnUserApprove(Connection connection)\r\n\t{\r\n\t\tstring username = connection.username;\r\n\t\tstring text = connection.userid.ToString();\r\n\t\tint authLevel = connection.authLevel;\r\n\t\tstring text2 = Regex.Replace(connection.ipaddress, ipPattern, \u0022\u0022);\r\n\t\tif (permission.IsLoaded)\r\n\t\t{\r\n\t\t\tpermission.UpdateNickname(text, username);\r\n\t\t\tOxideConfig.DefaultGroups defaultGroups = Interface.Oxide.Config.Options.DefaultGroups;\r\n\t\t\tif (!permission.UserHasGroup(text, defaultGroups.Players))\r\n\t\t\t{\r\n\t\t\t\tpermission.AddUserGroup(text, defaultGroups.Players);\r\n\t\t\t}\r\n\t\t\tif (authLevel == 2 \u0026\u0026 !permission.UserHasGroup(text, defaultGroups.Administrators))\r\n\t\t\t{\r\n\t\t\t\tpermission.AddUserGroup(text, defaultGroups.Administrators);\r\n\t\t\t}\r\n\t\t}\r\n\t\tCovalence.PlayerManager.PlayerJoin(connection.userid, username);\r\n\t\tobject obj = Interface.Call(\u0022CanClientLogin\u0022, connection);\r\n\t\tobject obj2 = Interface.Call(\u0022CanUserLogin\u0022, username, text, text2);\r\n\t\tobject obj3 = obj ?? obj2;\r\n\t\tif (obj3 is string || (obj3 is bool \u0026\u0026 !(bool)obj3))\r\n\t\t{\r\n\t\t\tConnectionAuth.Reject(connection, (obj3 is string) ? obj3.ToString() : lang.GetMessage(\u0022ConnectionRejected\u0022, this, text));\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tobject obj4 = Interface.Call(\u0022OnUserApprove\u0022, connection);\r\n\t\tobject obj5 = Interface.Call(\u0022OnUserApproved\u0022, username, text, text2);\r\n\t\treturn obj4 ?? obj5;\r\n\t}\r\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 30
  },
  {
    "HookSignature": "OnLootEntity(BasePlayer sourceGetComponent\u003CBasePlayer\u003E, BaseEntity entity)",
    "MethodSignature": "IOnLootEntity(PlayerLoot source, BaseEntity entity)",
    "MethodSourseCode": "\r\n\t[HookMethod(\u0022IOnLootEntity\u0022)]\r\n\tprivate void IOnLootEntity(PlayerLoot source, BaseEntity entity)\r\n\t{\r\n\t\tInterface.Call(\u0022OnLootEntity\u0022, source.GetComponent\u003CBasePlayer\u003E(), entity);\r\n\t}\r\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnPlayerRevive(BasePlayer toolGetOwnerPlayer, BasePlayer target)",
    "MethodSignature": "IOnPlayerRevive(MedicalTool tool, BasePlayer target)",
    "MethodSourseCode": "\r\n\t[HookMethod(\u0022IOnPlayerRevive\u0022)]\r\n\tprivate object IOnPlayerRevive(MedicalTool tool, BasePlayer target)\r\n\t{\r\n\t\treturn Interface.Call(\u0022OnPlayerRevive\u0022, tool.GetOwnerPlayer(), target);\r\n\t}\r\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnLootPlayer(BasePlayer sourceGetComponent\u003CBasePlayer\u003E, BasePlayer target)",
    "MethodSignature": "IOnLootPlayer(PlayerLoot source, BasePlayer target)",
    "MethodSourseCode": "\r\n\t[HookMethod(\u0022IOnLootPlayer\u0022)]\r\n\tprivate void IOnLootPlayer(PlayerLoot source, BasePlayer target)\r\n\t{\r\n\t\tInterface.Call(\u0022OnLootPlayer\u0022, source.GetComponent\u003CBasePlayer\u003E(), target);\r\n\t}\r\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnPlayerAttack(BasePlayer meleeGetOwnerPlayer, HitInfo info)",
    "MethodSignature": "IOnPlayerAttack(BaseMelee melee, HitInfo info)",
    "MethodSourseCode": "\r\n\t[HookMethod(\u0022IOnPlayerAttack\u0022)]\r\n\tprivate object IOnPlayerAttack(BaseMelee melee, HitInfo info)\r\n\t{\r\n\t\treturn Interface.Call(\u0022OnPlayerAttack\u0022, melee.GetOwnerPlayer(), info);\r\n\t}\r\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnServerCommand(ConsoleSystem.Arg arg)",
    "MethodSignature": "IOnServerCommand(ConsoleSystem.Arg arg)",
    "MethodSourseCode": "\r\n\t[HookMethod(\u0022IOnServerCommand\u0022)]\r\n\tprivate object IOnServerCommand(ConsoleSystem.Arg arg)\r\n\t{\r\n\t\tif (arg?.cmd == null)\r\n\t\t{\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tif (Interface.Call(\u0022OnServerCommand\u0022, arg) != null)\r\n\t\t{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tstring @string = arg.GetString(0);\r\n\t\tif (string.IsNullOrEmpty(@string))\r\n\t\t{\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tBasePlayer basePlayer = arg.Connection?.player as BasePlayer;\r\n\t\tif (basePlayer == null)\r\n\t\t{\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tstring argstr = @string.TrimStart(\u0027/\u0027);\r\n\t\tParseCommand(argstr, out var command, out var args);\r\n\t\tif (command == null)\r\n\t\t{\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tIPlayer iPlayer = basePlayer.IPlayer;\r\n\t\tif (iPlayer == null)\r\n\t\t{\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tobject obj = Interface.Call(\u0022OnPlayerCommand\u0022, arg);\r\n\t\tobject obj2 = Interface.Call(\u0022OnUserCommand\u0022, iPlayer, command, args);\r\n\t\tif (obj != null || obj2 != null)\r\n\t\t{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tif (arg.cmd.FullName != \u0022chat.say\u0022)\r\n\t\t{\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tif (@string[0] != \u0027/\u0027)\r\n\t\t{\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tif (!Covalence.CommandSystem.HandleChatMessage(iPlayer, @string) \u0026\u0026 !cmdlib.HandleChatCommand(basePlayer, command, args))\r\n\t\t{\r\n\t\t\tif (!Interface.Oxide.Config.Options.Modded)\r\n\t\t\t{\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t\tiPlayer.Reply(lang.GetMessage(\u0022UnknownCommand\u0022, this, iPlayer.Id), command);\r\n\t\t\targ.ReplyWith(string.Empty);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnPlayerInput(BasePlayer player, InputState playerServerInput)",
    "MethodSignature": "OnPlayerTick(BasePlayer player)",
    "MethodSourseCode": "\r\n\t[HookMethod(\u0022OnPlayerTick\u0022)]\r\n\tprivate object OnPlayerTick(BasePlayer player)\r\n\t{\r\n\t\treturn Interface.Call(\u0022OnPlayerInput\u0022, player, player.serverInput);\r\n\t}\r\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)",
    "MethodSignature": "IOnBaseCombatEntityHurt(BaseCombatEntity entity, HitInfo info)",
    "MethodSourseCode": "\r\n\t[HookMethod(\u0022IOnBaseCombatEntityHurt\u0022)]\r\n\tprivate object IOnBaseCombatEntityHurt(BaseCombatEntity entity, HitInfo info)\r\n\t{\r\n\t\tif (!(entity is BasePlayer))\r\n\t\t{\r\n\t\t\treturn Interface.Call(\u0022OnEntityTakeDamage\u0022, entity, info);\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnUserDisconnected(Oxide.Core.Libraries.Covalence.IPlayer iPlayer, string reason)",
    "MethodSignature": "OnPlayerDisconnected(BasePlayer player, string reason)",
    "MethodSourseCode": "\r\n\t[HookMethod(\u0022OnPlayerDisconnected\u0022)]\r\n\tprivate void OnPlayerDisconnected(BasePlayer player, string reason)\r\n\t{\r\n\t\tIPlayer iPlayer = player.IPlayer;\r\n\t\tif (iPlayer != null)\r\n\t\t{\r\n\t\t\tInterface.Call(\u0022OnUserDisconnected\u0022, iPlayer, reason);\r\n\t\t}\r\n\t\tCovalence.PlayerManager.PlayerDisconnected(player);\r\n\t}\r\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnUserBanned(string connectionUsername, string connectionUserid, string text, string text2)",
    "MethodSignature": "IOnPlayerBanned(Connection connection)",
    "MethodSourseCode": "\r\n\t[HookMethod(\u0022IOnPlayerBanned\u0022)]\r\n\tprivate void IOnPlayerBanned(Connection connection)\r\n\t{\r\n\t\tstring text = Regex.Replace(connection.ipaddress, ipPattern, \u0022\u0022) ?? \u00220\u0022;\r\n\t\tstring text2 = connection.authStatus ?? \u0022Unknown\u0022;\r\n\t\tInterface.Oxide.CallHook(\u0022OnPlayerBanned\u0022, connection.username, connection.userid, text, text2);\r\n\t\tInterface.Oxide.CallHook(\u0022OnUserBanned\u0022, connection.username, connection.userid.ToString(), text, text2);\r\n\t}\r\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnUserCommand(Oxide.Core.Libraries.Covalence.IPlayer iPlayer, string command, string[] args)",
    "MethodSignature": "IOnServerCommand(ConsoleSystem.Arg arg)",
    "MethodSourseCode": "\r\n\t[HookMethod(\u0022IOnServerCommand\u0022)]\r\n\tprivate object IOnServerCommand(ConsoleSystem.Arg arg)\r\n\t{\r\n\t\tif (arg?.cmd == null)\r\n\t\t{\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tif (Interface.Call(\u0022OnServerCommand\u0022, arg) != null)\r\n\t\t{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tstring @string = arg.GetString(0);\r\n\t\tif (string.IsNullOrEmpty(@string))\r\n\t\t{\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tBasePlayer basePlayer = arg.Connection?.player as BasePlayer;\r\n\t\tif (basePlayer == null)\r\n\t\t{\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tstring argstr = @string.TrimStart(\u0027/\u0027);\r\n\t\tParseCommand(argstr, out var command, out var args);\r\n\t\tif (command == null)\r\n\t\t{\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tIPlayer iPlayer = basePlayer.IPlayer;\r\n\t\tif (iPlayer == null)\r\n\t\t{\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tobject obj = Interface.Call(\u0022OnPlayerCommand\u0022, arg);\r\n\t\tobject obj2 = Interface.Call(\u0022OnUserCommand\u0022, iPlayer, command, args);\r\n\t\tif (obj != null || obj2 != null)\r\n\t\t{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tif (arg.cmd.FullName != \u0022chat.say\u0022)\r\n\t\t{\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tif (@string[0] != \u0027/\u0027)\r\n\t\t{\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tif (!Covalence.CommandSystem.HandleChatMessage(iPlayer, @string) \u0026\u0026 !cmdlib.HandleChatCommand(basePlayer, command, args))\r\n\t\t{\r\n\t\t\tif (!Interface.Oxide.Config.Options.Modded)\r\n\t\t\t{\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t\tiPlayer.Reply(lang.GetMessage(\u0022UnknownCommand\u0022, this, iPlayer.Id), command);\r\n\t\t\targ.ReplyWith(string.Empty);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 34
  },
  {
    "HookSignature": "OnLoseCondition(object[] array)",
    "MethodSignature": "IOnLoseCondition(Item item, float amount)",
    "MethodSourseCode": "\r\n\t[HookMethod(\u0022IOnLoseCondition\u0022)]\r\n\tprivate object IOnLoseCondition(Item item, float amount)\r\n\t{\r\n\t\tobject[] array = new object[2] { item, amount };\r\n\t\tInterface.Call(\u0022OnLoseCondition\u0022, array);\r\n\t\tamount = (float)array[1];\r\n\t\tfloat condition = item.condition;\r\n\t\titem.condition -= amount;\r\n\t\tif (item.condition \u003C= 0f \u0026\u0026 item.condition \u003C condition)\r\n\t\t{\r\n\t\t\titem.OnBroken();\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnLootItem(BasePlayer sourceGetComponent\u003CBasePlayer\u003E, Item item)",
    "MethodSignature": "IOnLootItem(PlayerLoot source, Item item)",
    "MethodSourseCode": "\r\n\t[HookMethod(\u0022IOnLootItem\u0022)]\r\n\tprivate void IOnLootItem(PlayerLoot source, Item item)\r\n\t{\r\n\t\tInterface.Call(\u0022OnLootItem\u0022, source.GetComponent\u003CBasePlayer\u003E(), item);\r\n\t}\r\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnStructureDemolish(BuildingBlock block, BasePlayer player, bool true)",
    "MethodSignature": "IOnStructureImmediateDemolish(BuildingBlock block, BasePlayer player)",
    "MethodSourseCode": "\r\n\t[HookMethod(\u0022IOnStructureImmediateDemolish\u0022)]\r\n\tprivate object IOnStructureImmediateDemolish(BuildingBlock block, BasePlayer player)\r\n\t{\r\n\t\treturn Interface.Call(\u0022OnStructureDemolish\u0022, block, player, true);\r\n\t}\r\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnUserApproved(string username, string text, string text2)",
    "MethodSignature": "IOnUserApprove(Connection connection)",
    "MethodSourseCode": "\r\n\t[HookMethod(\u0022IOnUserApprove\u0022)]\r\n\tprivate object IOnUserApprove(Connection connection)\r\n\t{\r\n\t\tstring username = connection.username;\r\n\t\tstring text = connection.userid.ToString();\r\n\t\tint authLevel = connection.authLevel;\r\n\t\tstring text2 = Regex.Replace(connection.ipaddress, ipPattern, \u0022\u0022);\r\n\t\tif (permission.IsLoaded)\r\n\t\t{\r\n\t\t\tpermission.UpdateNickname(text, username);\r\n\t\t\tOxideConfig.DefaultGroups defaultGroups = Interface.Oxide.Config.Options.DefaultGroups;\r\n\t\t\tif (!permission.UserHasGroup(text, defaultGroups.Players))\r\n\t\t\t{\r\n\t\t\t\tpermission.AddUserGroup(text, defaultGroups.Players);\r\n\t\t\t}\r\n\t\t\tif (authLevel == 2 \u0026\u0026 !permission.UserHasGroup(text, defaultGroups.Administrators))\r\n\t\t\t{\r\n\t\t\t\tpermission.AddUserGroup(text, defaultGroups.Administrators);\r\n\t\t\t}\r\n\t\t}\r\n\t\tCovalence.PlayerManager.PlayerJoin(connection.userid, username);\r\n\t\tobject obj = Interface.Call(\u0022CanClientLogin\u0022, connection);\r\n\t\tobject obj2 = Interface.Call(\u0022CanUserLogin\u0022, username, text, text2);\r\n\t\tobject obj3 = obj ?? obj2;\r\n\t\tif (obj3 is string || (obj3 is bool \u0026\u0026 !(bool)obj3))\r\n\t\t{\r\n\t\t\tConnectionAuth.Reject(connection, (obj3 is string) ? obj3.ToString() : lang.GetMessage(\u0022ConnectionRejected\u0022, this, text));\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tobject obj4 = Interface.Call(\u0022OnUserApprove\u0022, connection);\r\n\t\tobject obj5 = Interface.Call(\u0022OnUserApproved\u0022, username, text, text2);\r\n\t\treturn obj4 ?? obj5;\r\n\t}\r\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 31
  },
  {
    "HookSignature": "OnPlayerBanned(string name, ulong steamId, string player?Address ?? \u00220\u0022, string reason)",
    "MethodSignature": "IOnServerUsersSet(ulong steamId, ServerUsers.UserGroup group, string name, string reason)",
    "MethodSourseCode": "\r\n\t[HookMethod(\u0022IOnServerUsersSet\u0022)]\r\n\tprivate void IOnServerUsersSet(ulong steamId, ServerUsers.UserGroup group, string name, string reason)\r\n\t{\r\n\t\tif (serverInitialized)\r\n\t\t{\r\n\t\t\tstring text = steamId.ToString();\r\n\t\t\tIPlayer player = Covalence.PlayerManager.FindPlayerById(text);\r\n\t\t\tif (group == ServerUsers.UserGroup.Banned)\r\n\t\t\t{\r\n\t\t\t\tInterface.Oxide.CallHook(\u0022OnPlayerBanned\u0022, name, steamId, player?.Address ?? \u00220\u0022, reason);\r\n\t\t\t\tInterface.Oxide.CallHook(\u0022OnUserBanned\u0022, name, text, player?.Address ?? \u00220\u0022, reason);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnRconCommand(System.Net.IPAddress sender, string text, string[] (arrayLength \u003E 1) ? arraySkipToArray : null)",
    "MethodSignature": "IOnRconCommand(IPAddress sender, string message)",
    "MethodSourseCode": "\r\n\t[HookMethod(\u0022IOnRconCommand\u0022)]\r\n\tprivate object IOnRconCommand(IPAddress sender, string message)\r\n\t{\r\n\t\tif (string.IsNullOrEmpty(message))\r\n\t\t{\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tRemoteMessage message2 = RemoteMessage.GetMessage(message);\r\n\t\tif (message2 == null)\r\n\t\t{\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tstring[] array = message2.Message.Split(\u0027 \u0027);\r\n\t\tstring text = array[0];\r\n\t\tif (Interface.Call(\u0022OnRconCommand\u0022, sender, text, (array.Length \u003E 1) ? array.Skip(1).ToArray() : null) != null)\r\n\t\t{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 15
  },
  {
    "HookSignature": "OnPlayerUnbanned(string player?Name ?? \u0022Unnamed\u0022, ulong steamId, string player?Address ?? \u00220\u0022)",
    "MethodSignature": "IOnServerUsersRemove(ulong steamId)",
    "MethodSourseCode": "\r\n\t[HookMethod(\u0022IOnServerUsersRemove\u0022)]\r\n\tprivate void IOnServerUsersRemove(ulong steamId)\r\n\t{\r\n\t\tif (serverInitialized)\r\n\t\t{\r\n\t\t\tstring text = steamId.ToString();\r\n\t\t\tIPlayer player = Covalence.PlayerManager.FindPlayerById(text);\r\n\t\t\tif (ServerUsers.Is(steamId, ServerUsers.UserGroup.Banned))\r\n\t\t\t{\r\n\t\t\t\tInterface.Oxide.CallHook(\u0022OnPlayerUnbanned\u0022, player?.Name ?? \u0022Unnamed\u0022, steamId, player?.Address ?? \u00220\u0022);\r\n\t\t\t\tInterface.Oxide.CallHook(\u0022OnUserUnbanned\u0022, player?.Name ?? \u0022Unnamed\u0022, text, player?.Address ?? \u00220\u0022);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnServerInitialized()",
    "MethodSignature": "OnPluginLoaded(Plugin plugin)",
    "MethodSourseCode": "\r\n\t[HookMethod(\u0022OnPluginLoaded\u0022)]\r\n\tprivate void OnPluginLoaded(Plugin plugin)\r\n\t{\r\n\t\tif (serverInitialized)\r\n\t\t{\r\n\t\t\tplugin.CallHook(\u0022OnServerInitialized\u0022);\r\n\t\t}\r\n\t}\r\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "CanClientLogin(Network.Connection connection)",
    "MethodSignature": "IOnUserApprove(Connection connection)",
    "MethodSourseCode": "\r\n\t[HookMethod(\u0022IOnUserApprove\u0022)]\r\n\tprivate object IOnUserApprove(Connection connection)\r\n\t{\r\n\t\tstring username = connection.username;\r\n\t\tstring text = connection.userid.ToString();\r\n\t\tint authLevel = connection.authLevel;\r\n\t\tstring text2 = Regex.Replace(connection.ipaddress, ipPattern, \u0022\u0022);\r\n\t\tif (permission.IsLoaded)\r\n\t\t{\r\n\t\t\tpermission.UpdateNickname(text, username);\r\n\t\t\tOxideConfig.DefaultGroups defaultGroups = Interface.Oxide.Config.Options.DefaultGroups;\r\n\t\t\tif (!permission.UserHasGroup(text, defaultGroups.Players))\r\n\t\t\t{\r\n\t\t\t\tpermission.AddUserGroup(text, defaultGroups.Players);\r\n\t\t\t}\r\n\t\t\tif (authLevel == 2 \u0026\u0026 !permission.UserHasGroup(text, defaultGroups.Administrators))\r\n\t\t\t{\r\n\t\t\t\tpermission.AddUserGroup(text, defaultGroups.Administrators);\r\n\t\t\t}\r\n\t\t}\r\n\t\tCovalence.PlayerManager.PlayerJoin(connection.userid, username);\r\n\t\tobject obj = Interface.Call(\u0022CanClientLogin\u0022, connection);\r\n\t\tobject obj2 = Interface.Call(\u0022CanUserLogin\u0022, username, text, text2);\r\n\t\tobject obj3 = obj ?? obj2;\r\n\t\tif (obj3 is string || (obj3 is bool \u0026\u0026 !(bool)obj3))\r\n\t\t{\r\n\t\t\tConnectionAuth.Reject(connection, (obj3 is string) ? obj3.ToString() : lang.GetMessage(\u0022ConnectionRejected\u0022, this, text));\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tobject obj4 = Interface.Call(\u0022OnUserApprove\u0022, connection);\r\n\t\tobject obj5 = Interface.Call(\u0022OnUserApproved\u0022, username, text, text2);\r\n\t\treturn obj4 ?? obj5;\r\n\t}\r\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 22
  },
  {
    "HookSignature": "OnStructureDemolish(BuildingBlock block, BasePlayer player, bool false)",
    "MethodSignature": "IOnStructureDemolish(BuildingBlock block, BasePlayer player)",
    "MethodSourseCode": "\r\n\t[HookMethod(\u0022IOnStructureDemolish\u0022)]\r\n\tprivate object IOnStructureDemolish(BuildingBlock block, BasePlayer player)\r\n\t{\r\n\t\treturn Interface.Call(\u0022OnStructureDemolish\u0022, block, player, false);\r\n\t}\r\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 4
  }
]